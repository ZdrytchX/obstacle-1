Index: src/server/sv_world.c
===================================================================
--- src/server/sv_world.c	(revision 1055)
+++ src/server/sv_world.c	(working copy)
@@ -34,17 +34,17 @@
 ================
 */
 clipHandle_t SV_ClipHandleForEntity( const sharedEntity_t *ent ) {
-	if ( ent->r.bmodel ) {
-		// explicit hulls in the BSP model
-		return CM_InlineModel( ent->s.modelindex );
-	}
-	if ( ent->r.svFlags & SVF_CAPSULE ) {
-		// create a temp capsule from bounding box sizes
-		return CM_TempBoxModel( ent->r.mins, ent->r.maxs, qtrue );
-	}
+    if ( ent->r.bmodel ) {
+        // explicit hulls in the BSP model
+        return CM_InlineModel( ent->s.modelindex );
+    }
+    if ( ent->r.svFlags & SVF_CAPSULE ) {
+        // create a temp capsule from bounding box sizes
+        return CM_TempBoxModel( ent->r.mins, ent->r.maxs, qtrue );
+    }
 
-	// create a temp tree from bounding box sizes
-	return CM_TempBoxModel( ent->r.mins, ent->r.maxs, qfalse );
+    // create a temp tree from bounding box sizes
+    return CM_TempBoxModel( ent->r.mins, ent->r.maxs, qfalse );
 }
 
 
@@ -63,17 +63,17 @@
 */
 
 typedef struct worldSector_s {
-	int		axis;		// -1 = leaf node
-	float	dist;
-	struct worldSector_s	*children[2];
-	svEntity_t	*entities;
+    int     axis;       // -1 = leaf node
+    float   dist;
+    struct worldSector_s    *children[2];
+    svEntity_t  *entities;
 } worldSector_t;
 
-#define	AREA_DEPTH	4
-#define	AREA_NODES	64
+#define AREA_DEPTH  4
+#define AREA_NODES  64
 
-worldSector_t	sv_worldSectors[AREA_NODES];
-int			sv_numworldSectors;
+worldSector_t   sv_worldSectors[AREA_NODES];
+int         sv_numworldSectors;
 
 
 /*
@@ -82,19 +82,19 @@
 ===============
 */
 void SV_SectorList_f( void ) {
-	int				i, c;
-	worldSector_t	*sec;
-	svEntity_t		*ent;
+    int             i, c;
+    worldSector_t   *sec;
+    svEntity_t      *ent;
 
-	for ( i = 0 ; i < AREA_NODES ; i++ ) {
-		sec = &sv_worldSectors[i];
+    for ( i = 0 ; i < AREA_NODES ; i++ ) {
+        sec = &sv_worldSectors[i];
 
-		c = 0;
-		for ( ent = sec->entities ; ent ; ent = ent->nextEntityInWorldSector ) {
-			c++;
-		}
-		Com_Printf( "sector %i: %i entities\n", i, c );
-	}
+        c = 0;
+        for ( ent = sec->entities ; ent ; ent = ent->nextEntityInWorldSector ) {
+            c++;
+        }
+        Com_Printf( "sector %i: %i entities\n", i, c );
+    }
 }
 
 /*
@@ -105,38 +105,38 @@
 ===============
 */
 worldSector_t *SV_CreateworldSector( int depth, vec3_t mins, vec3_t maxs ) {
-	worldSector_t	*anode;
-	vec3_t		size;
-	vec3_t		mins1, maxs1, mins2, maxs2;
+    worldSector_t   *anode;
+    vec3_t      size;
+    vec3_t      mins1, maxs1, mins2, maxs2;
 
-	anode = &sv_worldSectors[sv_numworldSectors];
-	sv_numworldSectors++;
+    anode = &sv_worldSectors[sv_numworldSectors];
+    sv_numworldSectors++;
 
-	if (depth == AREA_DEPTH) {
-		anode->axis = -1;
-		anode->children[0] = anode->children[1] = NULL;
-		return anode;
-	}
-	
-	VectorSubtract (maxs, mins, size);
-	if (size[0] > size[1]) {
-		anode->axis = 0;
-	} else {
-		anode->axis = 1;
-	}
+    if (depth == AREA_DEPTH) {
+        anode->axis = -1;
+        anode->children[0] = anode->children[1] = NULL;
+        return anode;
+    }
 
-	anode->dist = 0.5 * (maxs[anode->axis] + mins[anode->axis]);
-	VectorCopy (mins, mins1);	
-	VectorCopy (mins, mins2);	
-	VectorCopy (maxs, maxs1);	
-	VectorCopy (maxs, maxs2);	
-	
-	maxs1[anode->axis] = mins2[anode->axis] = anode->dist;
-	
-	anode->children[0] = SV_CreateworldSector (depth+1, mins2, maxs2);
-	anode->children[1] = SV_CreateworldSector (depth+1, mins1, maxs1);
+    VectorSubtract (maxs, mins, size);
+    if (size[0] > size[1]) {
+        anode->axis = 0;
+    } else {
+        anode->axis = 1;
+    }
 
-	return anode;
+    anode->dist = 0.5 * (maxs[anode->axis] + mins[anode->axis]);
+    VectorCopy (mins, mins1);
+    VectorCopy (mins, mins2);
+    VectorCopy (maxs, maxs1);
+    VectorCopy (maxs, maxs2);
+
+    maxs1[anode->axis] = mins2[anode->axis] = anode->dist;
+
+    anode->children[0] = SV_CreateworldSector (depth+1, mins2, maxs2);
+    anode->children[1] = SV_CreateworldSector (depth+1, mins1, maxs1);
+
+    return anode;
 }
 
 /*
@@ -146,16 +146,16 @@
 ===============
 */
 void SV_ClearWorld( void ) {
-	clipHandle_t	h;
-	vec3_t			mins, maxs;
+    clipHandle_t    h;
+    vec3_t          mins, maxs;
 
-	Com_Memset( sv_worldSectors, 0, sizeof(sv_worldSectors) );
-	sv_numworldSectors = 0;
+    Com_Memset( sv_worldSectors, 0, sizeof(sv_worldSectors) );
+    sv_numworldSectors = 0;
 
-	// get world map bounds
-	h = CM_InlineModel( 0 );
-	CM_ModelBounds( h, mins, maxs );
-	SV_CreateworldSector( 0, mins, maxs );
+    // get world map bounds
+    h = CM_InlineModel( 0 );
+    CM_ModelBounds( h, mins, maxs );
+    SV_CreateworldSector( 0, mins, maxs );
 }
 
 
@@ -166,33 +166,33 @@
 ===============
 */
 void SV_UnlinkEntity( sharedEntity_t *gEnt ) {
-	svEntity_t		*ent;
-	svEntity_t		*scan;
-	worldSector_t	*ws;
+    svEntity_t      *ent;
+    svEntity_t      *scan;
+    worldSector_t   *ws;
 
-	ent = SV_SvEntityForGentity( gEnt );
+    ent = SV_SvEntityForGentity( gEnt );
 
-	gEnt->r.linked = qfalse;
+    gEnt->r.linked = qfalse;
 
-	ws = ent->worldSector;
-	if ( !ws ) {
-		return;		// not linked in anywhere
-	}
-	ent->worldSector = NULL;
+    ws = ent->worldSector;
+    if ( !ws ) {
+        return;     // not linked in anywhere
+    }
+    ent->worldSector = NULL;
 
-	if ( ws->entities == ent ) {
-		ws->entities = ent->nextEntityInWorldSector;
-		return;
-	}
+    if ( ws->entities == ent ) {
+        ws->entities = ent->nextEntityInWorldSector;
+        return;
+    }
 
-	for ( scan = ws->entities ; scan ; scan = scan->nextEntityInWorldSector ) {
-		if ( scan->nextEntityInWorldSector == ent ) {
-			scan->nextEntityInWorldSector = ent->nextEntityInWorldSector;
-			return;
-		}
-	}
+    for ( scan = ws->entities ; scan ; scan = scan->nextEntityInWorldSector ) {
+        if ( scan->nextEntityInWorldSector == ent ) {
+            scan->nextEntityInWorldSector = ent->nextEntityInWorldSector;
+            return;
+        }
+    }
 
-	Com_Printf( "WARNING: SV_UnlinkEntity: not found in worldSector\n" );
+    Com_Printf( "WARNING: SV_UnlinkEntity: not found in worldSector\n" );
 }
 
 
@@ -202,158 +202,158 @@
 
 ===============
 */
-#define MAX_TOTAL_ENT_LEAFS		128
+#define MAX_TOTAL_ENT_LEAFS     128
 void SV_LinkEntity( sharedEntity_t *gEnt ) {
-	worldSector_t	*node;
-	int			leafs[MAX_TOTAL_ENT_LEAFS];
-	int			cluster;
-	int			num_leafs;
-	int			i, j, k;
-	int			area;
-	int			lastLeaf;
-	float		*origin, *angles;
-	svEntity_t	*ent;
+    worldSector_t   *node;
+    int         leafs[MAX_TOTAL_ENT_LEAFS];
+    int         cluster;
+    int         num_leafs;
+    int         i, j, k;
+    int         area;
+    int         lastLeaf;
+    float       *origin, *angles;
+    svEntity_t  *ent;
 
-	ent = SV_SvEntityForGentity( gEnt );
+    ent = SV_SvEntityForGentity( gEnt );
 
-	if ( ent->worldSector ) {
-		SV_UnlinkEntity( gEnt );	// unlink from old position
-	}
+    if ( ent->worldSector ) {
+        SV_UnlinkEntity( gEnt );    // unlink from old position
+    }
 
-	// encode the size into the entityState_t for client prediction
-	if ( gEnt->r.bmodel ) {
-		gEnt->s.solid = SOLID_BMODEL;		// a solid_box will never create this value
-	} else if ( gEnt->r.contents & ( CONTENTS_SOLID | CONTENTS_BODY ) ) {
-		// assume that x/y are equal and symetric
-		i = gEnt->r.maxs[0];
-		if (i<1)
-			i = 1;
-		if (i>255)
-			i = 255;
+    // encode the size into the entityState_t for client prediction
+    if ( gEnt->r.bmodel ) {
+        gEnt->s.solid = SOLID_BMODEL;       // a solid_box will never create this value
+    } else if ( gEnt->r.contents & ( CONTENTS_SOLID | CONTENTS_BODY | CONTENTS_CORPSE ) ) {
+        // assume that x/y are equal and symetric
+        i = gEnt->r.maxs[0];
+        if (i<1)
+            i = 1;
+        if (i>255)
+            i = 255;
 
-		// z is not symetric
-		j = (-gEnt->r.mins[2]);
-		if (j<1)
-			j = 1;
-		if (j>255)
-			j = 255;
+        // z is not symetric
+        j = (-gEnt->r.mins[2]);
+        if (j<1)
+            j = 1;
+        if (j>255)
+            j = 255;
 
-		// and z maxs can be negative...
-		k = (gEnt->r.maxs[2]+32);
-		if (k<1)
-			k = 1;
-		if (k>255)
-			k = 255;
+        // and z maxs can be negative...
+        k = (gEnt->r.maxs[2]+32);
+        if (k<1)
+            k = 1;
+        if (k>255)
+            k = 255;
 
-		gEnt->s.solid = (k<<16) | (j<<8) | i;
-	} else {
-		gEnt->s.solid = 0;
-	}
+        gEnt->s.solid = (k<<16) | (j<<8) | i;
+    } else {
+        gEnt->s.solid = 0;
+    }
 
-	// get the position
-	origin = gEnt->r.currentOrigin;
-	angles = gEnt->r.currentAngles;
+    // get the position
+    origin = gEnt->r.currentOrigin;
+    angles = gEnt->r.currentAngles;
 
-	// set the abs box
-	if ( gEnt->r.bmodel && (angles[0] || angles[1] || angles[2]) ) {
-		// expand for rotation
-		float		max;
-		int			i;
+    // set the abs box
+    if ( gEnt->r.bmodel && (angles[0] || angles[1] || angles[2]) ) {
+        // expand for rotation
+        float       max;
+        int         i;
 
-		max = RadiusFromBounds( gEnt->r.mins, gEnt->r.maxs );
-		for (i=0 ; i<3 ; i++) {
-			gEnt->r.absmin[i] = origin[i] - max;
-			gEnt->r.absmax[i] = origin[i] + max;
-		}
-	} else {
-		// normal
-		VectorAdd (origin, gEnt->r.mins, gEnt->r.absmin);	
-		VectorAdd (origin, gEnt->r.maxs, gEnt->r.absmax);
-	}
+        max = RadiusFromBounds( gEnt->r.mins, gEnt->r.maxs );
+        for (i=0 ; i<3 ; i++) {
+            gEnt->r.absmin[i] = origin[i] - max;
+            gEnt->r.absmax[i] = origin[i] + max;
+        }
+    } else {
+        // normal
+        VectorAdd (origin, gEnt->r.mins, gEnt->r.absmin);
+        VectorAdd (origin, gEnt->r.maxs, gEnt->r.absmax);
+    }
 
-	// because movement is clipped an epsilon away from an actual edge,
-	// we must fully check even when bounding boxes don't quite touch
-	gEnt->r.absmin[0] -= 1;
-	gEnt->r.absmin[1] -= 1;
-	gEnt->r.absmin[2] -= 1;
-	gEnt->r.absmax[0] += 1;
-	gEnt->r.absmax[1] += 1;
-	gEnt->r.absmax[2] += 1;
+    // because movement is clipped an epsilon away from an actual edge,
+    // we must fully check even when bounding boxes don't quite touch
+    gEnt->r.absmin[0] -= 1;
+    gEnt->r.absmin[1] -= 1;
+    gEnt->r.absmin[2] -= 1;
+    gEnt->r.absmax[0] += 1;
+    gEnt->r.absmax[1] += 1;
+    gEnt->r.absmax[2] += 1;
 
-	// link to PVS leafs
-	ent->numClusters = 0;
-	ent->lastCluster = 0;
-	ent->areanum = -1;
-	ent->areanum2 = -1;
+    // link to PVS leafs
+    ent->numClusters = 0;
+    ent->lastCluster = 0;
+    ent->areanum = -1;
+    ent->areanum2 = -1;
 
-	//get all leafs, including solids
-	num_leafs = CM_BoxLeafnums( gEnt->r.absmin, gEnt->r.absmax,
-		leafs, MAX_TOTAL_ENT_LEAFS, &lastLeaf );
+    //get all leafs, including solids
+    num_leafs = CM_BoxLeafnums( gEnt->r.absmin, gEnt->r.absmax,
+        leafs, MAX_TOTAL_ENT_LEAFS, &lastLeaf );
 
-	// if none of the leafs were inside the map, the
-	// entity is outside the world and can be considered unlinked
-	if ( !num_leafs ) {
-		return;
-	}
+    // if none of the leafs were inside the map, the
+    // entity is outside the world and can be considered unlinked
+    if ( !num_leafs ) {
+        return;
+    }
 
-	// set areas, even from clusters that don't fit in the entity array
-	for (i=0 ; i<num_leafs ; i++) {
-		area = CM_LeafArea (leafs[i]);
-		if (area != -1) {
-			// doors may legally straggle two areas,
-			// but nothing should evern need more than that
-			if (ent->areanum != -1 && ent->areanum != area) {
-				if (ent->areanum2 != -1 && ent->areanum2 != area && sv.state == SS_LOADING) {
-					Com_DPrintf ("Object %i touching 3 areas at %f %f %f\n",
-					gEnt->s.number,
-					gEnt->r.absmin[0], gEnt->r.absmin[1], gEnt->r.absmin[2]);
-				}
-				ent->areanum2 = area;
-			} else {
-				ent->areanum = area;
-			}
-		}
-	}
+    // set areas, even from clusters that don't fit in the entity array
+    for (i=0 ; i<num_leafs ; i++) {
+        area = CM_LeafArea (leafs[i]);
+        if (area != -1) {
+            // doors may legally straggle two areas,
+            // but nothing should evern need more than that
+            if (ent->areanum != -1 && ent->areanum != area) {
+                if (ent->areanum2 != -1 && ent->areanum2 != area && sv.state == SS_LOADING) {
+                    Com_DPrintf ("Object %i touching 3 areas at %f %f %f\n",
+                    gEnt->s.number,
+                    gEnt->r.absmin[0], gEnt->r.absmin[1], gEnt->r.absmin[2]);
+                }
+                ent->areanum2 = area;
+            } else {
+                ent->areanum = area;
+            }
+        }
+    }
 
-	// store as many explicit clusters as we can
-	ent->numClusters = 0;
-	for (i=0 ; i < num_leafs ; i++) {
-		cluster = CM_LeafCluster( leafs[i] );
-		if ( cluster != -1 ) {
-			ent->clusternums[ent->numClusters++] = cluster;
-			if ( ent->numClusters == MAX_ENT_CLUSTERS ) {
-				break;
-			}
-		}
-	}
+    // store as many explicit clusters as we can
+    ent->numClusters = 0;
+    for (i=0 ; i < num_leafs ; i++) {
+        cluster = CM_LeafCluster( leafs[i] );
+        if ( cluster != -1 ) {
+            ent->clusternums[ent->numClusters++] = cluster;
+            if ( ent->numClusters == MAX_ENT_CLUSTERS ) {
+                break;
+            }
+        }
+    }
 
-	// store off a last cluster if we need to
-	if ( i != num_leafs ) {
-		ent->lastCluster = CM_LeafCluster( lastLeaf );
-	}
+    // store off a last cluster if we need to
+    if ( i != num_leafs ) {
+        ent->lastCluster = CM_LeafCluster( lastLeaf );
+    }
 
-	gEnt->r.linkcount++;
+    gEnt->r.linkcount++;
 
-	// find the first world sector node that the ent's box crosses
-	node = sv_worldSectors;
-	while (1)
-	{
-		if (node->axis == -1)
-			break;
-		if ( gEnt->r.absmin[node->axis] > node->dist)
-			node = node->children[0];
-		else if ( gEnt->r.absmax[node->axis] < node->dist)
-			node = node->children[1];
-		else
-			break;		// crosses the node
-	}
-	
-	// link it in
-	ent->worldSector = node;
-	ent->nextEntityInWorldSector = node->entities;
-	node->entities = ent;
+    // find the first world sector node that the ent's box crosses
+    node = sv_worldSectors;
+    while (1)
+    {
+        if (node->axis == -1)
+            break;
+        if ( gEnt->r.absmin[node->axis] > node->dist)
+            node = node->children[0];
+        else if ( gEnt->r.absmax[node->axis] < node->dist)
+            node = node->children[1];
+        else
+            break;      // crosses the node
+    }
 
-	gEnt->r.linked = qtrue;
+    // link it in
+    ent->worldSector = node;
+    ent->nextEntityInWorldSector = node->entities;
+    node->entities = ent;
+
+    gEnt->r.linked = qtrue;
 }
 
 /*
@@ -367,10 +367,10 @@
 */
 
 typedef struct {
-	const float	*mins;
-	const float	*maxs;
-	int			*list;
-	int			count, maxcount;
+    const float *mins;
+    const float *maxs;
+    int         *list;
+    int         count, maxcount;
 } areaParms_t;
 
 
@@ -381,46 +381,46 @@
 ====================
 */
 void SV_AreaEntities_r( worldSector_t *node, areaParms_t *ap ) {
-	svEntity_t	*check, *next;
-	sharedEntity_t *gcheck;
-	int			count;
+    svEntity_t  *check, *next;
+    sharedEntity_t *gcheck;
+    int         count;
 
-	count = 0;
+    count = 0;
 
-	for ( check = node->entities  ; check ; check = next ) {
-		next = check->nextEntityInWorldSector;
+    for ( check = node->entities  ; check ; check = next ) {
+        next = check->nextEntityInWorldSector;
 
-		gcheck = SV_GEntityForSvEntity( check );
+        gcheck = SV_GEntityForSvEntity( check );
 
-		if ( gcheck->r.absmin[0] > ap->maxs[0]
-		|| gcheck->r.absmin[1] > ap->maxs[1]
-		|| gcheck->r.absmin[2] > ap->maxs[2]
-		|| gcheck->r.absmax[0] < ap->mins[0]
-		|| gcheck->r.absmax[1] < ap->mins[1]
-		|| gcheck->r.absmax[2] < ap->mins[2]) {
-			continue;
-		}
+        if ( gcheck->r.absmin[0] > ap->maxs[0]
+        || gcheck->r.absmin[1] > ap->maxs[1]
+        || gcheck->r.absmin[2] > ap->maxs[2]
+        || gcheck->r.absmax[0] < ap->mins[0]
+        || gcheck->r.absmax[1] < ap->mins[1]
+        || gcheck->r.absmax[2] < ap->mins[2]) {
+            continue;
+        }
 
-		if ( ap->count == ap->maxcount ) {
-			Com_Printf ("SV_AreaEntities: MAXCOUNT\n");
-			return;
-		}
+        if ( ap->count == ap->maxcount ) {
+            Com_Printf ("SV_AreaEntities: MAXCOUNT\n");
+            return;
+        }
 
-		ap->list[ap->count] = check - sv.svEntities;
-		ap->count++;
-	}
-	
-	if (node->axis == -1) {
-		return;		// terminal node
-	}
+        ap->list[ap->count] = check - sv.svEntities;
+        ap->count++;
+    }
 
-	// recurse down both sides
-	if ( ap->maxs[node->axis] > node->dist ) {
-		SV_AreaEntities_r ( node->children[0], ap );
-	}
-	if ( ap->mins[node->axis] < node->dist ) {
-		SV_AreaEntities_r ( node->children[1], ap );
-	}
+    if (node->axis == -1) {
+        return;     // terminal node
+    }
+
+    // recurse down both sides
+    if ( ap->maxs[node->axis] > node->dist ) {
+        SV_AreaEntities_r ( node->children[0], ap );
+    }
+    if ( ap->mins[node->axis] < node->dist ) {
+        SV_AreaEntities_r ( node->children[1], ap );
+    }
 }
 
 /*
@@ -429,17 +429,17 @@
 ================
 */
 int SV_AreaEntities( const vec3_t mins, const vec3_t maxs, int *entityList, int maxcount ) {
-	areaParms_t		ap;
+    areaParms_t     ap;
 
-	ap.mins = mins;
-	ap.maxs = maxs;
-	ap.list = entityList;
-	ap.count = 0;
-	ap.maxcount = maxcount;
+    ap.mins = mins;
+    ap.maxs = maxs;
+    ap.list = entityList;
+    ap.count = 0;
+    ap.maxcount = maxcount;
 
-	SV_AreaEntities_r( sv_worldSectors, &ap );
+    SV_AreaEntities_r( sv_worldSectors, &ap );
 
-	return ap.count;
+    return ap.count;
 }
 
 
@@ -448,15 +448,15 @@
 
 
 typedef struct {
-	vec3_t		boxmins, boxmaxs;// enclose the test object along entire move
-	const float	*mins;
-	const float *maxs;	// size of the moving object
-	const float	*start;
-	vec3_t		end;
-	trace_t		trace;
-	int			passEntityNum;
-	int			contentmask;
-	traceType_t	collisionType;
+    vec3_t      boxmins, boxmaxs;// enclose the test object along entire move
+    const float *mins;
+    const float *maxs;  // size of the moving object
+    const float *start;
+    vec3_t      end;
+    trace_t     trace;
+    int         passEntityNum;
+    int         contentmask;
+    traceType_t collisionType;
 } moveclip_t;
 
 
@@ -467,38 +467,38 @@
 ====================
 */
 void SV_ClipToEntity( trace_t *trace, const vec3_t start, const vec3_t mins, const vec3_t maxs, const vec3_t end, int entityNum, int contentmask, traceType_t type ) {
-	sharedEntity_t	*touch;
-	clipHandle_t	clipHandle;
-	float			*origin, *angles;
+    sharedEntity_t  *touch;
+    clipHandle_t    clipHandle;
+    float           *origin, *angles;
 
-	touch = SV_GentityNum( entityNum );
+    touch = SV_GentityNum( entityNum );
 
-	Com_Memset(trace, 0, sizeof(trace_t));
+    Com_Memset(trace, 0, sizeof(trace_t));
 
-	// if it doesn't have any brushes of a type we
-	// are looking for, ignore it
-	if ( ! ( contentmask & touch->r.contents ) ) {
-		trace->fraction = 1.0;
-		return;
-	}
+    // if it doesn't have any brushes of a type we
+    // are looking for, ignore it
+    if ( ! ( contentmask & touch->r.contents ) ) {
+        trace->fraction = 1.0;
+        return;
+    }
 
-	// might intersect, so do an exact clip
-	clipHandle = SV_ClipHandleForEntity (touch);
+    // might intersect, so do an exact clip
+    clipHandle = SV_ClipHandleForEntity (touch);
 
-	origin = touch->r.currentOrigin;
-	angles = touch->r.currentAngles;
+    origin = touch->r.currentOrigin;
+    angles = touch->r.currentAngles;
 
-	if ( !touch->r.bmodel ) {
-		angles = vec3_origin;	// boxes don't rotate
-	}
+    if ( !touch->r.bmodel ) {
+        angles = vec3_origin;   // boxes don't rotate
+    }
 
-	CM_TransformedBoxTrace ( trace, (float *)start, (float *)end,
-		(float *)mins, (float *)maxs, clipHandle,  contentmask,
-		origin, angles, type);
+    CM_TransformedBoxTrace ( trace, (float *)start, (float *)end,
+        (float *)mins, (float *)maxs, clipHandle,  contentmask,
+        origin, angles, type);
 
-	if ( trace->fraction < 1 ) {
-		trace->entityNum = touch->s.number;
-	}
+    if ( trace->fraction < 1 ) {
+        trace->entityNum = touch->s.number;
+    }
 }
 
 
@@ -509,84 +509,84 @@
 ====================
 */
 void SV_ClipMoveToEntities( moveclip_t *clip ) {
-	int			i, num;
-	int			touchlist[MAX_GENTITIES];
-	sharedEntity_t *touch;
-	int			passOwnerNum;
-	trace_t		trace;
-	clipHandle_t	clipHandle;
-	float		*origin, *angles;
+    int         i, num;
+    int         touchlist[MAX_GENTITIES];
+    sharedEntity_t *touch;
+    int         passOwnerNum;
+    trace_t     trace;
+    clipHandle_t    clipHandle;
+    float       *origin, *angles;
 
-	num = SV_AreaEntities( clip->boxmins, clip->boxmaxs, touchlist, MAX_GENTITIES);
+    num = SV_AreaEntities( clip->boxmins, clip->boxmaxs, touchlist, MAX_GENTITIES);
 
-	if ( clip->passEntityNum != ENTITYNUM_NONE ) {
-		passOwnerNum = ( SV_GentityNum( clip->passEntityNum ) )->r.ownerNum;
-		if ( passOwnerNum == ENTITYNUM_NONE ) {
-			passOwnerNum = -1;
-		}
-	} else {
-		passOwnerNum = -1;
-	}
+    if ( clip->passEntityNum != ENTITYNUM_NONE ) {
+        passOwnerNum = ( SV_GentityNum( clip->passEntityNum ) )->r.ownerNum;
+        if ( passOwnerNum == ENTITYNUM_NONE ) {
+            passOwnerNum = -1;
+        }
+    } else {
+        passOwnerNum = -1;
+    }
 
-	for ( i=0 ; i<num ; i++ ) {
-		if ( clip->trace.allsolid ) {
-			return;
-		}
-		touch = SV_GentityNum( touchlist[i] );
+    for ( i=0 ; i<num ; i++ ) {
+        if ( clip->trace.allsolid ) {
+            return;
+        }
+        touch = SV_GentityNum( touchlist[i] );
 
-		// see if we should ignore this entity
-		if ( clip->passEntityNum != ENTITYNUM_NONE ) {
-			if ( touchlist[i] == clip->passEntityNum ) {
-				continue;	// don't clip against the pass entity
-			}
-			if ( touch->r.ownerNum == clip->passEntityNum ) {
-				continue;	// don't clip against own missiles
-			}
-			if ( touch->r.ownerNum == passOwnerNum ) {
-				continue;	// don't clip against other missiles from our owner
-			}
-		}
+        // see if we should ignore this entity
+        if ( clip->passEntityNum != ENTITYNUM_NONE ) {
+            if ( touchlist[i] == clip->passEntityNum ) {
+                continue;   // don't clip against the pass entity
+            }
+            if ( touch->r.ownerNum == clip->passEntityNum ) {
+                continue;   // don't clip against own missiles
+            }
+            if ( touch->r.ownerNum == passOwnerNum ) {
+                continue;   // don't clip against other missiles from our owner
+            }
+        }
 
-		// if it doesn't have any brushes of a type we
-		// are looking for, ignore it
-		if ( ! ( clip->contentmask & touch->r.contents ) ) {
-			continue;
-		}
+        // if it doesn't have any brushes of a type we
+        // are looking for, ignore it
+        if ( ! ( clip->contentmask & touch->r.contents ) ) {
+            continue;
+        }
 
-		// might intersect, so do an exact clip
-		clipHandle = SV_ClipHandleForEntity (touch);
+        // might intersect, so do an exact clip
+        clipHandle = SV_ClipHandleForEntity (touch);
 
-		origin = touch->r.currentOrigin;
-		angles = touch->r.currentAngles;
+        origin = touch->r.currentOrigin;
+        angles = touch->r.currentAngles;
 
 
-		if ( !touch->r.bmodel ) {
-			angles = vec3_origin;	// boxes don't rotate
-		}
+        if ( !touch->r.bmodel ) {
+            angles = vec3_origin;   // boxes don't rotate
+        }
 
-		CM_TransformedBoxTrace ( &trace, (float *)clip->start, (float *)clip->end,
-			(float *)clip->mins, (float *)clip->maxs, clipHandle,  clip->contentmask,
-			origin, angles, clip->collisionType);
+        CM_TransformedBoxTrace ( &trace, (float *)clip->start, (float *)clip->end,
+            (float *)clip->mins, (float *)clip->maxs, clipHandle,  clip->contentmask,
+            origin, angles, clip->collisionType);
 
-		if ( trace.allsolid ) {
-			clip->trace.allsolid = qtrue;
-			clip->trace.entityNum = touch->s.number;
-		} else if ( trace.startsolid ) {
-			clip->trace.startsolid = qtrue;
-			clip->trace.entityNum = touch->s.number;
-		}
+        if ( trace.allsolid ) {
+            clip->trace.allsolid = qtrue;
+//OC            clip->trace.entityNum = touch->s.number;
+        } else if ( trace.startsolid ) {
+            clip->trace.startsolid = qtrue;
+//OC            clip->trace.entityNum = touch->s.number;
+        }
 
-		if ( trace.fraction < clip->trace.fraction ) {
-			qboolean	oldStart;
+        if ( trace.fraction < clip->trace.fraction ) {
+            qboolean    oldStart;
 
-			// make sure we keep a startsolid from a previous trace
-			oldStart = clip->trace.startsolid;
+            // make sure we keep a startsolid from a previous trace
+            oldStart = clip->trace.startsolid;
 
-			trace.entityNum = touch->s.number;
-			clip->trace = trace;
-			clip->trace.startsolid |= oldStart;
-		}
-	}
+            trace.entityNum = touch->s.number;
+            clip->trace = trace;
+            clip->trace.startsolid |= oldStart;
+        }
+    }
 }
 
 
@@ -599,53 +599,53 @@
 ==================
 */
 void SV_Trace( trace_t *results, const vec3_t start, vec3_t mins, vec3_t maxs, const vec3_t end, int passEntityNum, int contentmask, traceType_t type ) {
-	moveclip_t	clip;
-	int			i;
+    moveclip_t  clip;
+    int         i;
 
-	if ( !mins ) {
-		mins = vec3_origin;
-	}
-	if ( !maxs ) {
-		maxs = vec3_origin;
-	}
+    if ( !mins ) {
+        mins = vec3_origin;
+    }
+    if ( !maxs ) {
+        maxs = vec3_origin;
+    }
 
-	Com_Memset ( &clip, 0, sizeof ( moveclip_t ) );
+    Com_Memset ( &clip, 0, sizeof ( moveclip_t ) );
 
-	// clip to world
-	CM_BoxTrace( &clip.trace, start, end, mins, maxs, 0, contentmask, type );
-	clip.trace.entityNum = clip.trace.fraction != 1.0 ? ENTITYNUM_WORLD : ENTITYNUM_NONE;
-	if ( clip.trace.fraction == 0 ) {
-		*results = clip.trace;
-		return;		// blocked immediately by the world
-	}
+    // clip to world
+    CM_BoxTrace( &clip.trace, start, end, mins, maxs, 0, contentmask, type );
+    clip.trace.entityNum = clip.trace.fraction != 1.0 ? ENTITYNUM_WORLD : ENTITYNUM_NONE;
+    if ( clip.trace.fraction == 0 ) {
+        *results = clip.trace;
+        return;     // blocked immediately by the world
+    }
 
-	clip.contentmask = contentmask;
-	clip.start = start;
-//	VectorCopy( clip.trace.endpos, clip.end );
-	VectorCopy( end, clip.end );
-	clip.mins = mins;
-	clip.maxs = maxs;
-	clip.passEntityNum = passEntityNum;
-	clip.collisionType = type;
+    clip.contentmask = contentmask;
+    clip.start = start;
+//  VectorCopy( clip.trace.endpos, clip.end );
+    VectorCopy( end, clip.end );
+    clip.mins = mins;
+    clip.maxs = maxs;
+    clip.passEntityNum = passEntityNum;
+    clip.collisionType = type;
 
-	// create the bounding box of the entire move
-	// we can limit it to the part of the move not
-	// already clipped off by the world, which can be
-	// a significant savings for line of sight and shot traces
-	for ( i=0 ; i<3 ; i++ ) {
-		if ( end[i] > start[i] ) {
-			clip.boxmins[i] = clip.start[i] + clip.mins[i] - 1;
-			clip.boxmaxs[i] = clip.end[i] + clip.maxs[i] + 1;
-		} else {
-			clip.boxmins[i] = clip.end[i] + clip.mins[i] - 1;
-			clip.boxmaxs[i] = clip.start[i] + clip.maxs[i] + 1;
-		}
-	}
+    // create the bounding box of the entire move
+    // we can limit it to the part of the move not
+    // already clipped off by the world, which can be
+    // a significant savings for line of sight and shot traces
+    for ( i=0 ; i<3 ; i++ ) {
+        if ( end[i] > start[i] ) {
+            clip.boxmins[i] = clip.start[i] + clip.mins[i] - 1;
+            clip.boxmaxs[i] = clip.end[i] + clip.maxs[i] + 1;
+        } else {
+            clip.boxmins[i] = clip.end[i] + clip.mins[i] - 1;
+            clip.boxmaxs[i] = clip.start[i] + clip.maxs[i] + 1;
+        }
+    }
 
-	// clip to other solid entities
-	SV_ClipMoveToEntities ( &clip );
+    // clip to other solid entities
+    SV_ClipMoveToEntities ( &clip );
 
-	*results = clip.trace;
+    *results = clip.trace;
 }
 
 
@@ -656,37 +656,37 @@
 =============
 */
 int SV_PointContents( const vec3_t p, int passEntityNum ) {
-	int			touch[MAX_GENTITIES];
-	sharedEntity_t *hit;
-	int			i, num;
-	int			contents, c2;
-	clipHandle_t	clipHandle;
-	float		*angles;
+    int         touch[MAX_GENTITIES];
+    sharedEntity_t *hit;
+    int         i, num;
+    int         contents, c2;
+    clipHandle_t    clipHandle;
+    float       *angles;
 
-	// get base contents from world
-	contents = CM_PointContents( p, 0 );
+    // get base contents from world
+    contents = CM_PointContents( p, 0 );
 
-	// or in contents from all the other entities
-	num = SV_AreaEntities( p, p, touch, MAX_GENTITIES );
+    // or in contents from all the other entities
+    num = SV_AreaEntities( p, p, touch, MAX_GENTITIES );
 
-	for ( i=0 ; i<num ; i++ ) {
-		if ( touch[i] == passEntityNum ) {
-			continue;
-		}
-		hit = SV_GentityNum( touch[i] );
-		// might intersect, so do an exact clip
-		clipHandle = SV_ClipHandleForEntity( hit );
-		angles = hit->s.angles;
-		if ( !hit->r.bmodel ) {
-			angles = vec3_origin;	// boxes don't rotate
-		}
+    for ( i=0 ; i<num ; i++ ) {
+        if ( touch[i] == passEntityNum ) {
+            continue;
+        }
+        hit = SV_GentityNum( touch[i] );
+        // might intersect, so do an exact clip
+        clipHandle = SV_ClipHandleForEntity( hit );
+        angles = hit->s.angles;
+        if ( !hit->r.bmodel ) {
+            angles = vec3_origin;   // boxes don't rotate
+        }
 
-		c2 = CM_TransformedPointContents (p, clipHandle, hit->s.origin, hit->s.angles);
+        c2 = CM_TransformedPointContents (p, clipHandle, hit->s.origin, hit->s.angles);
 
-		contents |= c2;
-	}
+        contents |= c2;
+    }
 
-	return contents;
+    return contents;
 }
 
 
Index: src/server/sv_ccmds.c
===================================================================
--- src/server/sv_ccmds.c	(revision 1055)
+++ src/server/sv_ccmds.c	(working copy)
@@ -41,59 +41,59 @@
 ==================
 */
 static client_t *SV_GetPlayerByHandle( void ) {
-	client_t	*cl;
-	int			i;
-	char		*s;
-	char		cleanName[64];
+    client_t    *cl;
+    int         i;
+    char        *s;
+    char        cleanName[64];
 
-	// make sure server is running
-	if ( !com_sv_running->integer ) {
-		return NULL;
-	}
+    // make sure server is running
+    if ( !com_sv_running->integer ) {
+        return NULL;
+    }
 
-	if ( Cmd_Argc() < 2 ) {
-		Com_Printf( "No player specified.\n" );
-		return NULL;
-	}
+    if ( Cmd_Argc() < 2 ) {
+        Com_Printf( "No player specified.\n" );
+        return NULL;
+    }
 
-	s = Cmd_Argv(1);
+    s = Cmd_Argv(1);
 
-	// Check whether this is a numeric player handle
-	for(i = 0; s[i] >= '0' && s[i] <= '9'; i++);
-	
-	if(!s[i])
-	{
-		int plid = atoi(s);
+    // Check whether this is a numeric player handle
+    for(i = 0; s[i] >= '0' && s[i] <= '9'; i++);
 
-		// Check for numeric playerid match
-		if(plid >= 0 && plid < sv_maxclients->integer)
-		{
-			cl = &svs.clients[plid];
-			
-			if(cl->state)
-				return cl;
-		}
-	}
+    if(!s[i])
+    {
+        int plid = atoi(s);
 
-	// check for a name match
-	for ( i=0, cl=svs.clients ; i < sv_maxclients->integer ; i++,cl++ ) {
-		if ( !cl->state ) {
-			continue;
-		}
-		if ( !Q_stricmp( cl->name, s ) ) {
-			return cl;
-		}
+        // Check for numeric playerid match
+        if(plid >= 0 && plid < sv_maxclients->integer)
+        {
+            cl = &svs.clients[plid];
 
-		Q_strncpyz( cleanName, cl->name, sizeof(cleanName) );
-		Q_CleanStr( cleanName );
-		if ( !Q_stricmp( cleanName, s ) ) {
-			return cl;
-		}
-	}
+            if(cl->state)
+                return cl;
+        }
+    }
 
-	Com_Printf( "Player %s is not on the server\n", s );
+    // check for a name match
+    for ( i=0, cl=svs.clients ; i < sv_maxclients->integer ; i++,cl++ ) {
+        if ( !cl->state ) {
+            continue;
+        }
+        if ( !Q_stricmp( cl->name, s ) ) {
+            return cl;
+        }
 
-	return NULL;
+        Q_strncpyz( cleanName, cl->name, sizeof(cleanName) );
+        Q_CleanStr( cleanName );
+        if ( !Q_stricmp( cleanName, s ) ) {
+            return cl;
+        }
+    }
+
+    Com_Printf( "Player %s is not on the server\n", s );
+
+    return NULL;
 }
 
 /*
@@ -104,41 +104,41 @@
 ==================
 */
 static client_t *SV_GetPlayerByNum( void ) {
-	client_t	*cl;
-	int			i;
-	int			idnum;
-	char		*s;
+    client_t    *cl;
+    int         i;
+    int         idnum;
+    char        *s;
 
-	// make sure server is running
-	if ( !com_sv_running->integer ) {
-		return NULL;
-	}
+    // make sure server is running
+    if ( !com_sv_running->integer ) {
+        return NULL;
+    }
 
-	if ( Cmd_Argc() < 2 ) {
-		Com_Printf( "No player specified.\n" );
-		return NULL;
-	}
+    if ( Cmd_Argc() < 2 ) {
+        Com_Printf( "No player specified.\n" );
+        return NULL;
+    }
 
-	s = Cmd_Argv(1);
+    s = Cmd_Argv(1);
 
-	for (i = 0; s[i]; i++) {
-		if (s[i] < '0' || s[i] > '9') {
-			Com_Printf( "Bad slot number: %s\n", s);
-			return NULL;
-		}
-	}
-	idnum = atoi( s );
-	if ( idnum < 0 || idnum >= sv_maxclients->integer ) {
-		Com_Printf( "Bad client slot: %i\n", idnum );
-		return NULL;
-	}
+    for (i = 0; s[i]; i++) {
+        if (s[i] < '0' || s[i] > '9') {
+            Com_Printf( "Bad slot number: %s\n", s);
+            return NULL;
+        }
+    }
+    idnum = atoi( s );
+    if ( idnum < 0 || idnum >= sv_maxclients->integer ) {
+        Com_Printf( "Bad client slot: %i\n", idnum );
+        return NULL;
+    }
 
-	cl = &svs.clients[idnum];
-	if ( !cl->state ) {
-		Com_Printf( "Client %i is not active\n", idnum );
-		return NULL;
-	}
-	return cl;
+    cl = &svs.clients[idnum];
+    if ( !cl->state ) {
+        Com_Printf( "Client %i is not active\n", idnum );
+        return NULL;
+    }
+    return cl;
 }
 
 //=========================================================
@@ -152,56 +152,56 @@
 ==================
 */
 static void SV_Map_f( void ) {
-	char		*cmd;
-	char		*map;
-	qboolean	killBots, cheat;
-	char		expanded[MAX_QPATH];
-	char		mapname[MAX_QPATH];
-	int			i;
+    char        *cmd;
+    char        *map;
+    qboolean    killBots, cheat;
+    char        expanded[MAX_QPATH];
+    char        mapname[MAX_QPATH];
+    int         i;
 
-	map = Cmd_Argv(1);
-	if ( !map ) {
-		return;
-	}
+    map = Cmd_Argv(1);
+    if ( !map ) {
+        return;
+    }
 
-	// make sure the level exists before trying to change, so that
-	// a typo at the server console won't end the game
-	Com_sprintf (expanded, sizeof(expanded), "maps/%s.bsp", map);
-	if ( FS_ReadFile (expanded, NULL) == -1 ) {
-		Com_Printf ("Can't find map %s\n", expanded);
-		return;
-	}
+    // make sure the level exists before trying to change, so that
+    // a typo at the server console won't end the game
+    Com_sprintf (expanded, sizeof(expanded), "maps/%s.bsp", map);
+    if ( FS_ReadFile (expanded, NULL) == -1 ) {
+        Com_Printf ("Can't find map %s\n", expanded);
+        return;
+    }
 
-	cmd = Cmd_Argv(0);
-	if ( !Q_stricmp( cmd, "devmap" ) ) {
-		cheat = qtrue;
-		killBots = qtrue;
-	} else {
-		cheat = qfalse;
-		killBots = qfalse;
-	}
+    cmd = Cmd_Argv(0);
+    if ( !Q_stricmp( cmd, "devmap" ) ) {
+        cheat = qtrue;
+        killBots = qtrue;
+    } else {
+        cheat = qfalse;
+        killBots = qfalse;
+    }
 
-	// save the map name here cause on a map restart we reload the autogen.cfg
-	// and thus nuke the arguments of the map command
-	Q_strncpyz(mapname, map, sizeof(mapname));
+    // save the map name here cause on a map restart we reload the autogen.cfg
+    // and thus nuke the arguments of the map command
+    Q_strncpyz(mapname, map, sizeof(mapname));
 
-	// start up the map
-	SV_SpawnServer( mapname, killBots );
+    // start up the map
+    SV_SpawnServer( mapname, killBots );
 
-	// set the cheat value
-	// if the level was started with "map <levelname>", then
-	// cheats will not be allowed.  If started with "devmap <levelname>"
-	// then cheats will be allowed
-	if ( cheat ) {
-		Cvar_Set( "sv_cheats", "1" );
-	} else {
-		Cvar_Set( "sv_cheats", "0" );
-	}
+    // set the cheat value
+    // if the level was started with "map <levelname>", then
+    // cheats will not be allowed.  If started with "devmap <levelname>"
+    // then cheats will be allowed
+    if ( cheat ) {
+        Cvar_Set( "sv_cheats", "1" );
+    } else {
+        Cvar_Set( "sv_cheats", "0" );
+    }
 
-	// This forces the local master server IP address cache
-	// to be updated on sending the next heartbeat
-	for( i = 0; i < MAX_MASTER_SERVERS; i++ )
-		sv_master[ i ]->modified  = qtrue;
+    // This forces the local master server IP address cache
+    // to be updated on sending the next heartbeat
+    for( i = 0; i < MAX_MASTER_SERVERS; i++ )
+        sv_master[ i ]->modified  = qtrue;
 }
 
 /*
@@ -213,110 +213,105 @@
 ================
 */
 static void SV_MapRestart_f( void ) {
-	int			i;
-	client_t	*client;
-	char		*denied;
-	int			delay;
+    int         i;
+    client_t    *client;
+    char        *denied;
+    int         delay;
 
-	// make sure we aren't restarting twice in the same frame
-	if ( com_frameTime == sv.serverId ) {
-		return;
-	}
+    // make sure we aren't restarting twice in the same frame
+    if ( com_frameTime == sv.serverId ) {
+        return;
+    }
 
-	// make sure server is running
-	if ( !com_sv_running->integer ) {
-		Com_Printf( "Server is not running.\n" );
-		return;
-	}
+    // make sure server is running
+    if ( !com_sv_running->integer ) {
+        Com_Printf( "Server is not running.\n" );
+        return;
+    }
 
-	if ( sv.restartTime ) {
-		return;
-	}
+    if ( sv.restartTime ) {
+        return;
+    }
 
-	if (Cmd_Argc() > 1 ) {
-		delay = atoi( Cmd_Argv(1) );
-	}
-	else {
-		delay = 5;
-	}
-	if( delay && !Cvar_VariableValue("g_doWarmup") ) {
-		sv.restartTime = sv.time + delay * 1000;
-		SV_SetConfigstring( CS_WARMUP, va("%i", sv.restartTime) );
-		return;
-	}
+    if (Cmd_Argc() > 1 ) {
+        delay = atoi( Cmd_Argv(1) );
+    }
+    else {
+        delay = 5;
+    }
 
-	// check for changes in variables that can't just be restarted
-	// check for maxclients change
-	if ( sv_maxclients->modified ) {
-		char	mapname[MAX_QPATH];
+    // check for changes in variables that can't just be restarted
+    // check for maxclients change
+    if ( sv_maxclients->modified ) {
+        char    mapname[MAX_QPATH];
 
-		Com_Printf( "variable change -- restarting.\n" );
-		// restart the map the slow way
-		Q_strncpyz( mapname, Cvar_VariableString( "mapname" ), sizeof( mapname ) );
+        Com_Printf( "variable change -- restarting.\n" );
+        // restart the map the slow way
+        Q_strncpyz( mapname, Cvar_VariableString( "mapname" ), sizeof( mapname ) );
 
-		SV_SpawnServer( mapname, qfalse );
-		return;
-	}
+        SV_SpawnServer( mapname, qfalse );
+        return;
+    }
 
-	// toggle the server bit so clients can detect that a
-	// map_restart has happened
-	svs.snapFlagServerBit ^= SNAPFLAG_SERVERCOUNT;
+    // toggle the server bit so clients can detect that a
+    // map_restart has happened
+    svs.snapFlagServerBit ^= SNAPFLAG_SERVERCOUNT;
 
-	// generate a new serverid	
-	// TTimo - don't update restartedserverId there, otherwise we won't deal correctly with multiple map_restart
-	sv.serverId = com_frameTime;
-	Cvar_Set( "sv_serverid", va("%i", sv.serverId ) );
+    // generate a new serverid
+    // TTimo - don't update restartedserverId there, otherwise we won't deal correctly with multiple map_restart
+    sv.serverId = com_frameTime;
+    Cvar_Set( "sv_serverid", va("%i", sv.serverId ) );
 
-	// reset all the vm data in place without changing memory allocation
-	// note that we do NOT set sv.state = SS_LOADING, so configstrings that
-	// had been changed from their default values will generate broadcast updates
-	sv.state = SS_LOADING;
-	sv.restarting = qtrue;
+    // reset all the vm data in place without changing memory allocation
+    // note that we do NOT set sv.state = SS_LOADING, so configstrings that
+    // had been changed from their default values will generate broadcast updates
+    sv.state = SS_LOADING;
+    sv.restarting = qtrue;
 
-	SV_RestartGameProgs();
+    SV_RestartGameProgs();
 
-	// run a few frames to allow everything to settle
-	for (i = 0; i < 3; i++)
-	{
-		VM_Call (gvm, GAME_RUN_FRAME, sv.time);
-		sv.time += 100;
-		svs.time += 100;
-	}
+    // run a few frames to allow everything to settle
+    for (i = 0; i < 3; i++)
+    {
+        VM_Call (gvm, GAME_RUN_FRAME, sv.time);
+        sv.time += 100;
+        svs.time += 100;
+    }
 
-	sv.state = SS_GAME;
-	sv.restarting = qfalse;
+    sv.state = SS_GAME;
+    sv.restarting = qfalse;
 
-	// connect and begin all the clients
-	for (i=0 ; i<sv_maxclients->integer ; i++) {
-		client = &svs.clients[i];
+    // connect and begin all the clients
+    for (i=0 ; i<sv_maxclients->integer ; i++) {
+        client = &svs.clients[i];
 
-		// send the new gamestate to all connected clients
-		if ( client->state < CS_CONNECTED) {
-			continue;
-		}
+        // send the new gamestate to all connected clients
+        if ( client->state < CS_CONNECTED) {
+            continue;
+        }
 
-		// add the map_restart command
-		SV_AddServerCommand( client, "map_restart\n" );
+        // add the map_restart command
+        SV_AddServerCommand( client, "map_restart\n" );
 
-		// connect the client again, without the firstTime flag
-		denied = VM_ExplicitArgPtr( gvm, VM_Call( gvm, GAME_CLIENT_CONNECT, i, qfalse ) );
-		if ( denied ) {
-			// this generally shouldn't happen, because the client
-			// was connected before the level change
-			SV_DropClient( client, denied );
-			Com_Printf( "SV_MapRestart_f(%d): dropped client %i - denied!\n", delay, i );
-			continue;
-		}
+        // connect the client again, without the firstTime flag
+        denied = VM_ExplicitArgPtr( gvm, VM_Call( gvm, GAME_CLIENT_CONNECT, i, qfalse ) );
+        if ( denied ) {
+            // this generally shouldn't happen, because the client
+            // was connected before the level change
+            SV_DropClient( client, denied );
+            Com_Printf( "SV_MapRestart_f(%d): dropped client %i - denied!\n", delay, i );
+            continue;
+        }
 
-		client->state = CS_ACTIVE;
+        client->state = CS_ACTIVE;
 
-		SV_ClientEnterWorld( client, &client->lastUsercmd );
-	}	
+        SV_ClientEnterWorld( client, &client->lastUsercmd );
+    }
 
-	// run another frame to allow things to look at all the players
-	VM_Call (gvm, GAME_RUN_FRAME, sv.time);
-	sv.time += 100;
-	svs.time += 100;
+    // run another frame to allow things to look at all the players
+    VM_Call (gvm, GAME_RUN_FRAME, sv.time);
+    sv.time += 100;
+    svs.time += 100;
 }
 
 //===============================================================
@@ -329,25 +324,25 @@
 ==================
 */
 static void SV_KickAll_f( void ) {
-	client_t	*cl;
-	int			i;
+    client_t    *cl;
+    int         i;
 
-	// make sure server is running
-	if ( !com_sv_running->integer ) {
-		Com_Printf( "Server is not running.\n" );
-		return;
-	}
+    // make sure server is running
+    if ( !com_sv_running->integer ) {
+        Com_Printf( "Server is not running.\n" );
+        return;
+    }
 
-	for ( i=0, cl=svs.clients ; i < sv_maxclients->integer ; i++,cl++ ) {
-		if ( !cl->state ) {
-			continue;
-		}
-		if( cl->netchan.remoteAddress.type == NA_LOOPBACK ) {
-			continue;
-		}
-		SV_DropClient( cl, "was kicked" );
-		cl->lastPacketTime = svs.time;	// in case there is a funny zombie
-	}
+    for ( i=0, cl=svs.clients ; i < sv_maxclients->integer ; i++,cl++ ) {
+        if ( !cl->state ) {
+            continue;
+        }
+        if( cl->netchan.remoteAddress.type == NA_LOOPBACK ) {
+            continue;
+        }
+        SV_DropClient( cl, "was kicked" );
+        cl->lastPacketTime = svs.time;  // in case there is a funny zombie
+    }
 }
 
 /*
@@ -358,30 +353,30 @@
 ==================
 */
 static void SV_Kick_f( void ) {
-	client_t	*cl;
+    client_t    *cl;
 
-	// make sure server is running
-	if ( !com_sv_running->integer ) {
-		Com_Printf( "Server is not running.\n" );
-		return;
-	}
+    // make sure server is running
+    if ( !com_sv_running->integer ) {
+        Com_Printf( "Server is not running.\n" );
+        return;
+    }
 
-	if ( Cmd_Argc() != 2 ) {
-		Com_Printf ("Usage: kick <player name>\n");
-		return;
-	}
+    if ( Cmd_Argc() != 2 ) {
+        Com_Printf ("Usage: kick <player name>\n");
+        return;
+    }
 
-	cl = SV_GetPlayerByHandle();
-	if ( !cl ) {
-		return;
-	}
-	if( cl->netchan.remoteAddress.type == NA_LOOPBACK ) {
-		SV_SendServerCommand(NULL, "print \"%s\"", "Cannot kick host player\n");
-		return;
-	}
+    cl = SV_GetPlayerByHandle();
+    if ( !cl ) {
+        return;
+    }
+    if( cl->netchan.remoteAddress.type == NA_LOOPBACK ) {
+        SV_SendServerCommand(NULL, "print \"%s\"", "Cannot kick host player\n");
+        return;
+    }
 
-	SV_DropClient( cl, "was kicked" );
-	cl->lastPacketTime = svs.time;	// in case there is a funny zombie
+    SV_DropClient( cl, "was kicked" );
+    cl->lastPacketTime = svs.time;  // in case there is a funny zombie
 }
 
 /*
@@ -393,53 +388,53 @@
 ==================
 */
 static void SV_Ban_f( void ) {
-	client_t	*cl;
+    client_t    *cl;
 
-	// make sure server is running
-	if ( !com_sv_running->integer ) {
-		Com_Printf( "Server is not running.\n" );
-		return;
-	}
+    // make sure server is running
+    if ( !com_sv_running->integer ) {
+        Com_Printf( "Server is not running.\n" );
+        return;
+    }
 
-	if ( Cmd_Argc() != 2 ) {
-		Com_Printf ("Usage: banUser <player name>\n");
-		return;
-	}
+    if ( Cmd_Argc() != 2 ) {
+        Com_Printf ("Usage: banUser <player name>\n");
+        return;
+    }
 
-	cl = SV_GetPlayerByHandle();
+    cl = SV_GetPlayerByHandle();
 
-	if (!cl) {
-		return;
-	}
+    if (!cl) {
+        return;
+    }
 
-	if( cl->netchan.remoteAddress.type == NA_LOOPBACK ) {
-		SV_SendServerCommand(NULL, "print \"%s\"", "Cannot kick host player\n");
-		return;
-	}
+    if( cl->netchan.remoteAddress.type == NA_LOOPBACK ) {
+        SV_SendServerCommand(NULL, "print \"%s\"", "Cannot kick host player\n");
+        return;
+    }
 
-	//FIXME: there is no auth server in Tremulous
+    //FIXME: there is no auth server in Tremulous
 #if 0
-	// look up the authorize server's IP
-	if ( !svs.authorizeAddress.ip[0] && svs.authorizeAddress.type != NA_BAD ) {
-		Com_Printf( "Resolving %s\n", AUTHORIZE_SERVER_NAME );
-		if ( !NET_StringToAdr( AUTHORIZE_SERVER_NAME, &svs.authorizeAddress ) ) {
-			Com_Printf( "Couldn't resolve address\n" );
-			return;
-		}
-		svs.authorizeAddress.port = BigShort( PORT_AUTHORIZE );
-		Com_Printf( "%s resolved to %i.%i.%i.%i:%i\n", AUTHORIZE_SERVER_NAME,
-			svs.authorizeAddress.ip[0], svs.authorizeAddress.ip[1],
-			svs.authorizeAddress.ip[2], svs.authorizeAddress.ip[3],
-			BigShort( svs.authorizeAddress.port ) );
-	}
+    // look up the authorize server's IP
+    if ( !svs.authorizeAddress.ip[0] && svs.authorizeAddress.type != NA_BAD ) {
+        Com_Printf( "Resolving %s\n", AUTHORIZE_SERVER_NAME );
+        if ( !NET_StringToAdr( AUTHORIZE_SERVER_NAME, &svs.authorizeAddress ) ) {
+            Com_Printf( "Couldn't resolve address\n" );
+            return;
+        }
+        svs.authorizeAddress.port = BigShort( PORT_AUTHORIZE );
+        Com_Printf( "%s resolved to %i.%i.%i.%i:%i\n", AUTHORIZE_SERVER_NAME,
+            svs.authorizeAddress.ip[0], svs.authorizeAddress.ip[1],
+            svs.authorizeAddress.ip[2], svs.authorizeAddress.ip[3],
+            BigShort( svs.authorizeAddress.port ) );
+    }
 
-	// otherwise send their ip to the authorize server
-	if ( svs.authorizeAddress.type != NA_BAD ) {
-		NET_OutOfBandPrint( NS_SERVER, svs.authorizeAddress,
-			"banUser %i.%i.%i.%i", cl->netchan.remoteAddress.ip[0], cl->netchan.remoteAddress.ip[1], 
-								   cl->netchan.remoteAddress.ip[2], cl->netchan.remoteAddress.ip[3] );
-		Com_Printf("%s was banned from coming back\n", cl->name);
-	}
+    // otherwise send their ip to the authorize server
+    if ( svs.authorizeAddress.type != NA_BAD ) {
+        NET_OutOfBandPrint( NS_SERVER, svs.authorizeAddress,
+            "banUser %i.%i.%i.%i", cl->netchan.remoteAddress.ip[0], cl->netchan.remoteAddress.ip[1],
+                                   cl->netchan.remoteAddress.ip[2], cl->netchan.remoteAddress.ip[3] );
+        Com_Printf("%s was banned from coming back\n", cl->name);
+    }
 #endif
 }
 
@@ -452,51 +447,51 @@
 ==================
 */
 static void SV_BanNum_f( void ) {
-	client_t	*cl;
+    client_t    *cl;
 
-	// make sure server is running
-	if ( !com_sv_running->integer ) {
-		Com_Printf( "Server is not running.\n" );
-		return;
-	}
+    // make sure server is running
+    if ( !com_sv_running->integer ) {
+        Com_Printf( "Server is not running.\n" );
+        return;
+    }
 
-	if ( Cmd_Argc() != 2 ) {
-		Com_Printf ("Usage: banClient <client number>\n");
-		return;
-	}
+    if ( Cmd_Argc() != 2 ) {
+        Com_Printf ("Usage: banClient <client number>\n");
+        return;
+    }
 
-	cl = SV_GetPlayerByNum();
-	if ( !cl ) {
-		return;
-	}
-	if( cl->netchan.remoteAddress.type == NA_LOOPBACK ) {
-		SV_SendServerCommand(NULL, "print \"%s\"", "Cannot kick host player\n");
-		return;
-	}
+    cl = SV_GetPlayerByNum();
+    if ( !cl ) {
+        return;
+    }
+    if( cl->netchan.remoteAddress.type == NA_LOOPBACK ) {
+        SV_SendServerCommand(NULL, "print \"%s\"", "Cannot kick host player\n");
+        return;
+    }
 
-	//FIXME: there is no auth server in Tremulous
+    //FIXME: there is no auth server in Tremulous
 #if 0
-	// look up the authorize server's IP
-	if ( !svs.authorizeAddress.ip[0] && svs.authorizeAddress.type != NA_BAD ) {
-		Com_Printf( "Resolving %s\n", AUTHORIZE_SERVER_NAME );
-		if ( !NET_StringToAdr( AUTHORIZE_SERVER_NAME, &svs.authorizeAddress ) ) {
-			Com_Printf( "Couldn't resolve address\n" );
-			return;
-		}
-		svs.authorizeAddress.port = BigShort( PORT_AUTHORIZE );
-		Com_Printf( "%s resolved to %i.%i.%i.%i:%i\n", AUTHORIZE_SERVER_NAME,
-			svs.authorizeAddress.ip[0], svs.authorizeAddress.ip[1],
-			svs.authorizeAddress.ip[2], svs.authorizeAddress.ip[3],
-			BigShort( svs.authorizeAddress.port ) );
-	}
+    // look up the authorize server's IP
+    if ( !svs.authorizeAddress.ip[0] && svs.authorizeAddress.type != NA_BAD ) {
+        Com_Printf( "Resolving %s\n", AUTHORIZE_SERVER_NAME );
+        if ( !NET_StringToAdr( AUTHORIZE_SERVER_NAME, &svs.authorizeAddress ) ) {
+            Com_Printf( "Couldn't resolve address\n" );
+            return;
+        }
+        svs.authorizeAddress.port = BigShort( PORT_AUTHORIZE );
+        Com_Printf( "%s resolved to %i.%i.%i.%i:%i\n", AUTHORIZE_SERVER_NAME,
+            svs.authorizeAddress.ip[0], svs.authorizeAddress.ip[1],
+            svs.authorizeAddress.ip[2], svs.authorizeAddress.ip[3],
+            BigShort( svs.authorizeAddress.port ) );
+    }
 
-	// otherwise send their ip to the authorize server
-	if ( svs.authorizeAddress.type != NA_BAD ) {
-		NET_OutOfBandPrint( NS_SERVER, svs.authorizeAddress,
-			"banUser %i.%i.%i.%i", cl->netchan.remoteAddress.ip[0], cl->netchan.remoteAddress.ip[1], 
-								   cl->netchan.remoteAddress.ip[2], cl->netchan.remoteAddress.ip[3] );
-		Com_Printf("%s was banned from coming back\n", cl->name);
-	}
+    // otherwise send their ip to the authorize server
+    if ( svs.authorizeAddress.type != NA_BAD ) {
+        NET_OutOfBandPrint( NS_SERVER, svs.authorizeAddress,
+            "banUser %i.%i.%i.%i", cl->netchan.remoteAddress.ip[0], cl->netchan.remoteAddress.ip[1],
+                                   cl->netchan.remoteAddress.ip[2], cl->netchan.remoteAddress.ip[3] );
+        Com_Printf("%s was banned from coming back\n", cl->name);
+    }
 #endif
 }
 
@@ -508,30 +503,30 @@
 ==================
 */
 static void SV_KickNum_f( void ) {
-	client_t	*cl;
+    client_t    *cl;
 
-	// make sure server is running
-	if ( !com_sv_running->integer ) {
-		Com_Printf( "Server is not running.\n" );
-		return;
-	}
+    // make sure server is running
+    if ( !com_sv_running->integer ) {
+        Com_Printf( "Server is not running.\n" );
+        return;
+    }
 
-	if ( Cmd_Argc() != 2 ) {
-		Com_Printf ("Usage: kicknum <client number>\n");
-		return;
-	}
+    if ( Cmd_Argc() != 2 ) {
+        Com_Printf ("Usage: kicknum <client number>\n");
+        return;
+    }
 
-	cl = SV_GetPlayerByNum();
-	if ( !cl ) {
-		return;
-	}
-	if( cl->netchan.remoteAddress.type == NA_LOOPBACK ) {
-		SV_SendServerCommand(NULL, "print \"%s\"", "Cannot kick host player\n");
-		return;
-	}
+    cl = SV_GetPlayerByNum();
+    if ( !cl ) {
+        return;
+    }
+    if( cl->netchan.remoteAddress.type == NA_LOOPBACK ) {
+        SV_SendServerCommand(NULL, "print \"%s\"", "Cannot kick host player\n");
+        return;
+    }
 
-	SV_DropClient( cl, "was kicked" );
-	cl->lastPacketTime = svs.time;	// in case there is a funny zombie
+    SV_DropClient( cl, "was kicked" );
+    cl->lastPacketTime = svs.time;  // in case there is a funny zombie
 }
 
 /*
@@ -540,63 +535,63 @@
 ================
 */
 static void SV_Status_f( void ) {
-	int			i, j, l;
-	client_t	*cl;
-	playerState_t	*ps;
-	const char		*s;
-	int			ping;
+    int         i, j, l;
+    client_t    *cl;
+    playerState_t   *ps;
+    const char      *s;
+    int         ping;
 
-	// make sure server is running
-	if ( !com_sv_running->integer ) {
-		Com_Printf( "Server is not running.\n" );
-		return;
-	}
+    // make sure server is running
+    if ( !com_sv_running->integer ) {
+        Com_Printf( "Server is not running.\n" );
+        return;
+    }
 
-	Com_Printf ("map: %s\n", sv_mapname->string );
+    Com_Printf ("map: %s\n", sv_mapname->string );
 
-	Com_Printf ("num score ping name            lastmsg address               qport rate\n");
-	Com_Printf ("--- ----- ---- --------------- ------- --------------------- ----- -----\n");
-	for (i=0,cl=svs.clients ; i < sv_maxclients->integer ; i++,cl++)
-	{
-		if (!cl->state)
-			continue;
-		Com_Printf ("%3i ", i);
-		ps = SV_GameClientNum( i );
-		Com_Printf ("%5i ", ps->persistant[PERS_SCORE]);
+    Com_Printf ("num score ping name            lastmsg address               qport rate\n");
+    Com_Printf ("--- ----- ---- --------------- ------- --------------------- ----- -----\n");
+    for (i=0,cl=svs.clients ; i < sv_maxclients->integer ; i++,cl++)
+    {
+        if (!cl->state)
+            continue;
+        Com_Printf ("%3i ", i);
+        ps = SV_GameClientNum( i );
+        Com_Printf ("%5i ", ps->persistant[PERS_SCORE]);
 
-		if (cl->state == CS_CONNECTED)
-			Com_Printf ("CNCT ");
-		else if (cl->state == CS_ZOMBIE)
-			Com_Printf ("ZMBI ");
-		else
-		{
-			ping = cl->ping < 9999 ? cl->ping : 9999;
-			Com_Printf ("%4i ", ping);
-		}
+        if (cl->state == CS_CONNECTED)
+            Com_Printf ("CNCT ");
+        else if (cl->state == CS_ZOMBIE)
+            Com_Printf ("ZMBI ");
+        else
+        {
+            ping = cl->ping < 9999 ? cl->ping : 9999;
+            Com_Printf ("%4i ", ping);
+        }
 
-		Com_Printf ("%s", cl->name);
+        Com_Printf ("%s", cl->name);
     // TTimo adding a ^7 to reset the color
     // NOTE: colored names in status breaks the padding (WONTFIX)
     Com_Printf ("^7");
-		l = 16 - strlen(cl->name);
-		for (j=0 ; j<l ; j++)
-			Com_Printf (" ");
+        l = 16 - strlen(cl->name);
+        for (j=0 ; j<l ; j++)
+            Com_Printf (" ");
 
-		Com_Printf ("%7i ", svs.time - cl->lastPacketTime );
+        Com_Printf ("%7i ", svs.time - cl->lastPacketTime );
 
-		s = NET_AdrToString( cl->netchan.remoteAddress );
-		Com_Printf ("%s", s);
-		l = 22 - strlen(s);
-		for (j=0 ; j<l ; j++)
-			Com_Printf (" ");
-		
-		Com_Printf ("%5i", cl->netchan.qport);
+        s = NET_AdrToString( cl->netchan.remoteAddress );
+        Com_Printf ("%s", s);
+        l = 22 - strlen(s);
+        for (j=0 ; j<l ; j++)
+            Com_Printf (" ");
 
-		Com_Printf (" %5i", cl->rate);
+        Com_Printf ("%5i", cl->netchan.qport);
 
-		Com_Printf ("\n");
-	}
-	Com_Printf ("\n");
+        Com_Printf (" %5i", cl->rate);
+
+        Com_Printf ("\n");
+    }
+    Com_Printf ("\n");
 }
 
 /*
@@ -605,30 +600,30 @@
 ==================
 */
 static void SV_ConSay_f(void) {
-	char	*p;
-	char	text[1024];
+    char    *p;
+    char    text[1024];
 
-	// make sure server is running
-	if ( !com_sv_running->integer ) {
-		Com_Printf( "Server is not running.\n" );
-		return;
-	}
+    // make sure server is running
+    if ( !com_sv_running->integer ) {
+        Com_Printf( "Server is not running.\n" );
+        return;
+    }
 
-	if ( Cmd_Argc () < 2 ) {
-		return;
-	}
+    if ( Cmd_Argc () < 2 ) {
+        return;
+    }
 
-	strcpy (text, "console: ");
-	p = Cmd_Args();
+    strcpy (text, "console: ");
+    p = Cmd_Args();
 
-	if ( *p == '"' ) {
-		p++;
-		p[strlen(p)-1] = 0;
-	}
+    if ( *p == '"' ) {
+        p++;
+        p[strlen(p)-1] = 0;
+    }
 
-	strcat(text, p);
+    strcat(text, p);
 
-	SV_SendServerCommand(NULL, "chat \"%s\n\"", text);
+    SV_SendServerCommand(NULL, "chat \"%s\n\"", text);
 }
 
 
@@ -640,7 +635,7 @@
 ==================
 */
 void SV_Heartbeat_f( void ) {
-	svs.nextHeartbeatTime = -9999999;
+    svs.nextHeartbeatTime = -9999999;
 }
 
 
@@ -652,8 +647,8 @@
 ===========
 */
 static void SV_Serverinfo_f( void ) {
-	Com_Printf ("Server info settings:\n");
-	Info_Print ( Cvar_InfoString( CVAR_SERVERINFO ) );
+    Com_Printf ("Server info settings:\n");
+    Info_Print ( Cvar_InfoString( CVAR_SERVERINFO ) );
 }
 
 
@@ -665,8 +660,8 @@
 ===========
 */
 static void SV_Systeminfo_f( void ) {
-	Com_Printf ("System info settings:\n");
-	Info_Print ( Cvar_InfoString( CVAR_SYSTEMINFO ) );
+    Com_Printf ("System info settings:\n");
+    Info_Print ( Cvar_InfoString( CVAR_SYSTEMINFO ) );
 }
 
 
@@ -678,27 +673,27 @@
 ===========
 */
 static void SV_DumpUser_f( void ) {
-	client_t	*cl;
+    client_t    *cl;
 
-	// make sure server is running
-	if ( !com_sv_running->integer ) {
-		Com_Printf( "Server is not running.\n" );
-		return;
-	}
+    // make sure server is running
+    if ( !com_sv_running->integer ) {
+        Com_Printf( "Server is not running.\n" );
+        return;
+    }
 
-	if ( Cmd_Argc() != 2 ) {
-		Com_Printf ("Usage: info <userid>\n");
-		return;
-	}
+    if ( Cmd_Argc() != 2 ) {
+        Com_Printf ("Usage: info <userid>\n");
+        return;
+    }
 
-	cl = SV_GetPlayerByHandle();
-	if ( !cl ) {
-		return;
-	}
+    cl = SV_GetPlayerByHandle();
+    if ( !cl ) {
+        return;
+    }
 
-	Com_Printf( "userinfo\n" );
-	Com_Printf( "--------\n" );
-	Info_Print( cl->userinfo );
+    Com_Printf( "userinfo\n" );
+    Com_Printf( "--------\n" );
+    Info_Print( cl->userinfo );
 }
 
 
@@ -708,7 +703,7 @@
 =================
 */
 static void SV_KillServer_f( void ) {
-	SV_Shutdown( "killserver" );
+    SV_Shutdown( "killserver" );
 }
 
 //===========================================================
@@ -719,31 +714,31 @@
 ==================
 */
 void SV_AddOperatorCommands( void ) {
-	static qboolean	initialized;
+    static qboolean initialized;
 
-	if ( initialized ) {
-		return;
-	}
-	initialized = qtrue;
+    if ( initialized ) {
+        return;
+    }
+    initialized = qtrue;
 
-	Cmd_AddCommand ("heartbeat", SV_Heartbeat_f);
-	Cmd_AddCommand ("kick", SV_Kick_f);
-	Cmd_AddCommand ("kickAll", SV_KickAll_f);
-	Cmd_AddCommand ("banUser", SV_Ban_f);
-	Cmd_AddCommand ("banClient", SV_BanNum_f);
-	Cmd_AddCommand ("clientkick", SV_KickNum_f);
-	Cmd_AddCommand ("status", SV_Status_f);
-	Cmd_AddCommand ("serverinfo", SV_Serverinfo_f);
-	Cmd_AddCommand ("systeminfo", SV_Systeminfo_f);
-	Cmd_AddCommand ("dumpuser", SV_DumpUser_f);
-	Cmd_AddCommand ("map_restart", SV_MapRestart_f);
-	Cmd_AddCommand ("sectorlist", SV_SectorList_f);
-	Cmd_AddCommand ("map", SV_Map_f);
-	Cmd_AddCommand ("devmap", SV_Map_f);
-	Cmd_AddCommand ("killserver", SV_KillServer_f);
-	if( com_dedicated->integer ) {
-		Cmd_AddCommand ("say", SV_ConSay_f);
-	}
+    Cmd_AddCommand ("heartbeat", SV_Heartbeat_f);
+    Cmd_AddCommand ("kick", SV_Kick_f);
+    Cmd_AddCommand ("kickAll", SV_KickAll_f);
+    Cmd_AddCommand ("banUser", SV_Ban_f);
+    Cmd_AddCommand ("banClient", SV_BanNum_f);
+    Cmd_AddCommand ("clientkick", SV_KickNum_f);
+    Cmd_AddCommand ("status", SV_Status_f);
+    Cmd_AddCommand ("serverinfo", SV_Serverinfo_f);
+    Cmd_AddCommand ("systeminfo", SV_Systeminfo_f);
+    Cmd_AddCommand ("dumpuser", SV_DumpUser_f);
+    Cmd_AddCommand ("map_restart", SV_MapRestart_f);
+    Cmd_AddCommand ("sectorlist", SV_SectorList_f);
+    Cmd_AddCommand ("map", SV_Map_f);
+    Cmd_AddCommand ("devmap", SV_Map_f);
+    Cmd_AddCommand ("killserver", SV_KillServer_f);
+    if( com_dedicated->integer ) {
+        Cmd_AddCommand ("say", SV_ConSay_f);
+    }
 }
 
 /*
@@ -753,18 +748,18 @@
 */
 void SV_RemoveOperatorCommands( void ) {
 #if 0
-	// removing these won't let the server start again
-	Cmd_RemoveCommand ("heartbeat");
-	Cmd_RemoveCommand ("kick");
-	Cmd_RemoveCommand ("banUser");
-	Cmd_RemoveCommand ("banClient");
-	Cmd_RemoveCommand ("status");
-	Cmd_RemoveCommand ("serverinfo");
-	Cmd_RemoveCommand ("systeminfo");
-	Cmd_RemoveCommand ("dumpuser");
-	Cmd_RemoveCommand ("map_restart");
-	Cmd_RemoveCommand ("sectorlist");
-	Cmd_RemoveCommand ("say");
+    // removing these won't let the server start again
+    Cmd_RemoveCommand ("heartbeat");
+    Cmd_RemoveCommand ("kick");
+    Cmd_RemoveCommand ("banUser");
+    Cmd_RemoveCommand ("banClient");
+    Cmd_RemoveCommand ("status");
+    Cmd_RemoveCommand ("serverinfo");
+    Cmd_RemoveCommand ("systeminfo");
+    Cmd_RemoveCommand ("dumpuser");
+    Cmd_RemoveCommand ("map_restart");
+    Cmd_RemoveCommand ("sectorlist");
+    Cmd_RemoveCommand ("say");
 #endif
 }
 
Index: src/server/sv_client.c
===================================================================
--- src/server/sv_client.c	(revision 1055)
+++ src/server/sv_client.c	(working copy)
@@ -125,9 +125,9 @@
 			continue;
 		}
 		if ( NET_CompareBaseAdr( from, cl->netchan.remoteAddress )
-			&& ( cl->netchan.qport == qport 
+			&& ( cl->netchan.qport == qport
 			|| from.port == cl->netchan.remoteAddress.port ) ) {
-			if (( svs.time - cl->lastConnectTime) 
+			if (( svs.time - cl->lastConnectTime)
 				< (sv_reconnectlimit->integer * 1000)) {
 				Com_DPrintf ("%s:reconnect rejected : too soon\n", NET_AdrToString (from));
 				return;
@@ -135,7 +135,7 @@
 			break;
 		}
 	}
-	
+
 	// don't let "ip" overflow userinfo string
 	if ( NET_IsLocalAddress (from) )
 		ip = "localhost";
@@ -169,9 +169,12 @@
 		Com_Printf( "Client %i connecting with %i challenge ping\n", i, ping );
 		svs.challenges[i].connected = qtrue;
 
+		// allow admins to override ping restrictions
 		// never reject a LAN client based on ping
-		if ( !Sys_IsLANAddress( from ) ) {
-			if ( sv_minPing->value && ping < sv_minPing->value ) {
+		if ( !Sys_IsLANAddress( from ) && VM_Call( gvm, GAME_PING_OVERRIDE ) != 1 )
+		{
+			if ( sv_minPing->value && ping < sv_minPing->value )
+			{
 				// don't let them keep trying until they get a big delay
 				NET_OutOfBandPrint( NS_SERVER, from, "print\nServer is for high pings only" );
 				Com_DPrintf ("Client %i rejected on a too low ping\n", i);
@@ -180,7 +183,8 @@
 				svs.challenges[i].adr.port = 0;
 				return;
 			}
-			if ( sv_maxPing->value && ping > sv_maxPing->value ) {
+			if ( sv_maxPing->value && ping > sv_maxPing->value )
+			{
 				NET_OutOfBandPrint( NS_SERVER, from, "print\nServer is for low pings only" );
 				Com_DPrintf ("Client %i rejected on a too high ping\n", i);
 				return;
@@ -197,7 +201,7 @@
 			continue;
 		}
 		if ( NET_CompareBaseAdr( from, cl->netchan.remoteAddress )
-			&& ( cl->netchan.qport == qport 
+			&& ( cl->netchan.qport == qport
 			|| from.port == cl->netchan.remoteAddress.port ) ) {
 			Com_Printf ("%s:reconnect\n", NET_AdrToString (from));
 			newcl = cl;
@@ -256,7 +260,7 @@
 	cl->reliableAcknowledge = 0;
 	cl->reliableSequence = 0;
 
-gotnewcl:	
+gotnewcl:
 	// build a new connection
 	// accept the new client
 	// this is the only place a client_t is ever initialized
@@ -298,7 +302,7 @@
 	newcl->nextSnapshotTime = svs.time;
 	newcl->lastPacketTime = svs.time;
 	newcl->lastConnectTime = svs.time;
-	
+
 	// when we receive the first packet from the client, we will
 	// notice that it is from a different serverid and that the
 	// gamestate message was not just sent, forcing a retransmit
@@ -366,7 +370,7 @@
 
 	// nuke user info
 	SV_SetUserinfo( drop - svs.clients, "" );
-	
+
 	Com_DPrintf( "Going to CS_ZOMBIE for %s\n", drop->name );
 	drop->state = CS_ZOMBIE;		// become free in a few seconds
 
@@ -604,7 +608,7 @@
 SV_WriteDownloadToClient
 
 Check to see if the client wants a file, open it if needed and start pumping the client
-Fill up msg with data 
+Fill up msg with data
 ==================
 */
 void SV_WriteDownloadToClient( client_t *cl , msg_t *msg )
@@ -624,7 +628,7 @@
  		// Chop off filename extension.
 		Com_sprintf(pakbuf, sizeof(pakbuf), "%s", cl->downloadName);
 		pakptr = Q_strrchr(pakbuf, '.');
-		
+
 		if(pakptr)
 		{
 			*pakptr = '\0';
@@ -705,9 +709,9 @@
 			*cl->downloadName = 0;
 			return;
 		}
- 
+
 		Com_Printf( "clientDownload: %d : beginning \"%s\"\n", (int) (cl - svs.clients), cl->downloadName );
-		
+
 		// Init
 		cl->downloadCurrentBlock = cl->downloadClientBlock = cl->downloadXmitBlock = 0;
 		cl->downloadCount = 0;
@@ -807,7 +811,7 @@
 		// block zero is special, contains file size
 		if ( cl->downloadXmitBlock == 0 )
 			MSG_WriteLong( msg, cl->downloadSize );
- 
+
 		MSG_WriteShort( msg, cl->downloadBlockSize[curindex] );
 
 		// Write the block
@@ -856,7 +860,7 @@
 	const char *pPaks, *pArg;
 	qboolean bGood = qtrue;
 
-	// if we are pure, we "expect" the client to load certain things from 
+	// if we are pure, we "expect" the client to load certain things from
 	// certain pk3 files, namely we want the client to have loaded the
 	// ui and cgame that we think should be loaded based on the pure setting
 	//
@@ -889,7 +893,7 @@
 				return;
 			}
 		}
-	
+
 		// we basically use this while loop to avoid using 'goto' :)
 		while (bGood) {
 
@@ -988,7 +992,7 @@
 
 		if (bGood) {
 			cl->pureAuthentic = 1;
-		} 
+		}
 		else {
 			cl->pureAuthentic = 0;
 			cl->nextSnapshotTime = -1;
@@ -1067,7 +1071,7 @@
 	} else {
 		cl->snapshotMsec = 50;
 	}
-	
+
 	// TTimo
 	// maintain the IP information
 	// the banning code relies on this being consistently present
@@ -1131,7 +1135,7 @@
 void SV_ExecuteClientCommand( client_t *cl, const char *s, qboolean clientOK ) {
 	ucmd_t	*u;
 	qboolean bProcessed = qfalse;
-	
+
 	Cmd_TokenizeString( s );
 
 	// see if it is a server level command
@@ -1175,7 +1179,7 @@
 
 	// drop the connection if we have somehow lost commands
 	if ( seq > cl->lastClientCommand + 1 ) {
-		Com_Printf( "Client %s lost %i clientCommands\n", cl->name, 
+		Com_Printf( "Client %s lost %i clientCommands\n", cl->name,
 			seq - cl->lastClientCommand + 1 );
 		SV_DropClient( cl, "Lost reliable commands" );
 		return qfalse;
@@ -1189,9 +1193,9 @@
 	// We don't do this when the client hasn't been active yet since its
 	// normal to spam a lot of commands when downloading
 #if 0 // flood protection in game for trem
-	if ( !com_cl_running->integer && 
+	if ( !com_cl_running->integer &&
 		cl->state >= CS_ACTIVE &&
-		sv_floodProtect->integer && 
+		sv_floodProtect->integer &&
 		svs.time < cl->nextReliableTime ) {
 		// ignore any other text messages from this client but let them keep playing
 		// TTimo - moved the ignored verbose to the actual processing in SV_ExecuteClientCommand, only printing if the core doesn't intercept
@@ -1235,7 +1239,7 @@
 ==================
 SV_UserMove
 
-The message usually contains all the movement commands 
+The message usually contains all the movement commands
 that were in the last three packets, so that the information
 in dropped packets can be recovered.
 
@@ -1298,17 +1302,17 @@
 			SV_SendClientGameState( cl );
 		}
 		return;
-	}			
-	
+	}
+
 	// if this is the first usercmd we have received
 	// this gamestate, put the client into the world
 	if ( cl->state == CS_PRIMED ) {
 		SV_ClientEnterWorld( cl, &cmds[0] );
 		// the moves can be processed normaly
 	}
-	
+
 	// a bad cp command was sent, drop the client
-	if (sv_pure->integer != 0 && cl->pureAuthentic == 0) {		
+	if (sv_pure->integer != 0 && cl->pureAuthentic == 0) {
 		SV_DropClient( cl, "Cannot validate pure client!");
 		return;
 	}
@@ -1389,7 +1393,7 @@
 	}
 	// if this is a usercmd from a previous gamestate,
 	// ignore it or retransmit the current gamestate
-	// 
+	//
 	// if the client was downloading, let it stay at whatever serverId and
 	// gamestate it was at.  This allows it to keep downloading even when
 	// the gamestate changes.  After the download is finished, we'll
Index: src/server/sv_snapshot.c
===================================================================
--- src/server/sv_snapshot.c	(revision 1055)
+++ src/server/sv_snapshot.c	(working copy)
@@ -134,7 +134,7 @@
 		// client is asking for a retransmit
 		oldframe = NULL;
 		lastframe = 0;
-	} else if ( client->netchan.outgoingSequence - client->deltaMessage 
+	} else if ( client->netchan.outgoingSequence - client->deltaMessage
 		>= (PACKET_BACKUP - 3) ) {
 		// client hasn't gotten a good message through in a long time
 		Com_DPrintf ("%s: Delta request from out of date packet.\n", client->name);
@@ -239,7 +239,7 @@
 #define	MAX_SNAPSHOT_ENTITIES	1024
 typedef struct {
 	int		numSnapshotEntities;
-	int		snapshotEntities[MAX_SNAPSHOT_ENTITIES];	
+	int		snapshotEntities[MAX_SNAPSHOT_ENTITIES];
 } snapshotEntityNumbers_t;
 
 /*
@@ -291,7 +291,7 @@
 SV_AddEntitiesVisibleFromPoint
 ===============
 */
-static void SV_AddEntitiesVisibleFromPoint( vec3_t origin, clientSnapshot_t *frame, 
+static void SV_AddEntitiesVisibleFromPoint( vec3_t origin, clientSnapshot_t *frame,
 									snapshotEntityNumbers_t *eNums, qboolean portal ) {
 	int		e, i;
 	sharedEntity_t *ent;
@@ -468,7 +468,7 @@
 
   // https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=62
 	frame->num_entities = 0;
-	
+
 	clent = client->gentity;
 	if ( !clent || client->state == CS_ZOMBIE ) {
 		return;
@@ -500,7 +500,7 @@
 	// in the list which will need to be resorted for the delta compression
 	// to work correctly.  This also catches the error condition
 	// of an entity being included twice.
-	qsort( entityNumbers.snapshotEntities, entityNumbers.numSnapshotEntities, 
+	qsort( entityNumbers.snapshotEntities, entityNumbers.numSnapshotEntities,
 		sizeof( entityNumbers.snapshotEntities[0] ), SV_QsortEntityNumbers );
 
 	// now that all viewpoint's areabits have been OR'd together, invert
@@ -591,7 +591,7 @@
 		client->nextSnapshotTime = svs.time + (1000.0 / sv_fps->integer * com_timescale->value);
 		return;
 	}
-	
+
 	// normal rate / snapshotMsec calculation
 	rateMsec = SV_RateMsec(client, msg->cursize);
 
@@ -680,7 +680,7 @@
 		// send additional message fragments if the last message
 		// was too large to send at once
 		if ( c->netchan.unsentFragments ) {
-			c->nextSnapshotTime = svs.time + 
+			c->nextSnapshotTime = svs.time +
 				SV_RateMsec( c, c->netchan.unsentLength - c->netchan.unsentFragmentStart );
 			SV_Netchan_TransmitNextFragment( c );
 			continue;
Index: src/server/server.h
===================================================================
--- src/server/server.h	(revision 1055)
+++ src/server/server.h	(working copy)
@@ -228,6 +228,8 @@
 extern	cvar_t	*sv_rconPassword;
 extern	cvar_t	*sv_privatePassword;
 extern	cvar_t	*sv_allowDownload;
+extern	cvar_t	*sv_wwwDownload;
+extern	cvar_t	*sv_wwwBaseURL;
 extern	cvar_t	*sv_maxclients;
 
 extern	cvar_t	*sv_privateClients;
Index: src/server/sv_init.c
===================================================================
--- src/server/sv_init.c	(revision 1055)
+++ src/server/sv_init.c	(working copy)
@@ -621,6 +621,10 @@
 
 	sv_allowDownload = Cvar_Get ("sv_allowDownload", "0", CVAR_SERVERINFO);
 	Cvar_Get ("sv_dlURL", "", CVAR_SERVERINFO | CVAR_ARCHIVE);
+	sv_wwwDownload = Cvar_Get ("sv_wwwDownload", "1",
+		CVAR_SYSTEMINFO|CVAR_ARCHIVE);
+	sv_wwwBaseURL = Cvar_Get ("sv_wwwBaseURL", "",
+		CVAR_SYSTEMINFO|CVAR_ARCHIVE);
 	sv_master[0] = Cvar_Get ("sv_master1", MASTER_SERVER_NAME, 0 );
 	sv_master[1] = Cvar_Get ("sv_master2", "", CVAR_ARCHIVE );
 	sv_master[2] = Cvar_Get ("sv_master3", "", CVAR_ARCHIVE );
Index: src/server/sv_main.c
===================================================================
--- src/server/sv_main.c	(revision 1055)
+++ src/server/sv_main.c	(working copy)
@@ -33,6 +33,8 @@
 cvar_t	*sv_rconPassword;		// password for remote server commands
 cvar_t	*sv_privatePassword;	// password for the privateClient slots
 cvar_t	*sv_allowDownload;
+cvar_t	*sv_wwwBaseURL;
+cvar_t	*sv_wwwDownload;
 cvar_t	*sv_maxclients;
 
 cvar_t	*sv_privateClients;		// number of clients reserved for password
Index: src/qcommon/q_shared.h
===================================================================
--- src/qcommon/q_shared.h	(revision 1055)
+++ src/qcommon/q_shared.h	(working copy)
@@ -27,7 +27,7 @@
 // q_shared.h -- included first by ALL program modules.
 // A user mod should never modify this file
 
-#define PRODUCT_NAME            "tremulous"
+#define PRODUCT_NAME            "bobsoc"
 #define PRODUCT_VERSION         "1.1.0"
 
 #ifdef SVN_VERSION
@@ -46,24 +46,24 @@
 #pragma warning(disable : 4018)     // signed/unsigned mismatch
 #pragma warning(disable : 4032)
 #pragma warning(disable : 4051)
-#pragma warning(disable : 4057)		// slightly different base types
-#pragma warning(disable : 4100)		// unreferenced formal parameter
+#pragma warning(disable : 4057)     // slightly different base types
+#pragma warning(disable : 4100)     // unreferenced formal parameter
 #pragma warning(disable : 4115)
-#pragma warning(disable : 4125)		// decimal digit terminates octal escape sequence
-#pragma warning(disable : 4127)		// conditional expression is constant
+#pragma warning(disable : 4125)     // decimal digit terminates octal escape sequence
+#pragma warning(disable : 4127)     // conditional expression is constant
 #pragma warning(disable : 4136)
-#pragma warning(disable : 4152)		// nonstandard extension, function/data pointer conversion in expression
+#pragma warning(disable : 4152)     // nonstandard extension, function/data pointer conversion in expression
 //#pragma warning(disable : 4201)
 //#pragma warning(disable : 4214)
 #pragma warning(disable : 4244)
-#pragma warning(disable : 4142)		// benign redefinition
-//#pragma warning(disable : 4305)		// truncation from const double to float
-//#pragma warning(disable : 4310)		// cast truncates constant value
-//#pragma warning(disable:  4505) 	// unreferenced local function has been removed
+#pragma warning(disable : 4142)     // benign redefinition
+//#pragma warning(disable : 4305)       // truncation from const double to float
+//#pragma warning(disable : 4310)       // cast truncates constant value
+//#pragma warning(disable:  4505)   // unreferenced local function has been removed
 #pragma warning(disable : 4514)
-#pragma warning(disable : 4702)		// unreachable code
-#pragma warning(disable : 4711)		// selected for automatic inline expansion
-#pragma warning(disable : 4220)		// varargs matches remaining parameters
+#pragma warning(disable : 4702)     // unreachable code
+#pragma warning(disable : 4711)     // selected for automatic inline expansion
+#pragma warning(disable : 4220)     // varargs matches remaining parameters
 //#pragma intrinsic( memset, memcpy )
 #endif
 
@@ -128,14 +128,14 @@
   #endif
 #endif
 
-typedef unsigned char 		byte;
+typedef unsigned char       byte;
 
-typedef enum {qfalse, qtrue}	qboolean;
+typedef enum {qfalse, qtrue}    qboolean;
 
-typedef int		qhandle_t;
-typedef int		sfxHandle_t;
-typedef int		fileHandle_t;
-typedef int		clipHandle_t;
+typedef int     qhandle_t;
+typedef int     sfxHandle_t;
+typedef int     fileHandle_t;
+typedef int     clipHandle_t;
 
 #define PAD(x,y) (((x)+(y)-1) & ~((y)-1))
 
@@ -149,114 +149,114 @@
 #define NULL ((void *)0)
 #endif
 
-#define	MAX_QINT			0x7fffffff
-#define	MIN_QINT			(-MAX_QINT-1)
+#define MAX_QINT            0x7fffffff
+#define MIN_QINT            (-MAX_QINT-1)
 
 
 // angle indexes
-#define	PITCH				0		// up / down
-#define	YAW					1		// left / right
-#define	ROLL				2		// fall over
+#define PITCH               0       // up / down
+#define YAW                 1       // left / right
+#define ROLL                2       // fall over
 
 // the game guarantees that no string from the network will ever
 // exceed MAX_STRING_CHARS
-#define	MAX_STRING_CHARS	1024	// max length of a string passed to Cmd_TokenizeString
-#define	MAX_STRING_TOKENS	1024	// max tokens resulting from Cmd_TokenizeString
-#define	MAX_TOKEN_CHARS		1024	// max length of an individual token
+#define MAX_STRING_CHARS    1024    // max length of a string passed to Cmd_TokenizeString
+#define MAX_STRING_TOKENS   1024    // max tokens resulting from Cmd_TokenizeString
+#define MAX_TOKEN_CHARS     1024    // max length of an individual token
 
-#define	MAX_INFO_STRING		1024
-#define	MAX_INFO_KEY		  1024
-#define	MAX_INFO_VALUE		1024
+#define MAX_INFO_STRING     1024
+#define MAX_INFO_KEY          1024
+#define MAX_INFO_VALUE      1024
 
-#define	BIG_INFO_STRING		8192  // used for system info key only
-#define	BIG_INFO_KEY		  8192
-#define	BIG_INFO_VALUE		8192
+#define BIG_INFO_STRING     8192  // used for system info key only
+#define BIG_INFO_KEY          8192
+#define BIG_INFO_VALUE      8192
 
 
-#define	MAX_QPATH			64		// max length of a quake game pathname
+#define MAX_QPATH           64      // max length of a quake game pathname
 #ifdef PATH_MAX
-#define MAX_OSPATH			PATH_MAX
+#define MAX_OSPATH          PATH_MAX
 #else
-#define	MAX_OSPATH			256		// max length of a filesystem pathname
+#define MAX_OSPATH          256     // max length of a filesystem pathname
 #endif
 
-#define	MAX_NAME_LENGTH			32		// max length of a client name
-#define	MAX_HOSTNAME_LENGTH	80		// max length of a host name
+#define MAX_NAME_LENGTH         32      // max length of a client name
+#define MAX_HOSTNAME_LENGTH 80      // max length of a host name
 
-#define	MAX_SAY_TEXT	150
+#define MAX_SAY_TEXT    150
 
 // paramters for command buffer stuffing
 typedef enum {
-	EXEC_NOW,			// don't return until completed, a VM should NEVER use this,
-						// because some commands might cause the VM to be unloaded...
-	EXEC_INSERT,		// insert at current position, but don't run yet
-	EXEC_APPEND			// add to end of the command buffer (normal case)
+    EXEC_NOW,           // don't return until completed, a VM should NEVER use this,
+                        // because some commands might cause the VM to be unloaded...
+    EXEC_INSERT,        // insert at current position, but don't run yet
+    EXEC_APPEND         // add to end of the command buffer (normal case)
 } cbufExec_t;
 
 
 //
 // these aren't needed by any of the VMs.  put in another header?
 //
-#define	MAX_MAP_AREA_BYTES		32		// bit vector of area visibility
+#define MAX_MAP_AREA_BYTES      32      // bit vector of area visibility
 
 
 // print levels from renderer (FIXME: set up for game / cgame?)
 typedef enum {
-	PRINT_ALL,
-	PRINT_DEVELOPER,		// only print when "developer 1"
-	PRINT_WARNING,
-	PRINT_ERROR
+    PRINT_ALL,
+    PRINT_DEVELOPER,        // only print when "developer 1"
+    PRINT_WARNING,
+    PRINT_ERROR
 } printParm_t;
 
 
 #ifdef ERR_FATAL
-#undef ERR_FATAL			// this is be defined in malloc.h
+#undef ERR_FATAL            // this is be defined in malloc.h
 #endif
 
 // parameters to the main Error routine
 typedef enum {
-	ERR_FATAL,					// exit the entire game with a popup window
-	ERR_DROP,					// print to console and disconnect from game
-	ERR_SERVERDISCONNECT,		// don't kill server
-	ERR_DISCONNECT,				// client disconnected from the server
-	ERR_NEED_CD					// pop up the need-cd dialog
+    ERR_FATAL,                  // exit the entire game with a popup window
+    ERR_DROP,                   // print to console and disconnect from game
+    ERR_SERVERDISCONNECT,       // don't kill server
+    ERR_DISCONNECT,             // client disconnected from the server
+    ERR_NEED_CD                 // pop up the need-cd dialog
 } errorParm_t;
 
 
 // font rendering values used by ui and cgame
 
-#define PROP_GAP_WIDTH			3
-#define PROP_SPACE_WIDTH		8
-#define PROP_HEIGHT				27
-#define PROP_SMALL_SIZE_SCALE	0.75
+#define PROP_GAP_WIDTH          3
+#define PROP_SPACE_WIDTH        8
+#define PROP_HEIGHT             27
+#define PROP_SMALL_SIZE_SCALE   0.75
 
-#define BLINK_DIVISOR			200
-#define PULSE_DIVISOR			75
+#define BLINK_DIVISOR           200
+#define PULSE_DIVISOR           75
 
-#define UI_LEFT			0x00000000	// default
-#define UI_CENTER		0x00000001
-#define UI_RIGHT		0x00000002
-#define UI_FORMATMASK	0x00000007
-#define UI_SMALLFONT	0x00000010
-#define UI_BIGFONT		0x00000020	// default
-#define UI_GIANTFONT	0x00000040
-#define UI_DROPSHADOW	0x00000800
-#define UI_BLINK		0x00001000
-#define UI_INVERSE		0x00002000
-#define UI_PULSE		0x00004000
+#define UI_LEFT         0x00000000  // default
+#define UI_CENTER       0x00000001
+#define UI_RIGHT        0x00000002
+#define UI_FORMATMASK   0x00000007
+#define UI_SMALLFONT    0x00000010
+#define UI_BIGFONT      0x00000020  // default
+#define UI_GIANTFONT    0x00000040
+#define UI_DROPSHADOW   0x00000800
+#define UI_BLINK        0x00001000
+#define UI_INVERSE      0x00002000
+#define UI_PULSE        0x00004000
 
 #if defined(_DEBUG) && !defined(BSPC)
-	#define HUNK_DEBUG
+    #define HUNK_DEBUG
 #endif
 
 typedef enum {
-	h_high,
-	h_low,
-	h_dontcare
+    h_high,
+    h_low,
+    h_dontcare
 } ha_pref;
 
 #ifdef HUNK_DEBUG
-#define Hunk_Alloc( size, preference )				Hunk_AllocDebug(size, preference, #size, __FILE__, __LINE__)
+#define Hunk_Alloc( size, preference )              Hunk_AllocDebug(size, preference, #size, __FILE__, __LINE__)
 void *Hunk_AllocDebug( int size, ha_pref preference, char *label, char *file, int line );
 #else
 void *Hunk_Alloc( int size, ha_pref preference );
@@ -265,11 +265,11 @@
 #define Com_Memset memset
 #define Com_Memcpy memcpy
 
-#define CIN_system	1
-#define CIN_loop	2
-#define	CIN_hold	4
-#define CIN_silent	8
-#define CIN_shader	16
+#define CIN_system  1
+#define CIN_loop    2
+#define CIN_hold    4
+#define CIN_silent  8
+#define CIN_shader  16
 
 /*
 ==============================================================
@@ -286,12 +286,12 @@
 typedef vec_t vec4_t[4];
 typedef vec_t vec5_t[5];
 
-typedef	int	fixed4_t;
-typedef	int	fixed8_t;
-typedef	int	fixed16_t;
+typedef int fixed4_t;
+typedef int fixed8_t;
+typedef int fixed16_t;
 
 #ifndef M_PI
-#define M_PI		3.14159265358979323846f	// matches value in gcc v2 math.h
+#define M_PI        3.14159265358979323846f // matches value in gcc v2 math.h
 #endif
 
 #ifndef M_SQRT2
@@ -302,94 +302,94 @@
 #define M_ROOT3 1.732050808f
 #endif
 
-#define NUMVERTEXNORMALS	162
-extern	vec3_t	bytedirs[NUMVERTEXNORMALS];
+#define NUMVERTEXNORMALS    162
+extern  vec3_t  bytedirs[NUMVERTEXNORMALS];
 
 // all drawing is done to a 640*480 virtual screen size
 // and will be automatically scaled to the real resolution
-#define	SCREEN_WIDTH		640
-#define	SCREEN_HEIGHT		480
+#define SCREEN_WIDTH        640
+#define SCREEN_HEIGHT       480
 
-#define TINYCHAR_WIDTH		(SMALLCHAR_WIDTH)
-#define TINYCHAR_HEIGHT		(SMALLCHAR_HEIGHT/2)
+#define TINYCHAR_WIDTH      (SMALLCHAR_WIDTH)
+#define TINYCHAR_HEIGHT     (SMALLCHAR_HEIGHT/2)
 
-#define SMALLCHAR_WIDTH		8
-#define SMALLCHAR_HEIGHT	16
+#define SMALLCHAR_WIDTH     8
+#define SMALLCHAR_HEIGHT    16
 
-#define BIGCHAR_WIDTH		16
-#define BIGCHAR_HEIGHT		16
+#define BIGCHAR_WIDTH       16
+#define BIGCHAR_HEIGHT      16
 
-#define	GIANTCHAR_WIDTH		32
-#define	GIANTCHAR_HEIGHT	48
+#define GIANTCHAR_WIDTH     32
+#define GIANTCHAR_HEIGHT    48
 
-extern	vec4_t		colorBlack;
-extern	vec4_t		colorRed;
-extern	vec4_t		colorGreen;
-extern	vec4_t		colorBlue;
-extern	vec4_t		colorYellow;
-extern	vec4_t		colorMagenta;
-extern	vec4_t		colorCyan;
-extern	vec4_t		colorWhite;
-extern	vec4_t		colorLtGrey;
-extern	vec4_t		colorMdGrey;
-extern	vec4_t		colorDkGrey;
+extern  vec4_t      colorBlack;
+extern  vec4_t      colorRed;
+extern  vec4_t      colorGreen;
+extern  vec4_t      colorBlue;
+extern  vec4_t      colorYellow;
+extern  vec4_t      colorMagenta;
+extern  vec4_t      colorCyan;
+extern  vec4_t      colorWhite;
+extern  vec4_t      colorLtGrey;
+extern  vec4_t      colorMdGrey;
+extern  vec4_t      colorDkGrey;
 
-#define Q_COLOR_ESCAPE	'^'
-#define Q_IsColorString(p)	( p && *(p) == Q_COLOR_ESCAPE && *((p)+1) && isalnum(*((p)+1)) ) // ^[0-9a-zA-Z]
+#define Q_COLOR_ESCAPE  '^'
+#define Q_IsColorString(p)  ( p && *(p) == Q_COLOR_ESCAPE && *((p)+1) && isalnum(*((p)+1)) ) // ^[0-9a-zA-Z]
 
-#define COLOR_BLACK		'0'
-#define COLOR_RED		'1'
-#define COLOR_GREEN		'2'
-#define COLOR_YELLOW	'3'
-#define COLOR_BLUE		'4'
-#define COLOR_CYAN		'5'
-#define COLOR_MAGENTA	'6'
-#define COLOR_WHITE		'7'
-#define ColorIndex(c)	( ( (c) - '0' ) & 7 )
+#define COLOR_BLACK     '0'
+#define COLOR_RED       '1'
+#define COLOR_GREEN     '2'
+#define COLOR_YELLOW    '3'
+#define COLOR_BLUE      '4'
+#define COLOR_CYAN      '5'
+#define COLOR_MAGENTA   '6'
+#define COLOR_WHITE     '7'
+#define ColorIndex(c)   ( ( (c) - '0' ) & 7 )
 
-#define S_COLOR_BLACK	"^0"
-#define S_COLOR_RED		"^1"
-#define S_COLOR_GREEN	"^2"
-#define S_COLOR_YELLOW	"^3"
-#define S_COLOR_BLUE	"^4"
-#define S_COLOR_CYAN	"^5"
-#define S_COLOR_MAGENTA	"^6"
-#define S_COLOR_WHITE	"^7"
+#define S_COLOR_BLACK   "^0"
+#define S_COLOR_RED     "^1"
+#define S_COLOR_GREEN   "^2"
+#define S_COLOR_YELLOW  "^3"
+#define S_COLOR_BLUE    "^4"
+#define S_COLOR_CYAN    "^5"
+#define S_COLOR_MAGENTA "^6"
+#define S_COLOR_WHITE   "^7"
 
-extern vec4_t	g_color_table[8];
+extern vec4_t   g_color_table[8];
 
-#define	MAKERGB( v, r, g, b ) v[0]=r;v[1]=g;v[2]=b
-#define	MAKERGBA( v, r, g, b, a ) v[0]=r;v[1]=g;v[2]=b;v[3]=a
+#define MAKERGB( v, r, g, b ) v[0]=r;v[1]=g;v[2]=b
+#define MAKERGBA( v, r, g, b, a ) v[0]=r;v[1]=g;v[2]=b;v[3]=a
 
 #define DEG2RAD( a ) ( ( (a) * M_PI ) / 180.0F )
 #define RAD2DEG( a ) ( ( (a) * 180.0f ) / M_PI )
 
 struct cplane_s;
 
-extern	vec3_t	vec3_origin;
-extern	vec3_t	axisDefault[3];
+extern  vec3_t  vec3_origin;
+extern  vec3_t  axisDefault[3];
 
-#define	nanmask (255<<23)
+#define nanmask (255<<23)
 
-#define	IS_NAN(x) (((*(int *)&x)&nanmask)==nanmask)
+#define IS_NAN(x) (((*(int *)&x)&nanmask)==nanmask)
 
 #if idppc
 
 static ID_INLINE float Q_rsqrt( float number ) {
-		float x = 0.5f * number;
+        float x = 0.5f * number;
                 float y;
-#ifdef __GNUC__            
+#ifdef __GNUC__
                 asm("frsqrte %0,%1" : "=f" (y) : "f" (number));
 #else
-		y = __frsqrte( number );
+        y = __frsqrte( number );
 #endif
-		return y * (1.5f - (x * y * y));
-	}
+        return y * (1.5f - (x * y * y));
+    }
 
-#ifdef __GNUC__            
+#ifdef __GNUC__
 static ID_INLINE float Q_fabs(float x) {
     float abs_x;
-    
+
     asm("fabs %0,%1" : "=f" (abs_x) : "f" (x));
     return abs_x;
 }
@@ -399,7 +399,7 @@
 
 #else
 float Q_fabs( float f );
-float Q_rsqrt( float f );		// reciprocal square root
+float Q_rsqrt( float f );       // reciprocal square root
 #endif
 
 #define SQRTFAST( x ) ( (x) * Q_rsqrt( x ) )
@@ -411,26 +411,26 @@
 int DirToByte( vec3_t dir );
 void ByteToDir( int b, vec3_t dir );
 
-#if	1
+#if 1
 
-#define DotProduct(x,y)			((x)[0]*(y)[0]+(x)[1]*(y)[1]+(x)[2]*(y)[2])
-#define VectorSubtract(a,b,c)	((c)[0]=(a)[0]-(b)[0],(c)[1]=(a)[1]-(b)[1],(c)[2]=(a)[2]-(b)[2])
-#define VectorAdd(a,b,c)		((c)[0]=(a)[0]+(b)[0],(c)[1]=(a)[1]+(b)[1],(c)[2]=(a)[2]+(b)[2])
-#define VectorCopy(a,b)			((b)[0]=(a)[0],(b)[1]=(a)[1],(b)[2]=(a)[2])
-#define	VectorScale(v, s, o)	((o)[0]=(v)[0]*(s),(o)[1]=(v)[1]*(s),(o)[2]=(v)[2]*(s))
-#define	VectorMA(v, s, b, o)	((o)[0]=(v)[0]+(b)[0]*(s),(o)[1]=(v)[1]+(b)[1]*(s),(o)[2]=(v)[2]+(b)[2]*(s))
+#define DotProduct(x,y)         ((x)[0]*(y)[0]+(x)[1]*(y)[1]+(x)[2]*(y)[2])
+#define VectorSubtract(a,b,c)   ((c)[0]=(a)[0]-(b)[0],(c)[1]=(a)[1]-(b)[1],(c)[2]=(a)[2]-(b)[2])
+#define VectorAdd(a,b,c)        ((c)[0]=(a)[0]+(b)[0],(c)[1]=(a)[1]+(b)[1],(c)[2]=(a)[2]+(b)[2])
+#define VectorCopy(a,b)         ((b)[0]=(a)[0],(b)[1]=(a)[1],(b)[2]=(a)[2])
+#define VectorScale(v, s, o)    ((o)[0]=(v)[0]*(s),(o)[1]=(v)[1]*(s),(o)[2]=(v)[2]*(s))
+#define VectorMA(v, s, b, o)    ((o)[0]=(v)[0]+(b)[0]*(s),(o)[1]=(v)[1]+(b)[1]*(s),(o)[2]=(v)[2]+(b)[2]*(s))
 #define VectorLerp( f, s, e, r ) ((r)[0]=(s)[0]+(f)*((e)[0]-(s)[0]),\
   (r)[1]=(s)[1]+(f)*((e)[1]-(s)[1]),\
-  (r)[2]=(s)[2]+(f)*((e)[2]-(s)[2])) 
+  (r)[2]=(s)[2]+(f)*((e)[2]-(s)[2]))
 
 #else
 
-#define DotProduct(x,y)			_DotProduct(x,y)
-#define VectorSubtract(a,b,c)	_VectorSubtract(a,b,c)
-#define VectorAdd(a,b,c)		_VectorAdd(a,b,c)
-#define VectorCopy(a,b)			_VectorCopy(a,b)
-#define	VectorScale(v, s, o)	_VectorScale(v,s,o)
-#define	VectorMA(v, s, b, o)	_VectorMA(v,s,b,o)
+#define DotProduct(x,y)         _DotProduct(x,y)
+#define VectorSubtract(a,b,c)   _VectorSubtract(a,b,c)
+#define VectorAdd(a,b,c)        _VectorAdd(a,b,c)
+#define VectorCopy(a,b)         _VectorCopy(a,b)
+#define VectorScale(v, s, o)    _VectorScale(v,s,o)
+#define VectorMA(v, s, b, o)    _VectorMA(v,s,b,o)
 
 #endif
 
@@ -439,20 +439,20 @@
 #undef VectorCopy
 // this is a little hack to get more efficient copies in our interpreter
 typedef struct {
-	float	v[3];
+    float   v[3];
 } vec3struct_t;
-#define VectorCopy(a,b)	(*(vec3struct_t *)b=*(vec3struct_t *)a)
+#define VectorCopy(a,b) (*(vec3struct_t *)b=*(vec3struct_t *)a)
 #endif
 #endif
 
 #define Vector2Set(v, x, y) ((v)[0]=(x), (v)[1]=(y))
-#define VectorClear(a)			((a)[0]=(a)[1]=(a)[2]=0)
-#define VectorNegate(a,b)		((b)[0]=-(a)[0],(b)[1]=-(a)[1],(b)[2]=-(a)[2])
-#define VectorSet(v, x, y, z)	((v)[0]=(x), (v)[1]=(y), (v)[2]=(z))
-#define Vector4Copy(a,b)		((b)[0]=(a)[0],(b)[1]=(a)[1],(b)[2]=(a)[2],(b)[3]=(a)[3])
+#define VectorClear(a)          ((a)[0]=(a)[1]=(a)[2]=0)
+#define VectorNegate(a,b)       ((b)[0]=-(a)[0],(b)[1]=-(a)[1],(b)[2]=-(a)[2])
+#define VectorSet(v, x, y, z)   ((v)[0]=(x), (v)[1]=(y), (v)[2]=(z))
+#define Vector4Copy(a,b)        ((b)[0]=(a)[0],(b)[1]=(a)[1],(b)[2]=(a)[2],(b)[3]=(a)[3])
 #define Vector4Add(a,b,c)    ((c)[0]=(a)[0]+(b)[0],(c)[1]=(a)[1]+(b)[1],(c)[2]=(a)[2]+(b)[2],(c)[3]=(a)[3]+(b)[3])
 
-#define	SnapVector(v) {v[0]=((int)(v[0]));v[1]=((int)(v[1]));v[2]=((int)(v[2]));}
+#define SnapVector(v) {v[0]=((int)(v[0]));v[1]=((int)(v[1]));v[2]=((int)(v[2]));}
 // just in case you do't want to use the macros
 vec_t _DotProduct( const vec3_t v1, const vec3_t v2 );
 void _VectorSubtract( const vec3_t veca, const vec3_t vecb, vec3_t out );
@@ -472,73 +472,73 @@
 
 #if !defined( Q3_VM ) || ( defined( Q3_VM ) && defined( __Q3_VM_MATH ) )
 static ID_INLINE int VectorCompare( const vec3_t v1, const vec3_t v2 ) {
-	if (v1[0] != v2[0] || v1[1] != v2[1] || v1[2] != v2[2]) {
-		return 0;
-	}			
-	return 1;
+    if (v1[0] != v2[0] || v1[1] != v2[1] || v1[2] != v2[2]) {
+        return 0;
+    }
+    return 1;
 }
 
 static ID_INLINE int VectorCompareEpsilon(
-		const vec3_t v1, const vec3_t v2, float epsilon )
+        const vec3_t v1, const vec3_t v2, float epsilon )
 {
-	vec3_t d;
+    vec3_t d;
 
-	VectorSubtract( v1, v2, d );
-	d[ 0 ] = fabs( d[ 0 ] );
-	d[ 1 ] = fabs( d[ 1 ] );
-	d[ 2 ] = fabs( d[ 2 ] );
+    VectorSubtract( v1, v2, d );
+    d[ 0 ] = fabs( d[ 0 ] );
+    d[ 1 ] = fabs( d[ 1 ] );
+    d[ 2 ] = fabs( d[ 2 ] );
 
-	if( d[ 0 ] > epsilon || d[ 1 ] > epsilon || d[ 2 ] > epsilon )
-		return 0;
+    if( d[ 0 ] > epsilon || d[ 1 ] > epsilon || d[ 2 ] > epsilon )
+        return 0;
 
-	return 1;
+    return 1;
 }
 
 static ID_INLINE vec_t VectorLength( const vec3_t v ) {
-	return (vec_t)sqrt (v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
+    return (vec_t)sqrt (v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
 }
 
 static ID_INLINE vec_t VectorLengthSquared( const vec3_t v ) {
-	return (v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
+    return (v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
 }
 
 static ID_INLINE vec_t Distance( const vec3_t p1, const vec3_t p2 ) {
-	vec3_t	v;
+    vec3_t  v;
 
-	VectorSubtract (p2, p1, v);
-	return VectorLength( v );
+    VectorSubtract (p2, p1, v);
+    return VectorLength( v );
 }
 
 static ID_INLINE vec_t DistanceSquared( const vec3_t p1, const vec3_t p2 ) {
-	vec3_t	v;
+    vec3_t  v;
 
-	VectorSubtract (p2, p1, v);
-	return v[0]*v[0] + v[1]*v[1] + v[2]*v[2];
+    VectorSubtract (p2, p1, v);
+    return v[0]*v[0] + v[1]*v[1] + v[2]*v[2];
 }
 
 // fast vector normalize routine that does not check to make sure
 // that length != 0, nor does it return length, uses rsqrt approximation
 static ID_INLINE void VectorNormalizeFast( vec3_t v )
 {
-	float ilength;
+    float ilength;
 
-	ilength = Q_rsqrt( DotProduct( v, v ) );
+    ilength = Q_rsqrt( DotProduct( v, v ) );
 
-	v[0] *= ilength;
-	v[1] *= ilength;
-	v[2] *= ilength;
+    v[0] *= ilength;
+    v[1] *= ilength;
+    v[2] *= ilength;
 }
 
 static ID_INLINE void VectorInverse( vec3_t v ){
-	v[0] = -v[0];
-	v[1] = -v[1];
-	v[2] = -v[2];
+    v[0] = -v[0];
+    v[1] = -v[1];
+    v[2] = -v[2];
 }
 
 static ID_INLINE void CrossProduct( const vec3_t v1, const vec3_t v2, vec3_t cross ) {
-	cross[0] = v1[1]*v2[2] - v1[2]*v2[1];
-	cross[1] = v1[2]*v2[0] - v1[0]*v2[2];
-	cross[2] = v1[0]*v2[1] - v1[1]*v2[0];
+    cross[0] = v1[1]*v2[2] - v1[2]*v2[1];
+    cross[1] = v1[2]*v2[0] - v1[0]*v2[2];
+    cross[2] = v1[0]*v2[1] - v1[1]*v2[0];
 }
 
 #else
@@ -560,7 +560,7 @@
 
 #endif
 
-vec_t VectorNormalize (vec3_t v);		// returns vector length
+vec_t VectorNormalize (vec3_t v);       // returns vector length
 vec_t VectorNormalize2( const vec3_t v, vec3_t out );
 void Vector4Scale( const vec4_t in, vec_t scale, vec4_t out );
 void VectorRotate( vec3_t in, vec3_t matrix[3], vec3_t out );
@@ -568,12 +568,12 @@
 
 float Q_acos(float c);
 
-int		Q_rand( int *seed );
-float	Q_random( int *seed );
-float	Q_crandom( int *seed );
+int     Q_rand( int *seed );
+float   Q_random( int *seed );
+float   Q_crandom( int *seed );
 
-#define random()	((rand () & 0x7fff) / ((float)0x7fff))
-#define crandom()	(2.0 * (random() - 0.5))
+#define random()    ((rand () & 0x7fff) / ((float)0x7fff))
+#define crandom()   (2.0 * (random() - 0.5))
 
 void vectoangles( const vec3_t value1, vec3_t angles);
 void AnglesToAxis( const vec3_t angles, vec3_t axis[3] );
@@ -586,16 +586,16 @@
 int BoxOnPlaneSide (vec3_t emins, vec3_t emaxs, struct cplane_s *plane);
 
 qboolean BoundsIntersect(const vec3_t mins, const vec3_t maxs,
-		const vec3_t mins2, const vec3_t maxs2);
+        const vec3_t mins2, const vec3_t maxs2);
 qboolean BoundsIntersectSphere(const vec3_t mins, const vec3_t maxs,
-		const vec3_t origin, vec_t radius);
+        const vec3_t origin, vec_t radius);
 qboolean BoundsIntersectPoint(const vec3_t mins, const vec3_t maxs,
-		const vec3_t origin);
+        const vec3_t origin);
 
-float	AngleMod(float a);
-float	LerpAngle (float from, float to, float frac);
-float	AngleSubtract( float a1, float a2 );
-void	AnglesSubtract( vec3_t v1, vec3_t v2, vec3_t v3 );
+float   AngleMod(float a);
+float   LerpAngle (float from, float to, float frac);
+float   AngleSubtract( float a1, float a2 );
+void    AnglesSubtract( vec3_t v1, vec3_t v2, vec3_t v3 );
 
 float AngleNormalize360 ( float angle );
 float AngleNormalize180 ( float angle );
@@ -608,7 +608,7 @@
 void MakeNormalVectors( const vec3_t forward, vec3_t right, vec3_t up );
 // perpendicular vector could be replaced by this
 
-//int	PlaneTypeForNormal (vec3_t normal);
+//int   PlaneTypeForNormal (vec3_t normal);
 
 void MatrixMultiply(float in1[3][3], float in2[3][3], float out[3][3]);
 void VectorMatrixMultiply( const vec3_t p, vec3_t m[ 3 ], vec3_t out );
@@ -617,9 +617,9 @@
 int Q_isnan( float x );
 
 void GetPerpendicularViewVector( const vec3_t point, const vec3_t p1,
-		const vec3_t p2, vec3_t up );
+        const vec3_t p2, vec3_t up );
 void ProjectPointOntoVector( vec3_t point, vec3_t vStart,
-		vec3_t vEnd, vec3_t vProj );
+        vec3_t vEnd, vec3_t vProj );
 float VectorDistance( vec3_t v1, vec3_t v2 );
 
 float pointToLineDistance( const vec3_t point, const vec3_t p1, const vec3_t p2 );
@@ -647,43 +647,43 @@
 
 float Com_Clamp( float min, float max, float value );
 
-char	*COM_SkipPath( char *pathname );
-const char	*COM_GetExtension( const char *name );
-void	COM_StripExtension(const char *in, char *out, int destsize);
-void	COM_DefaultExtension( char *path, int maxSize, const char *extension );
+char    *COM_SkipPath( char *pathname );
+const char  *COM_GetExtension( const char *name );
+void    COM_StripExtension(const char *in, char *out, int destsize);
+void    COM_DefaultExtension( char *path, int maxSize, const char *extension );
 
-void	COM_BeginParseSession( const char *name );
-int		COM_GetCurrentParseLine( void );
-char	*COM_Parse( char **data_p );
-char	*COM_ParseExt( char **data_p, qboolean allowLineBreak );
-int		COM_Compress( char *data_p );
-void	COM_ParseError( char *format, ... ) __attribute__ ((format (printf, 1, 2)));
-void	COM_ParseWarning( char *format, ... ) __attribute__ ((format (printf, 1, 2)));
-//int		COM_ParseInfos( char *buf, int max, char infos[][MAX_INFO_STRING] );
+void    COM_BeginParseSession( const char *name );
+int     COM_GetCurrentParseLine( void );
+char    *COM_Parse( char **data_p );
+char    *COM_ParseExt( char **data_p, qboolean allowLineBreak );
+int     COM_Compress( char *data_p );
+void    COM_ParseError( char *format, ... ) __attribute__ ((format (printf, 1, 2)));
+void    COM_ParseWarning( char *format, ... ) __attribute__ ((format (printf, 1, 2)));
+//int       COM_ParseInfos( char *buf, int max, char infos[][MAX_INFO_STRING] );
 
-#define MAX_TOKENLENGTH		1024
+#define MAX_TOKENLENGTH     1024
 
 #ifndef TT_STRING
 //token types
-#define TT_STRING					1			// string
-#define TT_LITERAL					2			// literal
-#define TT_NUMBER					3			// number
-#define TT_NAME						4			// name
-#define TT_PUNCTUATION				5			// punctuation
+#define TT_STRING                   1           // string
+#define TT_LITERAL                  2           // literal
+#define TT_NUMBER                   3           // number
+#define TT_NAME                     4           // name
+#define TT_PUNCTUATION              5           // punctuation
 #endif
 
 typedef struct pc_token_s
 {
-	int type;
-	int subtype;
-	int intvalue;
-	float floatvalue;
-	char string[MAX_TOKENLENGTH];
+    int type;
+    int subtype;
+    int intvalue;
+    float floatvalue;
+    char string[MAX_TOKENLENGTH];
 } pc_token_t;
 
 // data is an in/out parm, returns a parsed out token
 
-void	COM_MatchToken( char**buf_p, char *match );
+void    COM_MatchToken( char**buf_p, char *match );
 
 void SkipBracedSection (char **program);
 void SkipRestOfLine ( char **data );
@@ -692,7 +692,7 @@
 void Parse2DMatrix (char **buf_p, int y, int x, float *m);
 void Parse3DMatrix (char **buf_p, int z, int y, int x, float *m);
 
-void	QDECL Com_sprintf (char *dest, int size, const char *fmt, ...) __attribute__ ((format (printf, 3, 4)));
+void    QDECL Com_sprintf (char *dest, int size, const char *fmt, ...) __attribute__ ((format (printf, 3, 4)));
 
 char *Com_SkipTokens( char *s, int numTokens, char *sep );
 char *Com_SkipCharset( char *s, char *sep );
@@ -701,16 +701,16 @@
 
 // mode parm for FS_FOpenFile
 typedef enum {
-	FS_READ,
-	FS_WRITE,
-	FS_APPEND,
-	FS_APPEND_SYNC
+    FS_READ,
+    FS_WRITE,
+    FS_APPEND,
+    FS_APPEND_SYNC
 } fsMode_t;
 
 typedef enum {
-	FS_SEEK_CUR,
-	FS_SEEK_END,
-	FS_SEEK_SET
+    FS_SEEK_CUR,
+    FS_SEEK_END,
+    FS_SEEK_SET
 } fsOrigin_t;
 
 //=============================================
@@ -721,17 +721,17 @@
 int Q_isalpha( int c );
 
 // portable case insensitive compare
-int		Q_stricmp (const char *s1, const char *s2);
-int		Q_strncmp (const char *s1, const char *s2, int n);
-int		Q_stricmpn (const char *s1, const char *s2, int n);
-char	*Q_strlwr( char *s1 );
-char	*Q_strupr( char *s1 );
-char	*Q_strrchr( const char* string, int c );
-const char	*Q_stristr( const char *s, const char *find);
+int     Q_stricmp (const char *s1, const char *s2);
+int     Q_strncmp (const char *s1, const char *s2, int n);
+int     Q_stricmpn (const char *s1, const char *s2, int n);
+char    *Q_strlwr( char *s1 );
+char    *Q_strupr( char *s1 );
+char    *Q_strrchr( const char* string, int c );
+const char  *Q_stristr( const char *s, const char *find);
 
 // buffer size safe library replacements
-void	Q_strncpyz( char *dest, const char *src, int destsize );
-void	Q_strcat( char *dest, int size, const char *src );
+void    Q_strncpyz( char *dest, const char *src, int destsize );
+void    Q_strcat( char *dest, int size, const char *src );
 
 // strlen that discounts Quake color sequences
 int Q_PrintStrlen( const char *string );
@@ -744,32 +744,32 @@
 // implemented as a struct for qvm compatibility
 typedef struct
 {
-	byte	b0;
-	byte	b1;
-	byte	b2;
-	byte	b3;
-	byte	b4;
-	byte	b5;
-	byte	b6;
-	byte	b7;
+    byte    b0;
+    byte    b1;
+    byte    b2;
+    byte    b3;
+    byte    b4;
+    byte    b5;
+    byte    b6;
+    byte    b7;
 } qint64;
 
 //=============================================
 /*
-short	BigShort(short l);
-short	LittleShort(short l);
-int		BigLong (int l);
-int		LittleLong (int l);
+short   BigShort(short l);
+short   LittleShort(short l);
+int     BigLong (int l);
+int     LittleLong (int l);
 qint64  BigLong64 (qint64 l);
 qint64  LittleLong64 (qint64 l);
-float	BigFloat (const float *l);
-float	LittleFloat (const float *l);
+float   BigFloat (const float *l);
+float   LittleFloat (const float *l);
 
-void	Swap_Init (void);
+void    Swap_Init (void);
 */
-char	* QDECL va(char *format, ...) __attribute__ ((format (printf, 1, 2)));
+char    * QDECL va(char *format, ...) __attribute__ ((format (printf, 1, 2)));
 
-#define TRUNCATE_LENGTH	64
+#define TRUNCATE_LENGTH 64
 void Com_TruncateLongString( char *buffer, const char *s );
 
 //=============================================
@@ -786,8 +786,8 @@
 void Info_NextPair( const char **s, char *key, char *value );
 
 // this is only here so the functions in q_shared.c and bg_*.c can link
-void	QDECL Com_Error( int level, const char *error, ... ) __attribute__ ((format (printf, 2, 3)));
-void	QDECL Com_Printf( const char *msg, ... ) __attribute__ ((format (printf, 1, 2)));
+void    QDECL Com_Error( int level, const char *error, ... ) __attribute__ ((format (printf, 2, 3)));
+void    QDECL Com_Printf( const char *msg, ... ) __attribute__ ((format (printf, 1, 2)));
 
 
 /*
@@ -801,55 +801,55 @@
 ==========================================================
 */
 
-#define	CVAR_ARCHIVE		1	// set to cause it to be saved to vars.rc
-								// used for system variables, not for player
-								// specific configurations
-#define	CVAR_USERINFO		2	// sent to server on connect or change
-#define	CVAR_SERVERINFO		4	// sent in response to front end requests
-#define	CVAR_SYSTEMINFO		8	// these cvars will be duplicated on all clients
-#define	CVAR_INIT			16	// don't allow change from console at all,
-								// but can be set from the command line
-#define	CVAR_LATCH			32	// will only change when C code next does
-								// a Cvar_Get(), so it can't be changed
-								// without proper initialization.  modified
-								// will be set, even though the value hasn't
-								// changed yet
-#define	CVAR_ROM			64	// display only, cannot be set by user at all
-#define	CVAR_USER_CREATED	128	// created by a set command
-#define	CVAR_TEMP			256	// can be set even when cheats are disabled, but is not archived
-#define CVAR_CHEAT			512	// can not be changed if cheats are disabled
-#define CVAR_NORESTART		1024	// do not clear when a cvar_restart is issued
+#define CVAR_ARCHIVE        1   // set to cause it to be saved to vars.rc
+                                // used for system variables, not for player
+                                // specific configurations
+#define CVAR_USERINFO       2   // sent to server on connect or change
+#define CVAR_SERVERINFO     4   // sent in response to front end requests
+#define CVAR_SYSTEMINFO     8   // these cvars will be duplicated on all clients
+#define CVAR_INIT           16  // don't allow change from console at all,
+                                // but can be set from the command line
+#define CVAR_LATCH          32  // will only change when C code next does
+                                // a Cvar_Get(), so it can't be changed
+                                // without proper initialization.  modified
+                                // will be set, even though the value hasn't
+                                // changed yet
+#define CVAR_ROM            64  // display only, cannot be set by user at all
+#define CVAR_USER_CREATED   128 // created by a set command
+#define CVAR_TEMP           256 // can be set even when cheats are disabled, but is not archived
+#define CVAR_CHEAT          512 // can not be changed if cheats are disabled
+#define CVAR_NORESTART      1024    // do not clear when a cvar_restart is issued
 
-#define CVAR_SERVER_CREATED	2048	// cvar was created by a server the client connected to.
-#define CVAR_NONEXISTENT	0xFFFFFFFF	// Cvar doesn't exist.
+#define CVAR_SERVER_CREATED 2048    // cvar was created by a server the client connected to.
+#define CVAR_NONEXISTENT    0xFFFFFFFF  // Cvar doesn't exist.
 
 // nothing outside the Cvar_*() functions should modify these fields!
 typedef struct cvar_s {
-	char		*name;
-	char		*string;
-	char		*resetString;		// cvar_restart will reset to this value
-	char		*latchedString;		// for CVAR_LATCH vars
-	int			flags;
-	qboolean	modified;			// set each time the cvar is changed
-	int			modificationCount;	// incremented each time the cvar is changed
-	float		value;				// atof( string )
-	int			integer;			// atoi( string )
-	struct cvar_s *next;
-	struct cvar_s *hashNext;
+    char        *name;
+    char        *string;
+    char        *resetString;       // cvar_restart will reset to this value
+    char        *latchedString;     // for CVAR_LATCH vars
+    int         flags;
+    qboolean    modified;           // set each time the cvar is changed
+    int         modificationCount;  // incremented each time the cvar is changed
+    float       value;              // atof( string )
+    int         integer;            // atoi( string )
+    struct cvar_s *next;
+    struct cvar_s *hashNext;
 } cvar_t;
 
-#define	MAX_CVAR_VALUE_STRING	256
+#define MAX_CVAR_VALUE_STRING   256
 
-typedef int	cvarHandle_t;
+typedef int cvarHandle_t;
 
 // the modules that run in the virtual machine can't access the cvar_t directly,
 // so they must ask for structured updates
 typedef struct {
-	cvarHandle_t	handle;
-	int			modificationCount;
-	float		value;
-	int			integer;
-	char		string[MAX_CVAR_VALUE_STRING];
+    cvarHandle_t    handle;
+    int         modificationCount;
+    float       value;
+    int         integer;
+    char        string[MAX_CVAR_VALUE_STRING];
 } vmCvar_t;
 
 /*
@@ -860,14 +860,14 @@
 ==============================================================
 */
 
-#include "surfaceflags.h"			// shared with the q3map utility
+#include "surfaceflags.h"           // shared with the q3map utility
 
 // plane types are used to speed some tests
 // 0-2 are axial planes
-#define	PLANE_X			0
-#define	PLANE_Y			1
-#define	PLANE_Z			2
-#define	PLANE_NON_AXIAL	3
+#define PLANE_X         0
+#define PLANE_Y         1
+#define PLANE_Z         2
+#define PLANE_NON_AXIAL 3
 
 
 /*
@@ -881,34 +881,34 @@
 // plane_t structure
 // !!! if this is changed, it must be changed in asm code too !!!
 typedef struct cplane_s {
-	vec3_t	normal;
-	float	dist;
-	byte	type;			// for fast side tests: 0,1,2 = axial, 3 = nonaxial
-	byte	signbits;		// signx + (signy<<1) + (signz<<2), used as lookup during collision
-	byte	pad[2];
+    vec3_t  normal;
+    float   dist;
+    byte    type;           // for fast side tests: 0,1,2 = axial, 3 = nonaxial
+    byte    signbits;       // signx + (signy<<1) + (signz<<2), used as lookup during collision
+    byte    pad[2];
 } cplane_t;
 
 typedef enum {
-	TT_NONE,
+    TT_NONE,
 
-	TT_AABB,
-	TT_CAPSULE,
-	TT_BISPHERE,
+    TT_AABB,
+    TT_CAPSULE,
+    TT_BISPHERE,
 
-	TT_NUM_TRACE_TYPES
+    TT_NUM_TRACE_TYPES
 } traceType_t;
 
 // a trace is returned when a box is swept through the world
 typedef struct {
-	qboolean	allsolid;	// if true, plane is not valid
-	qboolean	startsolid;	// if true, the initial point was in a solid area
-	float		fraction;	// time completed, 1.0 = didn't hit anything
-	vec3_t		endpos;		// final position
-	cplane_t	plane;		// surface normal at impact, transformed to world space
-	int			surfaceFlags;	// surface hit
-	int			contents;	// contents on other side of surface hit
-	int			entityNum;	// entity the contacted sirface is a part of
-	float		lateralFraction; // fraction of collision tangetially to the trace direction
+    qboolean    allsolid;   // if true, plane is not valid
+    qboolean    startsolid; // if true, the initial point was in a solid area
+    float       fraction;   // time completed, 1.0 = didn't hit anything
+    vec3_t      endpos;     // final position
+    cplane_t    plane;      // surface normal at impact, transformed to world space
+    int         surfaceFlags;   // surface hit
+    int         contents;   // contents on other side of surface hit
+    int         entityNum;  // entity the contacted sirface is a part of
+    float       lateralFraction; // fraction of collision tangetially to the trace direction
 } trace_t;
 
 // trace->entityNum can also be 0 to (MAX_GENTITIES-1)
@@ -917,15 +917,15 @@
 
 // markfragments are returned by CM_MarkFragments()
 typedef struct {
-	int		firstPoint;
-	int		numPoints;
+    int     firstPoint;
+    int     numPoints;
 } markFragment_t;
 
 
 
 typedef struct {
-	vec3_t		origin;
-	vec3_t		axis[3];
+    vec3_t      origin;
+    vec3_t      axis[3];
 } orientation_t;
 
 //=====================================================================
@@ -933,23 +933,23 @@
 
 // in order from highest priority to lowest
 // if none of the catchers are active, bound key strings will be executed
-#define KEYCATCH_CONSOLE		0x0001
-#define	KEYCATCH_UI					0x0002
-#define	KEYCATCH_CGAME			0x0008
+#define KEYCATCH_CONSOLE        0x0001
+#define KEYCATCH_UI                 0x0002
+#define KEYCATCH_CGAME          0x0008
 
 
 // sound channels
 // channel 0 never willingly overrides
 // other channels will allways override a playing sound on that channel
 typedef enum {
-	CHAN_AUTO,
-	CHAN_LOCAL,		// menu sounds, etc
-	CHAN_WEAPON,
-	CHAN_VOICE,
-	CHAN_ITEM,
-	CHAN_BODY,
-	CHAN_LOCAL_SOUND,	// chat messages, etc
-	CHAN_ANNOUNCER		// announcer voices, etc
+    CHAN_AUTO,
+    CHAN_LOCAL,     // menu sounds, etc
+    CHAN_WEAPON,
+    CHAN_VOICE,
+    CHAN_ITEM,
+    CHAN_BODY,
+    CHAN_LOCAL_SOUND,   // chat messages, etc
+    CHAN_ANNOUNCER      // announcer voices, etc
 } soundChannel_t;
 
 
@@ -961,63 +961,63 @@
 ========================================================================
 */
 
-#define	ANGLE2SHORT(x)	((int)((x)*65536/360) & 65535)
-#define	SHORT2ANGLE(x)	((x)*(360.0/65536))
+#define ANGLE2SHORT(x)  ((int)((x)*65536/360) & 65535)
+#define SHORT2ANGLE(x)  ((x)*(360.0/65536))
 
-#define	SNAPFLAG_RATE_DELAYED	1
-#define	SNAPFLAG_NOT_ACTIVE		2	// snapshot used during connection and for zombies
-#define SNAPFLAG_SERVERCOUNT	4	// toggled every map_restart so transitions can be detected
+#define SNAPFLAG_RATE_DELAYED   1
+#define SNAPFLAG_NOT_ACTIVE     2   // snapshot used during connection and for zombies
+#define SNAPFLAG_SERVERCOUNT    4   // toggled every map_restart so transitions can be detected
 
 //
 // per-level limits
 //
-#define	MAX_CLIENTS			64		// absolute limit
-#define MAX_LOCATIONS		64
+#define MAX_CLIENTS         64      // absolute limit
+#define MAX_LOCATIONS       64
 
-#define	GENTITYNUM_BITS		10		// don't need to send any more
-#define	MAX_GENTITIES		(1<<GENTITYNUM_BITS)
+#define GENTITYNUM_BITS     10      // don't need to send any more
+#define MAX_GENTITIES       (1<<GENTITYNUM_BITS)
 
 // entitynums are communicated with GENTITY_BITS, so any reserved
 // values that are going to be communcated over the net need to
 // also be in this range
-#define	ENTITYNUM_NONE		(MAX_GENTITIES-1)
-#define	ENTITYNUM_WORLD		(MAX_GENTITIES-2)
-#define	ENTITYNUM_MAX_NORMAL	(MAX_GENTITIES-2)
+#define ENTITYNUM_NONE      (MAX_GENTITIES-1)
+#define ENTITYNUM_WORLD     (MAX_GENTITIES-2)
+#define ENTITYNUM_MAX_NORMAL    (MAX_GENTITIES-2)
 
 
-#define	MAX_MODELS									256		// these are sent over the net as 8 bits
-#define	MAX_SOUNDS									256		// so they cannot be blindly increased
-#define	MAX_GAME_SHADERS						64
-#define	MAX_GAME_PARTICLE_SYSTEMS		64
+#define MAX_MODELS                                  256     // these are sent over the net as 8 bits
+#define MAX_SOUNDS                                  256     // so they cannot be blindly increased
+#define MAX_GAME_SHADERS                        64
+#define MAX_GAME_PARTICLE_SYSTEMS       64
 
 
-#define	MAX_CONFIGSTRINGS	1024
+#define MAX_CONFIGSTRINGS   1024
 
 // these are the only configstrings that the system reserves, all the
 // other ones are strictly for servergame to clientgame communication
-#define	CS_SERVERINFO		0		// an info string with all the serverinfo cvars
-#define	CS_SYSTEMINFO		1		// an info string for server system to client system configuration (timescale, etc)
+#define CS_SERVERINFO       0       // an info string with all the serverinfo cvars
+#define CS_SYSTEMINFO       1       // an info string for server system to client system configuration (timescale, etc)
 
-#define	RESERVED_CONFIGSTRINGS	2	// game can't modify below this, only the system can
+#define RESERVED_CONFIGSTRINGS  2   // game can't modify below this, only the system can
 
-#define	MAX_GAMESTATE_CHARS	16000
+#define MAX_GAMESTATE_CHARS 16000
 typedef struct {
-	int			stringOffsets[MAX_CONFIGSTRINGS];
-	char		stringData[MAX_GAMESTATE_CHARS];
-	int			dataCount;
+    int         stringOffsets[MAX_CONFIGSTRINGS];
+    char        stringData[MAX_GAMESTATE_CHARS];
+    int         dataCount;
 } gameState_t;
 
 //=========================================================
 
 // bit field limits
-#define	MAX_STATS				16
-#define	MAX_PERSISTANT			16
-#define	MAX_MISC    			16
-#define	MAX_WEAPONS				16		
+#define MAX_STATS               16
+#define MAX_PERSISTANT          16
+#define MAX_MISC                16
+#define MAX_WEAPONS             16
 
-#define	MAX_PS_EVENTS			2
+#define MAX_PS_EVENTS           2
 
-#define PS_PMOVEFRAMECOUNTBITS	6
+#define PS_PMOVEFRAMECOUNTBITS  6
 
 // playerState_t is the information needed by both the client and server
 // to predict player motion and actions
@@ -1030,73 +1030,72 @@
 // so if a playerState_t is transmitted, the entityState_t can be fully derived
 // from it.
 typedef struct playerState_s {
-	int			commandTime;	// cmd->serverTime of last executed command
-	int			pm_type;
-	int			bobCycle;		// for view bobbing and footstep generation
-	int			pm_flags;		// ducked, jump_held, etc
-	int			pm_time;
+    int         commandTime;    // cmd->serverTime of last executed command
+    int         pm_type;
+    int         bobCycle;       // for view bobbing and footstep generation
+    int         pm_flags;       // ducked, jump_held, etc
+    int         pm_time;
 
-	vec3_t		origin;
-	vec3_t		velocity;
-	int			weaponTime;
-	int			gravity;
-	int			speed;
-	int			delta_angles[3];	// add to command angles to get view direction
-									// changed by spawns, rotating objects, and teleporters
+    vec3_t      origin;
+    vec3_t      velocity;
+    int         weaponTime;
+    int         gravity;
+    int         speed;
+    int         delta_angles[3];    // add to command angles to get view direction
+                                    // changed by spawns, rotating objects, and teleporters
 
-	int			groundEntityNum;// ENTITYNUM_NONE = in air
+    int         groundEntityNum;// ENTITYNUM_NONE = in air
 
-	int			legsTimer;		// don't change low priority animations until this runs out
-	int			legsAnim;		// mask off ANIM_TOGGLEBIT
+    int         legsTimer;      // don't change low priority animations until this runs out
+    int         legsAnim;       // mask off ANIM_TOGGLEBIT
 
-	int			torsoTimer;		// don't change low priority animations until this runs out
-	int			torsoAnim;		// mask off ANIM_TOGGLEBIT
+    int         torsoTimer;     // don't change low priority animations until this runs out
+    int         torsoAnim;      // mask off ANIM_TOGGLEBIT
 
-	int			movementDir;	// a number 0 to 7 that represents the reletive angle
-								// of movement to the view angle (axial and diagonals)
-								// when at rest, the value will remain unchanged
-								// used to twist the legs during strafing
+    int         movementDir;    // a number 0 to 7 that represents the reletive angle
+                                // of movement to the view angle (axial and diagonals)
+                                // when at rest, the value will remain unchanged
+                                // used to twist the legs during strafing
 
-	vec3_t		grapplePoint;	// location of grapple to pull towards if PMF_GRAPPLE_PULL
+    vec3_t      grapplePoint;   // location of grapple to pull towards if PMF_GRAPPLE_PULL
 
-	int			eFlags;			// copied to entityState_t->eFlags
+    int         eFlags;         // copied to entityState_t->eFlags
 
-	int			eventSequence;	// pmove generated events
-	int			events[MAX_PS_EVENTS];
-	int			eventParms[MAX_PS_EVENTS];
+    int         eventSequence;  // pmove generated events
+    int         events[MAX_PS_EVENTS];
+    int         eventParms[MAX_PS_EVENTS];
 
-	int			externalEvent;	// events set on player from another source
-	int			externalEventParm;
-	int			externalEventTime;
+    int         externalEvent;  // events set on player from another source
+    int         externalEventParm;
+    int         externalEventTime;
 
-	int			clientNum;		// ranges from 0 to MAX_CLIENTS-1
-	int			weapon;			// copied to entityState_t->weapon
-	int			weaponstate;
+    int         clientNum;      // ranges from 0 to MAX_CLIENTS-1
+    int         weapon;         // copied to entityState_t->weapon
+    int         weaponstate;
 
-	vec3_t		viewangles;		// for fixed views
-	int			viewheight;
+    vec3_t      viewangles;     // for fixed views
+    int         viewheight;
 
-	// damage feedback
-	int			damageEvent;	// when it changes, latch the other parms
-	int			damageYaw;
-	int			damagePitch;
-	int			damageCount;
+    // damage feedback
+    int         damageEvent;    // when it changes, latch the other parms
+    int         damageYaw;
+    int         damagePitch;
+    int         damageCount;
 
-	int			stats[MAX_STATS];
-	int			persistant[MAX_PERSISTANT];	// stats that aren't cleared on death
-	int			misc[MAX_MISC];	// misc data
-	int			ammo;			// ammo held
-	int			clips;			// clips held
+    int         stats[MAX_STATS];
+    int         persistant[MAX_PERSISTANT]; // stats that aren't cleared on death
+    int         misc[MAX_MISC]; // level.time that the powerup runs out
+    int         ammo[MAX_WEAPONS];
 
-	int			generic1;
-	int			loopSound;
-	int			otherEntityNum;
+    int         generic1;
+    int         loopSound;
+    int         otherEntityNum;
 
-	// not communicated over the net at all
-	int			ping;			// server to game info for scoreboard
-	int			pmove_framecount;	// FIXME: don't transmit over the network
-	int			jumppad_frame;
-	int			entityEventSequence;
+    // not communicated over the net at all
+    int         ping;           // server to game info for scoreboard
+    int         pmove_framecount;   // FIXME: don't transmit over the network
+    int         jumppad_frame;
+    int         entityEventSequence;
 } playerState_t;
 
 
@@ -1107,58 +1106,58 @@
 // usercmd_t->button bits, many of which are generated by the client system,
 // so they aren't game/cgame only definitions
 //
-#define	BUTTON_ATTACK		1
-#define	BUTTON_TALK			2			// displays talk balloon and disables actions
-#define	BUTTON_USE_HOLDABLE	4
-#define	BUTTON_GESTURE		8
-#define	BUTTON_WALKING		16			// walking can't just be infered from MOVE_RUN
-										// because a key pressed late in the frame will
-										// only generate a small move value for that frame
-										// walking will use different animations and
-										// won't generate footsteps
-#define BUTTON_ATTACK2	32
-#define	BUTTON_NEGATIVE		64
+#define BUTTON_ATTACK       1
+#define BUTTON_TALK         2           // displays talk balloon and disables actions
+#define BUTTON_USE_HOLDABLE 4
+#define BUTTON_GESTURE      8
+#define BUTTON_WALKING      16          // walking can't just be infered from MOVE_RUN
+                                        // because a key pressed late in the frame will
+                                        // only generate a small move value for that frame
+                                        // walking will use different animations and
+                                        // won't generate footsteps
+#define BUTTON_ATTACK2  32
+#define BUTTON_NEGATIVE     64
 
-#define BUTTON_GETFLAG		128
-#define BUTTON_GUARDBASE	256
-#define BUTTON_PATROL		512
-#define BUTTON_FOLLOWME		1024
+#define BUTTON_GETFLAG      128
+#define BUTTON_GUARDBASE    256
+#define BUTTON_PATROL       512
+#define BUTTON_FOLLOWME     1024
 
-#define	BUTTON_ANY			2048			// any key whatsoever
+#define BUTTON_ANY          2048            // any key whatsoever
 
-#define	MOVE_RUN			120			// if forwardmove or rightmove are >= MOVE_RUN,
-										// then BUTTON_WALKING should be set
+#define MOVE_RUN            120         // if forwardmove or rightmove are >= MOVE_RUN,
+                                        // then BUTTON_WALKING should be set
 
 // usercmd_t is sent to the server each client frame
 typedef struct usercmd_s {
-	int				serverTime;
-	int				angles[3];
-	int 			buttons;
-	byte			weapon;           // weapon 
-	signed char	forwardmove, rightmove, upmove;
+    int             serverTime;
+    int             angles[3];
+    int             buttons;
+    byte            weapon;           // weapon
+    signed char forwardmove, rightmove, upmove;
 } usercmd_t;
 
 //===================================================================
 
 // if entityState->solid == SOLID_BMODEL, modelindex is an inline model number
-#define	SOLID_BMODEL	0xffffff
+#define SOLID_BMODEL    0xffffff
 
 typedef enum {
-	TR_STATIONARY,
-	TR_INTERPOLATE,				// non-parametric, but interpolate between snapshots
-	TR_LINEAR,
-	TR_LINEAR_STOP,
-	TR_SINE,					// value = base + sin( time / duration ) * delta
-	TR_GRAVITY,
-	TR_BUOYANCY
+    TR_STATIONARY,
+    TR_INTERPOLATE,             // non-parametric, but interpolate between snapshots
+    TR_LINEAR,
+    TR_LINEAR_STOP,
+    TR_SINE,                    // value = base + sin( time / duration ) * delta
+    TR_GRAVITY,
+    TR_BUOYANCY
 } trType_t;
 
 typedef struct {
-	trType_t	trType;
-	int		trTime;
-	int		trDuration;			// if non 0, trTime + trDuration = stop time
-	vec3_t	trBase;
-	vec3_t	trDelta;			// velocity, etc
+    trType_t    trType;
+    int     trTime;
+    int     trDuration;         // if non 0, trTime + trDuration = stop time
+    vec3_t  trBase;
+    vec3_t  trDelta;            // velocity, etc
 } trajectory_t;
 
 // entityState_t is the information conveyed from the server
@@ -1169,63 +1168,63 @@
 // the structure size is fairly large
 
 typedef struct entityState_s {
-	int		number;			// entity index
-	int		eType;			// entityType_t
-	int		eFlags;
+    int     number;         // entity index
+    int     eType;          // entityType_t
+    int     eFlags;
 
-	trajectory_t	pos;	// for calculating position
-	trajectory_t	apos;	// for calculating angles
+    trajectory_t    pos;    // for calculating position
+    trajectory_t    apos;   // for calculating angles
 
-	int		time;
-	int		time2;
+    int     time;
+    int     time2;
 
-	vec3_t	origin;
-	vec3_t	origin2;
+    vec3_t  origin;
+    vec3_t  origin2;
 
-	vec3_t	angles;
-	vec3_t	angles2;
+    vec3_t  angles;
+    vec3_t  angles2;
 
-	int		otherEntityNum;	// shotgun sources, etc
-	int		otherEntityNum2;
+    int     otherEntityNum; // shotgun sources, etc
+    int     otherEntityNum2;
 
-	int		groundEntityNum;	// -1 = in air
+    int     groundEntityNum;    // -1 = in air
 
-	int		constantLight;	// r + (g<<8) + (b<<16) + (intensity<<24)
-	int		loopSound;		// constantly loop this sound
+    int     constantLight;  // r + (g<<8) + (b<<16) + (intensity<<24)
+    int     loopSound;      // constantly loop this sound
 
-	int		modelindex;
-	int		modelindex2;
-	int		clientNum;		// 0 to (MAX_CLIENTS - 1), for players and corpses
-	int		frame;
+    int     modelindex;
+    int     modelindex2;
+    int     clientNum;      // 0 to (MAX_CLIENTS - 1), for players and corpses
+    int     frame;
 
-	int		solid;			// for client side prediction, trap_linkentity sets this properly
+    int     solid;          // for client side prediction, trap_linkentity sets this properly
 
-	int		event;			// impulse events -- muzzle flashes, footsteps, etc
-	int		eventParm;
+    int     event;          // impulse events -- muzzle flashes, footsteps, etc
+    int     eventParm;
 
-	// for players
-	int		misc;			// bit flags
-	int		weapon;			// determines weapon and flash model, etc
-	int		legsAnim;		// mask off ANIM_TOGGLEBIT
-	int		torsoAnim;		// mask off ANIM_TOGGLEBIT
+    // for players
+    int     misc;           // bit flags
+    int     weapon;         // determines weapon and flash model, etc
+    int     legsAnim;       // mask off ANIM_TOGGLEBIT
+    int     torsoAnim;      // mask off ANIM_TOGGLEBIT
 
-	int		generic1;
+    int     generic1;
 } entityState_t;
 
 typedef enum {
-	CA_UNINITIALIZED,
-	CA_DISCONNECTED, 	// not talking to a server
-	CA_AUTHORIZING,		// not used any more, was checking cd key 
-	CA_CONNECTING,		// sending request packets to the server
-	CA_CHALLENGING,		// sending challenge packets to the server
-	CA_CONNECTED,		// netchan_t established, getting gamestate
-	CA_LOADING,			// only during cgame initialization, never during main loop
-	CA_PRIMED,			// got gamestate, waiting for first frame
-	CA_ACTIVE,			// game views should be displayed
-	CA_CINEMATIC		// playing a cinematic or a static pic, not connected to a server
+    CA_UNINITIALIZED,
+    CA_DISCONNECTED,    // not talking to a server
+    CA_AUTHORIZING,     // not used any more, was checking cd key
+    CA_CONNECTING,      // sending request packets to the server
+    CA_CHALLENGING,     // sending challenge packets to the server
+    CA_CONNECTED,       // netchan_t established, getting gamestate
+    CA_LOADING,         // only during cgame initialization, never during main loop
+    CA_PRIMED,          // got gamestate, waiting for first frame
+    CA_ACTIVE,          // game views should be displayed
+    CA_CINEMATIC        // playing a cinematic or a static pic, not connected to a server
 } connstate_t;
 
-// font support 
+// font support
 
 #define GLYPH_START 0
 #define GLYPH_END 255
@@ -1261,62 +1260,65 @@
 
 
 typedef struct qtime_s {
-	int tm_sec;     /* seconds after the minute - [0,59] */
-	int tm_min;     /* minutes after the hour - [0,59] */
-	int tm_hour;    /* hours since midnight - [0,23] */
-	int tm_mday;    /* day of the month - [1,31] */
-	int tm_mon;     /* months since January - [0,11] */
-	int tm_year;    /* years since 1900 */
-	int tm_wday;    /* days since Sunday - [0,6] */
-	int tm_yday;    /* days since January 1 - [0,365] */
-	int tm_isdst;   /* daylight savings time flag */
+    int tm_sec;     /* seconds after the minute - [0,59] */
+    int tm_min;     /* minutes after the hour - [0,59] */
+    int tm_hour;    /* hours since midnight - [0,23] */
+    int tm_mday;    /* day of the month - [1,31] */
+    int tm_mon;     /* months since January - [0,11] */
+    int tm_year;    /* years since 1900 */
+    int tm_wday;    /* days since Sunday - [0,6] */
+    int tm_yday;    /* days since January 1 - [0,365] */
+    int tm_isdst;   /* daylight savings time flag */
 } qtime_t;
 
 
 // server browser sources
 // AS_MPLAYER is no longer used
-#define AS_GLOBAL			0
-#define AS_MPLAYER		1
-#define AS_LOCAL			2
-#define AS_FAVORITES	3
+#define AS_GLOBAL           0
+#define AS_MPLAYER      1
+#define AS_LOCAL            2
+#define AS_FAVORITES    3
 
 
 // cinematic states
 typedef enum {
-	FMV_IDLE,
-	FMV_PLAY,		// play
-	FMV_EOF,		// all other conditions, i.e. stop/EOF/abort
-	FMV_ID_BLT,
-	FMV_ID_IDLE,
-	FMV_LOOPED,
-	FMV_ID_WAIT
+    FMV_IDLE,
+    FMV_PLAY,       // play
+    FMV_EOF,        // all other conditions, i.e. stop/EOF/abort
+    FMV_ID_BLT,
+    FMV_ID_IDLE,
+    FMV_LOOPED,
+    FMV_ID_WAIT
 } e_status;
 
 typedef enum _flag_status {
-	FLAG_ATBASE = 0,
-	FLAG_TAKEN,			// CTF
-	FLAG_TAKEN_RED,		// One Flag CTF
-	FLAG_TAKEN_BLUE,	// One Flag CTF
-	FLAG_DROPPED
+    FLAG_ATBASE = 0,
+    FLAG_TAKEN,         // CTF
+    FLAG_TAKEN_RED,     // One Flag CTF
+    FLAG_TAKEN_BLUE,    // One Flag CTF
+    FLAG_DROPPED
 } flagStatus_t;
 
 typedef enum {
-	DS_NONE,
+    DS_NONE,
 
-	DS_PLAYBACK,
-	DS_RECORDING,
+    DS_PLAYBACK,
+    DS_RECORDING,
 
-	DS_NUM_DEMO_STATES
+    DS_NUM_DEMO_STATES
 } demoState_t;
 
 
-#define	MAX_GLOBAL_SERVERS				4096
-#define	MAX_OTHER_SERVERS					128
-#define MAX_PINGREQUESTS					32
-#define MAX_SERVERSTATUSREQUESTS	16
+#define MAX_GLOBAL_SERVERS              4096
+#define MAX_OTHER_SERVERS                   128
+#define MAX_PINGREQUESTS                    32
+#define MAX_SERVERSTATUSREQUESTS    16
 
-#define SAY_ALL		0
-#define SAY_TEAM	1
-#define SAY_TELL	2
+#define SAY_ALL     0
+#define SAY_TEAM    1
+#define SAY_TELL    2
+#define SAY_ACTION      3
+#define SAY_ACTION_T    4
+#define SAY_ADMINS    5
 
-#endif	// __Q_SHARED_H
+#endif  // __Q_SHARED_H
Index: src/qcommon/qcommon.h
===================================================================
--- src/qcommon/qcommon.h	(revision 1055)
+++ src/qcommon/qcommon.h	(working copy)
@@ -221,7 +221,7 @@
 ==============================================================
 */
 
-#define	PROTOCOL_VERSION	70
+#define	PROTOCOL_VERSION	69
 
 // maintain a list of compatible protocols for demo playing
 // NOTE: that stuff only works with two digits protocols
Index: src/qcommon/msg.c
===================================================================
--- src/qcommon/msg.c	(revision 1055)
+++ src/qcommon/msg.c	(working copy)
@@ -827,7 +827,7 @@
 { NETF(modelindex), 8 },
 { NETF(otherEntityNum2), GENTITYNUM_BITS },
 { NETF(loopSound), 8 },
-{ NETF(generic1), 16 },
+{ NETF(generic1), 8 },
 { NETF(origin2[2]), 0 },
 { NETF(origin2[0]), 0 },
 { NETF(origin2[1]), 0 },
@@ -1143,9 +1143,7 @@
 { PSF(damageYaw), 8 },
 { PSF(damagePitch), 8 },
 { PSF(damageCount), 8 },
-{ PSF(ammo), 12 },
-{ PSF(clips), 4 },
-{ PSF(generic1), 16 },
+{ PSF(generic1), 8 },
 { PSF(pm_type), 8 },					
 { PSF(delta_angles[0]), 16 },
 { PSF(delta_angles[2]), 16 },
@@ -1173,6 +1171,7 @@
 	playerState_t	dummy;
 	int				statsbits;
 	int				persistantbits;
+	int				ammobits;
 	int				miscbits;
 	int				numFields;
 	int				c;
@@ -1253,6 +1252,12 @@
 			persistantbits |= 1<<i;
 		}
 	}
+	ammobits = 0;
+	for (i=0 ; i<MAX_WEAPONS ; i++) {
+		if (to->ammo[i] != from->ammo[i]) {
+			ammobits |= 1<<i;
+		}
+	}
 	miscbits = 0;
 	for (i=0 ; i<MAX_MISC ; i++) {
 		if (to->misc[i] != from->misc[i]) {
@@ -1260,7 +1265,7 @@
 		}
 	}
 
-	if (!statsbits && !persistantbits && !miscbits) {
+	if (!statsbits && !persistantbits && !ammobits && !miscbits) {
 		MSG_WriteBits( msg, 0, 1 );	// no change
 		oldsize += 4;
 		return;
@@ -1289,6 +1294,17 @@
 	}
 
 
+	if ( ammobits ) {
+		MSG_WriteBits( msg, 1, 1 );	// changed
+		MSG_WriteBits( msg, ammobits, MAX_WEAPONS );
+		for (i=0 ; i<MAX_WEAPONS ; i++)
+			if (ammobits & (1<<i) )
+				MSG_WriteShort (msg, to->ammo[i]);
+	} else {
+		MSG_WriteBits( msg, 0, 1 );	// no change
+	}
+
+
 	if ( miscbits ) {
 		MSG_WriteBits( msg, 1, 1 );	// changed
 		MSG_WriteBits( msg, miscbits, MAX_MISC );
@@ -1408,8 +1424,19 @@
 			}
 		}
 
-		// parse misc data
+		// parse ammo
 		if ( MSG_ReadBits( msg, 1 ) ) {
+			LOG("PS_AMMO");
+			bits = MSG_ReadBits (msg, MAX_WEAPONS);
+			for (i=0 ; i<MAX_WEAPONS ; i++) {
+				if (bits & (1<<i) ) {
+					to->ammo[i] = MSG_ReadShort(msg);
+				}
+			}
+		}
+
+		// parse misc
+		if ( MSG_ReadBits( msg, 1 ) ) {
 			LOG("PS_MISC");
 			bits = MSG_ReadBits (msg, MAX_MISC);
 			for (i=0 ; i<MAX_MISC ; i++) {
Index: src/qcommon/common.c
===================================================================
--- src/qcommon/common.c	(revision 1055)
+++ src/qcommon/common.c	(working copy)
@@ -33,7 +33,7 @@
 #endif
 
 int demo_protocols[] =
-{ PROTOCOL_VERSION, 0 };
+{ 66, 67, 68, 69, 0 };
 
 #define MAX_NUM_ARGVS	50
 
Index: src/game/g_spawn.c
===================================================================
--- src/game/g_spawn.c	(revision 1055)
+++ src/game/g_spawn.c	(working copy)
@@ -336,7 +336,7 @@
       AngleNormalize360( ent->s.angles[ YAW ] );
     }
 
-    G_SpawnBuildable( ent, buildable );
+    G_SpawnBuildable( ent, buildable, 0, 0, 0.0f );
     return qtrue;
   }
 
@@ -661,20 +661,8 @@
   g_entities[ ENTITYNUM_WORLD ].s.number = ENTITYNUM_WORLD;
   g_entities[ ENTITYNUM_WORLD ].classname = "worldspawn";
 
-  // see if we want a warmup time
-  trap_SetConfigstring( CS_WARMUP, "" );
   if( g_restarted.integer )
-  {
     trap_Cvar_Set( "g_restarted", "0" );
-    level.warmupTime = 0;
-  }
-  else if( g_doWarmup.integer )
-  {
-    // Turn it on
-    level.warmupTime = -1;
-    trap_SetConfigstring( CS_WARMUP, va( "%i", level.warmupTime ) );
-    G_LogPrintf( "Warmup:\n" );
-  }
 
 }
 
Index: src/game/bg_misc.c
===================================================================
--- src/game/bg_misc.c	(revision 1055)
+++ src/game/bg_misc.c	(working copy)
@@ -71,7 +71,8 @@
     ASPAWN_CREEPSIZE,      //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qfalse,                //qboolean  replacable;
   },
   {
     BA_A_BARRICADE,        //int       buildNum;
@@ -109,7 +110,8 @@
     BARRICADE_CREEPSIZE,   //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qfalse,                //qboolean  replaceable;
   },
   {
     BA_A_BOOSTER,          //int       buildNum;
@@ -150,7 +152,8 @@
     BOOSTER_CREEPSIZE,     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qtrue,                 //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qtrue,                 //qboolean  replacable;
   },
   {
     BA_A_ACIDTUBE,         //int       buildNum;
@@ -189,7 +192,8 @@
     ACIDTUBE_CREEPSIZE,    //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qfalse,                //qboolean  replacable;
   },
   {
     BA_A_HIVE,             //int       buildNum;
@@ -227,7 +231,8 @@
     HIVE_CREEPSIZE,        //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qfalse,                //qboolean  replacable;
   },
   {
     BA_A_TRAPPER,          //int       buildNum;
@@ -266,7 +271,8 @@
     TRAPPER_CREEPSIZE,     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qtrue,                 //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                 //qboolean  reactorTest;
+    qfalse,                //qboolean  replacable;
   },
   {
     BA_A_OVERMIND,         //int       buildNum;
@@ -305,7 +311,8 @@
     OVERMIND_CREEPSIZE,    //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qtrue                  //qboolean  reactorTest;
+    qtrue,                 //qboolean  reactorTest;
+    qtrue,                 //qboolean  replacable;
   },
   {
     BA_A_HOVEL,            //int       buildNum;
@@ -344,7 +351,8 @@
     HOVEL_CREEPSIZE,       //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qtrue                  //qboolean  reactorTest;
+    qtrue,                 //qboolean  reactorTest;
+    qfalse,                //qboolean  replacable;
   },
   {
     BA_H_SPAWN,            //int       buildNum;
@@ -373,7 +381,7 @@
     BANIM_IDLE1,           //int       idleAnim;
     100,                   //int       nextthink;
     HSPAWN_BT,             //int       buildTime;
-    qfalse,                //qboolean  usable;
+    qtrue,                //qboolean  usable;
     0,                     //int       turretRange;
     0,                     //int       turretFireSpeed;
     WP_NONE,               //weapon_t  turretProjType;
@@ -383,7 +391,8 @@
     0,                     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qtrue,                 //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qfalse,                //qboolean  replacable;
   },
   {
     BA_H_MEDISTAT,         //int       buildNum;
@@ -422,7 +431,8 @@
     0,                     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qtrue,                 //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qtrue,                 //qboolean  replacable;
   },
   {
     BA_H_MGTURRET,         //int       buildNum;
@@ -463,7 +473,8 @@
     0,                     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qtrue,                 //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                 //qboolean  reactorTest;
+    qfalse,                //qboolean  replacable;
   },
   {
     BA_H_TESLAGEN,         //int       buildNum;
@@ -502,7 +513,8 @@
     0,                     //int       creepSize;
     qtrue,                 //qboolean  dccTest;
     qtrue,                 //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qfalse,                //qboolean  replacable;
   },
   {
     BA_H_DCC,              //int       buildNum;
@@ -541,7 +553,8 @@
     0,                     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qtrue,                 //qboolean  replacable;
   },
   {
     BA_H_ARMOURY,          //int       buildNum;
@@ -580,7 +593,8 @@
     0,                     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qtrue,                 //qboolean  replacable;
   },
   {
     BA_H_REACTOR,          //int       buildNum;
@@ -619,7 +633,8 @@
     0,                     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qtrue                  //qboolean  reactorTest;
+    qtrue,                 //qboolean  reactorTest;
+    qtrue,                 //qboolean  replacable;
   },
   {
     BA_H_REPEATER,         //int       buildNum;
@@ -658,7 +673,8 @@
     0,                     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qtrue,                 //qboolean  replacable;
   }
 };
 
@@ -1373,6 +1389,25 @@
 
 /*
 ==============
+BG_FindReplaceableTestForBuildable
+==============
+*/
+qboolean BG_FindReplaceableTestForBuildable( int bclass )
+{
+  int i;
+
+  for( i = 0; i < bg_numBuildables; i++ )
+  {
+    if( bg_buildableList[ i ].buildNum == bclass )
+    {
+      return bg_buildableList[ i ].replaceable;
+    }
+  }
+  return qfalse;
+}
+
+/*
+==============
 BG_FindOverrideForBuildable
 ==============
 */
@@ -1397,7 +1432,7 @@
       return bg_buildableList[ i ].transparentTest;
     }
   }
-  return qfalse; 
+  return qfalse;
 }
 
 /*
@@ -2435,7 +2470,7 @@
       break;
     }
   }
-  
+
   if( bg_classOverrideList[ pclass ].viewheight != 0 )
     vh = bg_classOverrideList[ pclass ].viewheight;
   if( bg_classOverrideList[ pclass ].crouchViewheight != 0 )
@@ -3440,8 +3475,10 @@
     GRENADE_K_SCALE,      //float     knockbackScale;
     qfalse,               //qboolean  hasAltMode;
     qfalse,               //qboolean  hasThirdMode;
-    qfalse,               //qboolean  canZoom;
-    90.0f,                //float     zoomFov;
+//    qfalse,               //qboolean  canZoom;
+    qtrue,               //qboolean  canZoom;
+//    90.0f,                //float     zoomFov;
+    20.0f,                //float     zoomFov;
     qfalse,               //qboolean  purchasable;
     qfalse,               //qboolean  longRanged;
     0,                    //int       buildDelay;
@@ -5126,16 +5163,62 @@
 
 /*
 ========================
+BG_UnpackAmmoArray
+
+Extract the ammo quantity from the array
+========================
+*/
+void BG_UnpackAmmoArray( int weapon, int psAmmo[ ], int psAmmo2[ ], int *ammo, int *clips )
+{
+  int   ammoarray[ 32 ];
+  int   i;
+
+  for( i = 0; i <= 15; i++ )
+    ammoarray[ i ] = psAmmo[ i ];
+
+  for( i = 16; i <= 31; i++ )
+    ammoarray[ i ] = psAmmo2[ i - 16 ];
+
+  if( ammo != NULL )
+    *ammo = ammoarray[ weapon ] & 0x0FFF;
+
+  if( clips != NULL )
+    *clips = ( ammoarray[ weapon ] >> 12 ) & 0x0F;
+}
+
+/*
+========================
+BG_PackAmmoArray
+
+Pack the ammo quantity into the array
+========================
+*/
+void BG_PackAmmoArray( int weapon, int psAmmo[ ], int psAmmo2[ ], int ammo, int clips )
+{
+  int   weaponvalue;
+
+  weaponvalue = ammo | ( clips << 12 );
+
+  if( weapon <= 15 )
+    psAmmo[ weapon ] = weaponvalue;
+  else if( weapon >= 16 )
+    psAmmo2[ weapon - 16 ] = weaponvalue;
+}
+
+/*
+========================
 BG_WeaponIsFull
 
 Check if a weapon has full ammo
 ========================
 */
-qboolean BG_WeaponIsFull( weapon_t weapon, int stats[ ], int ammo, int clips )
+qboolean BG_WeaponIsFull( weapon_t weapon, int stats[ ], int psAmmo[ ], int psAmmo2[ ] )
 {
   int maxAmmo, maxClips;
+  int ammo, clips;
 
   BG_FindAmmoForWeapon( weapon, &maxAmmo, &maxClips );
+  BG_UnpackAmmoArray( weapon, psAmmo, psAmmo2, &ammo, &clips );
 
   if( BG_InventoryContainsUpgrade( UP_BATTPACK, stats ) )
     maxAmmo = (int)( (float)maxAmmo * BATTPACK_MODIFIER );
@@ -5391,7 +5474,7 @@
   VectorMA( targetOrigin, -128, playerNormal, targetOrigin );
 
   // The mask is MASK_DEADSOLID on purpose to avoid collisions with other entities
-  (*trace)( tr, entityOrigin, mins, maxs, targetOrigin, ps->clientNum, MASK_DEADSOLID );
+  (*trace)( tr, entityOrigin, mins, maxs, targetOrigin, ps->clientNum, MASK_PLAYERSOLID );
   VectorCopy( tr->endpos, entityOrigin );
   VectorMA( entityOrigin, 0.1f, playerNormal, outOrigin );
   vectoangles( forward, outAngles );
@@ -5399,15 +5482,13 @@
 
 /*
 ===============
-BG_GetValueOfHuman
+BG_GetValueOfEquipment
 
-Returns the kills value of some human player
+Returns the equipment value of some human player's gear
 ===============
 */
-int BG_GetValueOfHuman( playerState_t *ps )
-{
-  int     i, worth = 0;
-  float   portion;
+  int BG_GetValueOfEquipment( playerState_t *ps ) {
+  int i, worth = 0;
 
   for( i = UP_NONE + 1; i < UP_NUM_UPGRADES; i++ )
   {
@@ -5421,8 +5502,20 @@
       worth += BG_FindPriceForWeapon( i );
   }
 
-  portion = worth / (float)HUMAN_MAXED;
+    return worth;
+  }
+/*
+===============
+BG_GetValueOfHuman
 
+Returns the kills value of some human player
+===============
+*/
+int BG_GetValueOfHuman( playerState_t *ps )
+{
+  float portion = BG_GetValueOfEquipment( ps ) / (float)HUMAN_MAXED;
+
+
   if( portion < 0.01f )
     portion = 0.01f;
   else if( portion > 1.0f )
@@ -5787,9 +5880,9 @@
   if( clientNum < 0 || clientNum >= MAX_CLIENTS || !list )
     return qfalse;
   if( clientNum < 32 )
-    return ( ( list->lo & ( 1 << clientNum ) ) != 0 ); 
+    return ( ( list->lo & ( 1 << clientNum ) ) != 0 );
   else
-    return ( ( list->hi & ( 1 << ( clientNum - 32 ) ) ) != 0 ); 
+    return ( ( list->hi & ( 1 << ( clientNum - 32 ) ) ) != 0 );
 }
 
 /*
@@ -5802,7 +5895,7 @@
   if( clientNum < 0 || clientNum >= MAX_CLIENTS || !list )
     return;
   if( clientNum < 32 )
-    list->lo |= ( 1 << clientNum ); 
+    list->lo |= ( 1 << clientNum );
   else
     list->hi |= ( 1 << ( clientNum - 32 ) );
 }
@@ -5817,7 +5910,7 @@
   if( clientNum < 0 || clientNum >= MAX_CLIENTS || !list )
     return;
   if( clientNum < 32 )
-    list->lo &= ~( 1 << clientNum ); 
+    list->lo &= ~( 1 << clientNum );
   else
     list->hi &= ~( 1 << ( clientNum - 32 ) );
 }
Index: src/game/tremulous.h
===================================================================
--- src/game/tremulous.h	(revision 1055)
+++ src/game/tremulous.h	(working copy)
@@ -20,8 +20,6 @@
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 ===========================================================================
 */
-
-
 /*
  * ALIEN weapons
  *
@@ -320,8 +318,8 @@
 
 #define ALIENSENSE_RANGE            1000.0f
 
-#define ALIEN_POISON_TIME           10000
-#define ALIEN_POISON_DMG            30
+#define ALIEN_POISON_TIME           5000
+#define ALIEN_POISON_DMG            5
 #define ALIEN_POISON_DIVIDER        (1.0f/1.32f) //about 1.0/(time`th root of damage)
 
 #define ALIEN_SPAWN_REPEAT_TIME     10000
@@ -452,9 +450,11 @@
  */
 
 #define LIGHTARMOUR_PRICE           70
+#define LIGHTARMOUR_POISON_PROTECTION 1
 
 #define HELMET_PRICE                90
 #define HELMET_RANGE                1000.0f
+#define HELMET_POISON_PROTECTION    2
 
 #define MEDKIT_PRICE                0
 
@@ -468,6 +468,7 @@
 #define JETPACK_DISABLE_CHANCE      0.3f
 
 #define BSUIT_PRICE                 400
+#define BSUIT_POISON_PROTECTION     4
 
 #define MGCLIP_PRICE                0
 
@@ -475,7 +476,7 @@
 
 #define GAS_PRICE                   0
 
-#define MEDKIT_POISON_IMMUNITY_TIME 30000
+#define MEDKIT_POISON_IMMUNITY_TIME 0
 #define MEDKIT_STARTUP_TIME         4000
 #define MEDKIT_STARTUP_SPEED        5
 
@@ -508,6 +509,12 @@
 #define HSPAWN_SPLASHRADIUS         100
 #define HSPAWN_VALUE                1
 
+#define HTELE_BP                    8
+#define HTELE_BT                    7500
+#define HTELE_HEALTH                HBHM(60)
+#define HTELE_SPLASHDAMAGE          250
+#define HTELE_SPLASHRADIUS          100
+
 #define MEDISTAT_BP                 8
 #define MEDISTAT_BT                 10000
 #define MEDISTAT_HEALTH             HBHM(190)
@@ -604,14 +611,27 @@
 #define FREEKILL_ALIEN              1
 #define FREEKILL_HUMAN              LEVEL0_VALUE
 
-#define DEFAULT_ALIEN_BUILDPOINTS   "100"
+#define DEFAULT_ALIEN_BUILDPOINTS   "140"
 #define DEFAULT_ALIEN_STAGE2_THRESH "20"
 #define DEFAULT_ALIEN_STAGE3_THRESH "40"
 #define DEFAULT_ALIEN_MAX_STAGE     "2"
-#define DEFAULT_HUMAN_BUILDPOINTS   "100"
+#define DEFAULT_HUMAN_BUILDPOINTS   "140"
 #define DEFAULT_HUMAN_STAGE2_THRESH "20"
 #define DEFAULT_HUMAN_STAGE3_THRESH "40"
 #define DEFAULT_HUMAN_MAX_STAGE     "2"
 
+#define DEFAULT_ALLOW_ADMIN_CHEATS  "0"
+
 #define DAMAGE_FRACTION_FOR_KILL    0.5f //how much damage players (versus structures) need to
                                          //do to increment the stage kill counters
+
+// g_suddenDeathMode settings
+#define SDMODE_BP                   0
+#define SDMODE_NO_BUILD             1
+#define SDMODE_SELECTIVE            2
+
+// oc data
+#define RESTARTOC_CHECKPOINT_OK    3000
+#define OC_MEDICANNOTUSEMESSAGE "Cannot collect bonuses using\na jetpack"
+#define OC_TIMELATENCY_EVOLVEBLOCK 2000
+#define OC_BUILDABLE_THINK_OFFSET 4000  // save at least a little processing power for DC's and arms
Index: src/game/g_svcmds.c
===================================================================
--- src/game/g_svcmds.c	(revision 1055)
+++ src/game/g_svcmds.c	(working copy)
@@ -502,7 +502,7 @@
   {
     if( ( *s >= '0' && *s <= '9' ) ||
       ( *s >= 'a' && *s <= 'z' ) ||
-      ( *s >= 'A' && *s <= 'Z' ) || *s == '-' || *s == '_' )
+      ( *s >= 'A' && *s <= 'Z' ) || *s == '-' || *s == '_' || *s == '^' )
     {
       str2[ i++ ] = *s;
       str2[ i ] = '\0';
@@ -539,7 +539,7 @@
 
   s = ConcatArgs( 1 );
   Q_strncpyz( layouts, s, sizeof( layouts ) );
-  trap_Cvar_Set( "g_layouts", layouts ); 
+  trap_Cvar_Set( "g_layouts", layouts );
   trap_SendConsoleCommand( EXEC_APPEND, "map_restart\n" );
   level.restarted = qtrue;
 }
@@ -573,7 +573,7 @@
   else
   {
     G_Printf("admitdefeat: invalid team\n");
-  } 
+  }
 }
 
 /*
@@ -681,13 +681,13 @@
     Svcmd_LayoutSave_f( );
     return qtrue;
   }
-  
+
   if( !Q_stricmp( cmd, "layoutload" ) )
   {
     Svcmd_LayoutLoad_f( );
     return qtrue;
   }
-  
+
   if( !Q_stricmp( cmd, "admitdefeat" ) )
   {
     Svcmd_AdmitDefeat_f( );
@@ -702,7 +702,7 @@
     LogExit( "Evacuation." );
     return qtrue;
   }
-  
+
   // see if this is a a admin command
   if( G_admin_cmd_check( NULL, qfalse ) )
     return qtrue;
@@ -731,6 +731,11 @@
       G_PrivateMessage( NULL );
       return qtrue;
     }
+    else if( !Q_stricmp( cmd, "a" ) || !Q_stricmp( cmd, "say_admins" ))
+    {
+      G_Say( NULL, NULL, SAY_ADMINS, ConcatArgs( 1 )  );
+      return qtrue;
+    }
 
     G_Printf( "unknown command: %s\n", cmd );
     return qtrue;
Index: src/game/g_local.h
===================================================================
--- src/game/g_local.h	(revision 1055)
+++ src/game/g_local.h	(working copy)
@@ -34,8 +34,52 @@
 
 //==================================================================
 
+#define MSEC(t) ( ( t ) - ( ( ( t ) / 1000 ) * 1000 ) )
+#define SECS(t) ( ( ( t ) - ( ( ( t ) / 60000 ) * 60000 ) ) / 1000 )
+#define MINS(t) ( ( t ) / 60000 )
+
+#define SUFN(x) ( ( ( x ) < 11 && ( x ) > 13 ) ? ( ( ( x ) % 10 == 1 ) ? ( "st" ) : ( ( ( x ) % 10 == 2 ) ? ( "nd" ) : ( ( ( x ) % 10 == 3 ) ? ( "rd" ) : ( "th" ) ) ) ) : ( "th" ) )
+
+#define EXCOLOR(s) \
+{ \
+    int i; \
+ \
+    for(i = 0; i < sizeof((s)); i++) \
+    { \
+        if(((s)[i]) == '^' && i + 3 < sizeof((s))) \
+        { \
+            memmove( (&(s)[i]) + 2, (&(s)[i]), strlen((s)) + 1); \
+            (s)[++i] = '^'; \
+            (s)[++i] = '7'; \
+        } \
+    } \
+}
+
+//==================================================================
+
 #define INFINITE      1000000
 
+#define MAX_SPAWNGROUP 2048
+/*
+ * We can either load insanely long by reading the file MAX_SPAWNGROUP times,
+ * or read it a few times and put it in fragmented tables.  The problem
+ * with fragmented tables is that spawn groups may not spawn in the right order.
+ * Each table is loaded in order, but each table is loaded in order as well.
+ * This rare issue is only ever a problem when a structure is built over
+ * (over, so it relies on another structure's spawnGroup) and the two (or
+ * multiple) structures are in different tables, and the wrong table comes
+ * first.  Fortunately, layout editors usually build in groups so any structures
+ * which depend on each other are usually in the same table.  It is also even
+ * rarer because the layout developer usually builds the second one second, and
+ * the third one third, and since the layout is usually saved in order
+ * the order of the tables is usually correct (note that this isn't always
+ * the case, especially if the developer deconstructs a lot of structures).
+*/
+#define MAX_LAYOUT_BUILDABLES 4096
+// TODO: keep G_Alloc from crashing server when (and only when) trying different memory sizes it can't handle.
+// until then, both these are somewhat low
+#define MIN_LAYOUT_BUILDABLES 512
+
 #define FRAMETIME     100         // msec
 #define CARNAGE_REWARD_TIME 3000
 #define REWARD_SPRITE_TIME  2000
@@ -44,15 +88,59 @@
 #define SP_INTERMISSION_DELAY_TIME 5000
 
 // gentity->flags
-#define FL_GODMODE        0x00000010
-#define FL_NOTARGET       0x00000020
-#define FL_TEAMSLAVE      0x00000400  // not the first on the team
-#define FL_NO_KNOCKBACK   0x00000800
-#define FL_DROPPED_ITEM   0x00001000
-#define FL_NO_BOTS        0x00002000  // spawn point not for bot use
-#define FL_NO_HUMANS      0x00004000  // spawn point just for bots
-#define FL_FORCE_GESTURE  0x00008000  // spawn point just for bots
+#define FL_GODMODE             0x00000010
+#define FL_NOTARGET            0x00000020
+#define FL_TEAMSLAVE           0x00000400  // not the first on the team
+#define FL_NO_KNOCKBACK        0x00000800
+#define FL_DROPPED_ITEM        0x00001000
+#define FL_NO_BOTS             0x00002000  // spawn point not for bot use
+#define FL_NO_HUMANS           0x00004000  // spawn point just for bots
+#define FL_FORCE_GESTURE       0x00008000  // spawn point just for bots
 
+// oc flags
+// these must all be lowercase!!
+#define OCFL_ONEARM                  "n"
+#define OCFL_NOCREEP                 "p"
+#define OCFL_ALIENONLY               "a"
+#define OCFL_BOTHTEAMS               "b"
+#define OCFL_NOWALLWALK              "w"
+#define OCFL_NOALIENTURRETFIRE       "u"
+#define OCFL_NOALIENTESLAFIRE        "e"
+#define OCFL_NOALIENREACTORFIRE      "r"
+#define OCFL_AGRANGER                "g"
+#define OCFL_AGRANGERUPG             "^g"
+#define OCFL_ADRETCH                 "d"
+#define OCFL_ABASILISK               "l"
+#define OCFL_ABASILISKUPG            "^l"
+#define OCFL_AMARAUDER               "m"
+#define OCFL_AMARAUDERUPG            "^m"
+#define OCFL_ADRAGOON                "h"
+#define OCFL_ADRAGOONUPG             "^h"
+#define OCFL_ATYRANT                 "t"
+
+// oc flag names
+#define OCFL_ONEARM_NAME             "UseOneArm"
+#define OCFL_NOCREEP_NAME            "NoCreep"
+#define OCFL_ALIENONLY_NAME          "Aliens"
+#define OCFL_BOTHTEAMS_NAME          "BothTeams"
+#define OCFL_NOWALLWALK_NAME         "NoWallWalk"
+#define OCFL_NOALIENTURRETFIRE_NAME  "NoTurretDamage"
+#define OCFL_NOALIENTESLAFIRE_NAME   "NoTeslaDamage"
+#define OCFL_NOALIENREACTORFIRE_NAME "NoReactorDamage"
+#define OCFL_AGRANGER_NAME           "Grangers"
+#define OCFL_AGRANGERUPG_NAME        "AdvGrangers"
+#define OCFL_ADRETCH_NAME            "Dretches"
+#define OCFL_ABASILISK_NAME          "Basilisks"
+#define OCFL_ABASILISKUPG_NAME       "AdvBasilisks"
+#define OCFL_AMARAUDER_NAME          "Maradauders"
+#define OCFL_AMARAUDERUPG_NAME       "AdvMaradauders"
+#define OCFL_ADRAGOON_NAME           "Dragoons"
+#define OCFL_ADRAGOONUPG_NAME        "AdvDragoons"
+#define OCFL_ATYRANT_NAME            "Tyrants"
+
+// oc high scores and stats
+#define OC_STATMAXRECORDS 16
+
 // movers are things like doors, plats, buttons, etc
 typedef enum
 {
@@ -198,6 +286,7 @@
   gentity_t         *parentNode;        // for creep and defence/spawn dependencies
   qboolean          active;             // for power repeater, but could be useful elsewhere
   qboolean          powered;            // for human buildables
+  qboolean          verifyUnpowered;    // oc crap
   int               builtBy;            // clientNum of person that built this
   gentity_t         *dccNode;           // controlling dcc
   gentity_t         *overmindNode;      // controlling overmind
@@ -215,6 +304,7 @@
   int               clientSpawnTime;    // the time until this spawn can spawn a client
   qboolean          lev1Grabbed;        // for turrets interacting with lev1s
   int               lev1GrabTime;       // for turrets interacting with lev1s
+  int               spawnBlockTime;
 
   int               credits[ MAX_CLIENTS ];     // human credits for each client
   qboolean          creditsHash[ MAX_CLIENTS ]; // track who has claimed credit
@@ -239,6 +329,13 @@
   int               suicideTime;                    // when the client will suicide
 
   int               lastDamageTime;
+
+  int               ocMediID;
+  int               ocArmID;
+
+  int               groupID;
+  int               spawnGroup;
+  float             reserved2;
 };
 
 typedef enum
@@ -294,6 +391,7 @@
 typedef struct
 {
   team_t            sessionTeam;
+  pTeam_t         restartTeam; //for !restart keepteams and !restart switchteams
   int               spectatorTime;    // for determining next-in-line to play
   spectatorState_t  spectatorState;
   int               spectatorClient;  // for chasecam and follow mode
@@ -307,13 +405,44 @@
 // data to store details of clients that have abnormally disconnected
 typedef struct connectionRecord_s
 {
-  int       clientNum;
-  pTeam_t   clientTeam;
-  int       clientCredit;
+  int        clientNum;
+  pTeam_t    clientTeam;
+  int        clientCredit;
+  gentity_t  *lastOCCheckpoint;
+  gentity_t  **medisLastCheckpoint;
+  gentity_t  **armsLastCheckpoint;
+  int        lastAliveTime;
+  int        aliveTime;
+  int        hasCheated;
 
   int       ptrCode;
 } connectionRecord_t;
 
+//#define MAX_CP 1024
+#define MAX_CP 60
+typedef struct
+{
+    qboolean    active;
+    int         start;
+    char        message[ MAX_STRING_CHARS ];
+} mix_cp_t;
+//#define CP_FRAME_TIME     400
+
+//client flags
+#define CP_FRAME_TIME     50
+#define CP_TIME           3000
+#define CLIENT_SPECTATORS 0x01  // send to players _directly_ spectating target
+#define CLIENT_OCTEAM     0x02  // send to players on the same team as target
+#define CLIENT_ALLBUT     0x04  // inverse send, excluding all below.  Anything
+                                // above is only accounted for if ent is not
+                                // null
+#define CLIENT_NOTARGET   0x08  // regardless of who it gets sent to, never
+                                // send to target
+#define CLIENT_NOTEAM     0x10  // regardless of who it gets sent to, never
+                                // send to anybody on a team
+#define CLIENT_ONLYTEAM   0x20  // regardless of who it gets sent to, never
+                                // send to anybody not on a team
+
 // client data that stays across multiple respawns, but is cleared
 // on each level change or team change at ClientBegin()
 typedef struct
@@ -342,20 +471,68 @@
   int                 nameChangeTime;
   int                 nameChanges;
 
-  // used to save persistant[] values while in SPECTATOR_FOLLOW mode
-  int                 savedScore;
-  int                 savedCredit;
+  int                 noAuO;
 
+  // used to save playerState_t values while in SPECTATOR_FOLLOW mode
+  int                 score;
+  int                 credit;
+  int                 ping;
+
   // votes
   qboolean            vote;
   qboolean            teamVote;
 
+  int                 lastFloodTime;         // level.time of last flood-limited command
+  int                 floodDemerits;         // number of flood demerits accumulated
+
   vec3_t              lastDeathLocation;
   char                guid[ 33 ];
   char                ip[ 16 ];
   qboolean            muted;
   qboolean            denyBuild;
+  qboolean            override;
   int                 adminLevel;
+  int                 specExpires;          // level.time at which a player can join a team again after !spec
+  qboolean            designatedBuilder;
+  int                 floodTimer;
+
+  qboolean            firstConnect;        // This is the first map since connect
+  int                 crashTime;
+
+  // oc data
+  int                 cheated;
+  int                 ocTeam;
+  int                 restartocOKtime;
+  gentity_t           *lastOCCheckpoint;
+  gentity_t           **medis;  // array of medistations by id
+  gentity_t           **medisLastCheckpoint; // array of medistations by id since last checkpoint
+  gentity_t           **arms;
+  gentity_t           **armsLastCheckpoint;
+  int                 hidden;
+  int                 hiddenTime;
+  char                hiddenReason[ MAX_STRING_CHARS ];
+  int                 ocNeedSpawn;
+  int                 ocNeedSpawnTime;
+  int                 ocTimeDisplay;
+  mix_cp_t            *clientCP;
+  int                 autoAngleDisabled;
+  int                 nextWeaponTime;
+#define OC_WEAPON_FRAME_TIME 1000
+  int                 nextAOTime;
+#define OC_AO_FRAME_TIME 500
+  int                 nextWallwalkTime;
+#define OC_WALLWALK_FRAME_TIME 10
+  int                 nextEvolveTime;
+#define OC_EVOLVE_FRAME_TIME 50
+  int                 nextSpawnTime;
+#define OC_SPAWN_FRAME_TIME 50
+
+  // oc highscores and stats
+  int               mediTime;
+  int               winTime;
+  int               aliveTime;
+  int               lastAliveTime;
+  int               hasCheated;
 } clientPersistant_t;
 
 #define MAX_UNLAGGED_MARKERS 10
@@ -455,11 +632,16 @@
 
   int                 lastFlameBall;        // s.number of the last flame ball fired
 
+#define RAM_FRAMES  1                       // number of frames to wait before retriggering
+  int                 retriggerArmouryMenu; // frame number to retrigger the armoury menu
+
   unlagged_t          unlaggedHist[ MAX_UNLAGGED_MARKERS ];
   unlagged_t          unlaggedBackup;
   unlagged_t          unlaggedCalc;
   int                 unlaggedTime;
 
+  int               tkcredits[ MAX_CLIENTS ];
+
 };
 
 
@@ -477,7 +659,8 @@
 int       G_GetSpawnQueueLength( spawnQueue_t *sq );
 int       G_PopSpawnQueue( spawnQueue_t *sq );
 int       G_PeekSpawnQueue( spawnQueue_t *sq );
-void      G_PushSpawnQueue( spawnQueue_t *sq, int clientNum );
+qboolean  G_SearchSpawnQueue( spawnQueue_t *sq, int clientNum );
+qboolean  G_PushSpawnQueue( spawnQueue_t *sq, int clientNum );
 qboolean  G_RemoveFromSpawnQueue( spawnQueue_t *sq, int clientNum );
 int       G_GetPosInSpawnQueue( spawnQueue_t *sq, int clientNum );
 
@@ -518,6 +701,32 @@
   TW_PASSED
 } timeWarning_t;
 
+typedef enum
+{
+  BF_BUILT,
+  BF_DECONNED,
+  BF_DESTROYED,
+  BF_TEAMKILLED
+} buildableFate_t;
+
+// record all changes to the buildable layout - build, decon, destroy - and
+// enough information to revert that change
+typedef struct buildHistory_s buildHistory_t;
+struct buildHistory_s
+{
+  int ID; // persistent ID to aid in specific reverting
+  gentity_t *ent; // who, NULL if they've disconnected (or aren't an ent)
+  char name[ MAX_NETNAME ]; // who, saves name if ent is NULL
+  int buildable; // what
+  vec3_t origin; // where
+  vec3_t angles; // which way round
+  vec3_t origin2; // I don't know what the hell these are, but layoutsave saves
+  vec3_t angles2; // them so I will do the same
+  buildableFate_t fate; // was it built, destroyed or deconned
+  buildHistory_t *next; // next oldest change
+  buildHistory_t *marked; // linked list of markdecon buildings taken
+};
+
 //
 // this structure is cleared as each map is entered
 //
@@ -526,14 +735,42 @@
 
 typedef struct
 {
+    int       active;
+    char      name[MAX_NAME_LENGTH];
+    int       time;
+    gentity_t **arms;
+    gentity_t **medis;
+    gentity_t *lastOCCheckpoint;
+    weapon_t  weapon;
+//    struct oc_scrimTeam_t *next;
+} oc_scrimTeam_t;
+
+#define MAX_SCRIM_TEAMS 64  // really up to MAX_SCRIM_TEAMS - 1 are allowed
+
+/*
+#define OC_GETTEAM(d, s, n) \
+{ \
+    int i; \
+    for(i = 0, (d) = (s); (d) && i < (n); (d) = ((d)->next), i++); \
+    if(!t) \
+        G_LogPrintf("ERROR: non-existant team %d requested\n", n); \
+}
+*/
+
+// no longer a linked list
+#define OC_GETTEAM(d, s, n) \
+{ \
+    (d) = (s) + (n); \
+}
+
+typedef struct
+{
   struct gclient_s  *clients;   // [maxclients]
 
   struct gentity_s  *gentities;
   int               gentitySize;
   int               num_entities;   // current number, <= MAX_GENTITIES
 
-  int               warmupTime;     // restart match at this time
-
   fileHandle_t      logFile;
 
   // store latched cvars here that we want to get at often
@@ -542,6 +779,7 @@
   int               framenum;
   int               time;                         // in msec
   int               previousTime;                 // so movers can back up when blocked
+  int               frameMsec;                    // trap_Milliseconds() at end frame
 
   int               startTime;                    // level.time the map was started
 
@@ -558,13 +796,14 @@
   int               numPlayingClients;            // connected, non-spectators
   int               sortedClients[MAX_CLIENTS];   // sorted by score
 
+  int               numNewbies;                   // number of UnnamedPlayers who have been renamed this round.
+
   int               snd_fry;                      // sound index for standing in lava
 
-  int               warmupModificationCount;      // for detecting if g_warmup is changed
-
   // voting state
   char              voteString[MAX_STRING_CHARS];
   char              voteDisplayString[MAX_STRING_CHARS];
+  int               votePercentToPass;
   int               voteTime;                     // level.time vote was called
   int               voteExecuteTime;              // time the vote is executed
   int               voteYes;
@@ -634,6 +873,9 @@
 
   pTeam_t           lastWin;
 
+  int               suddenDeathABuildPoints;
+  int               suddenDeathHBuildPoints;
+  qboolean          suddenDeath;
   timeWarning_t     suddenDeathWarning;
   timeWarning_t     timelimitWarning;
 
@@ -649,6 +891,8 @@
   qboolean          uncondHumanWin;
   qboolean          alienTeamLocked;
   qboolean          humanTeamLocked;
+  qboolean paused;
+  int pausedTime;
 
   int unlaggedIndex;
   int unlaggedTimes[ MAX_UNLAGGED_MARKERS ];
@@ -656,17 +900,48 @@
   char              layout[ MAX_QPATH ];
 
   pTeam_t           surrenderTeam;
+   int              lastTeamUnbalancedTime;
+   int              numTeamWarnings;
+
+  buildHistory_t    *buildHistory;
+  int               lastBuildID;
+
+  int               totalMedistations;
+  int               totalArmouries;
+  int               numNodes;
+
+  oc_scrimTeam_t    *scrimTeam;  // scrimTeam[0] is always NULL
+  int               ocScrimMode;
+  int               ocStartTime;
+  int               ocScrimState;
+  int               ocEndsTime;
+  int               ocOrder;
+  int               ocLoadTime;
+  int               oc;
+
+  int               nextCPTime;
 } level_locals_t;
 
-#define CMD_CHEAT         0x01
-#define CMD_MESSAGE       0x02 // sends message to others (skip when muted)
-#define CMD_TEAM          0x04 // must be on a team
-#define CMD_NOTEAM        0x08 // must not be on a team
-#define CMD_ALIEN         0x10
-#define CMD_HUMAN         0x20
-#define CMD_LIVING        0x40
-#define CMD_INTERMISSION  0x80 // valid during intermission
+#define OC_PREP_TIME 1500  // enough to get a few frames in
 
+#define OC_STATE_NONE 0
+#define OC_STATE_PREP 1
+#define OC_STATE_WARM 2
+#define OC_STATE_PLAY 3
+
+#define OC_MODE_MEDI 1
+#define OC_MODE_ARM  2
+
+#define CMD_CHEAT         0x00000001
+#define CMD_MESSAGE       0x00000002 // sends message to others (skip when muted)
+#define CMD_TEAM          0x00000004 // must be on a team
+#define CMD_NOTEAM        0x00000008 // must not be on a team
+#define CMD_ALIEN         0x00000010
+#define CMD_HUMAN         0x00000020
+#define CMD_LIVING        0x00000040
+#define CMD_INTERMISSION  0x00000080 // valid during intermission
+#define CMD_STEALTH       0x00000100 // will print Unknown command if command has permission to run
+
 typedef struct
 {
   char *cmdName;
@@ -689,11 +964,13 @@
 // g_cmds.c
 //
 void      Cmd_Score_f( gentity_t *ent );
+void      G_StopFromFollowing( gentity_t *ent );
 void      G_StopFollowing( gentity_t *ent );
 qboolean  G_FollowNewClient( gentity_t *ent, int dir );
 void      G_ToggleFollow( gentity_t *ent );
 void      G_MatchOnePlayer( int *plist, int num, char *err, int len );
 int       G_ClientNumbersFromString( char *s, int *plist, int max );
+void G_Say( gentity_t *ent, gentity_t *target, int mode, const char *chatText );
 int       G_SayArgc( void );
 qboolean  G_SayArgv( int n, char *buffer, int bufferLength );
 char      *G_SayConcatArgs( int start );
@@ -702,6 +979,18 @@
 void      G_ChangeTeam( gentity_t *ent, pTeam_t newTeam );
 void      G_SanitiseName( char *in, char *out );
 void      G_PrivateMessage( gentity_t *ent );
+qboolean  G_RoomForClassChange( gentity_t *ent, pClass_t class, vec3_t newOrigin );
+void      Cmd_TeamVote_f( gentity_t *ent );
+void      Cmd_Share_f( gentity_t *ent );
+void      Cmd_Donate_f( gentity_t *ent );
+char      *G_MediStats( gentity_t *ent, int count, int time );
+char      *G_WinStats( gentity_t *ent, int count, int time );
+int       G_StrFind( const char *str, const char * const find );
+void      G_UpdateCP( void );
+void      G_ClientCP( gentity_t *ent, char *message, char *find, int mode );
+void      G_ClientPrint( gentity_t *ent, char *message, int mode );
+void      G_RestartClient( gentity_t *ent, int quick, int restartScrimTeam );
+void      G_ToLowerCase(char *str);
 
 //
 // g_physics.c
@@ -741,27 +1030,70 @@
   IBE_MAXERRORS
 } itemBuildError_t;
 
+int               G_UseMedi( gentity_t *medi, gentity_t *ent );
+int               G_MergeMedis ( gentity_t **dst, gentity_t **src);
+int               G_AppendMedi( gentity_t **medis, gentity_t *medi);
+int               G_RemoveMedi( gentity_t **medis, gentity_t *medi);
+int               G_AllMedis( gentity_t **medis );
+int               G_HasMediBeenUsed(gentity_t *medi, gentity_t **medis);
+int               G_NumberOfMedis( gentity_t **medis );
+int               G_ClearMedis(gentity_t **medis);
+int               G_UseArm( gentity_t *ent, gentity_t *arm );
+int               G_MergeArms ( gentity_t **dst, gentity_t **src);
+int               G_AppendArm( gentity_t **arms, gentity_t *arm);
+int               G_RemoveArm( gentity_t **arms, gentity_t *arm);
+int               G_AllArms( gentity_t **arms );
+int               G_HasArmBeenUsed(gentity_t *arm, gentity_t **arms);
+int               G_NumberOfArms( gentity_t **arms );
+int               G_ClearArms(gentity_t **arms);
+int               G_CanUseBonus( gentity_t *ent );
+int               G_WeaponIsReserved( weapon_t weapon );
+int               G_WeaponRemoveReserved( gentity_t *ent );
+int               G_StructureBuilt( gentity_t *ent );
+int               G_StructureDecon( gentity_t *ent );
+int               G_OCPlayerCheckpoint(gentity_t *checkpoint, gentity_t *ent);
+int               G_OCPlayerDie( gentity_t *ent );
+int               G_OCPlayerSpawn( gentity_t *ent );
+oc_scrimTeam_t    *G_OCScrimTeam( char *name );
+oc_scrimTeam_t    *G_OCNewScrimTeam( char *name, weapon_t weapon, char *err, int errlen );
+int               G_OCScrimValidWeapon( weapon_t weapon );
+int               G_OCScrimValidTeamName( char *name );
+int               G_OCScrimTeamEmpty( void );
+int               G_OCScrimTeamRemovePlayer( gentity_t *ent );
+int               G_OCScrimAllWon( void );
+int               G_OCSingleScrim( void );
+int               G_OCScrimEnd( void );
+
 qboolean          AHovel_Blocked( gentity_t *hovel, gentity_t *player, qboolean provideExit );
 gentity_t         *G_CheckSpawnPoint( int spawnNum, vec3_t origin, vec3_t normal,
-                    buildable_t spawn, vec3_t spawnOrigin );
+                    buildable_t spawn, vec3_t spawnOrigin, int force );
 
 buildable_t       G_IsPowered( vec3_t origin );
 qboolean          G_IsDCCBuilt( void );
 qboolean          G_IsOvermindBuilt( void );
 
 void              G_BuildableThink( gentity_t *ent, int msec );
-qboolean          G_BuildableRange( vec3_t origin, float r, buildable_t buildable );
+gentity_t         *G_BuildableRange( vec3_t origin, float r, buildable_t buildable );
 itemBuildError_t  G_CanBuild( gentity_t *ent, buildable_t buildable, int distance, vec3_t origin );
+qboolean G_BuildingExists( int bclass ) ;
 qboolean          G_BuildIfValid( gentity_t *ent, buildable_t buildable );
 void              G_SetBuildableAnim( gentity_t *ent, buildableAnimNumber_t anim, qboolean force );
 void              G_SetIdleBuildableAnim( gentity_t *ent, buildableAnimNumber_t anim );
-void              G_SpawnBuildable(gentity_t *ent, buildable_t buildable);
+void              G_SpawnBuildable(gentity_t *ent, buildable_t buildable, int groupID, int spawnGroup, float reserved2);
 void              FinishSpawningBuildable( gentity_t *ent );
+void              G_CheckDBProtection( void );
 void              G_LayoutSave( char *name );
 int               G_LayoutList( const char *map, char *list, int len );
 void              G_LayoutSelect( void );
-void              G_LayoutLoad( void );
+void              G_LayoutLoad( char *layout );
+int               G_AddArmouryToClient( gentity_t *ent, int *test, int *test2 );
 void              G_BaseSelfDestruct( pTeam_t team );
+gentity_t         *G_InstantBuild( buildable_t buildable, vec3_t origin, vec3_t angles, vec3_t origin2, vec3_t angles2 );
+void              G_SpawnRevertedBuildable( buildHistory_t *bh, qboolean mark );
+void              G_CommitRevertedBuildable( gentity_t *ent );
+qboolean          G_RevertCanFit( buildHistory_t *bh );
+int               G_LogBuild( buildHistory_t *new );
+int               G_CountBuildLog( void );
 
 //
 // g_utils.c
@@ -905,15 +1237,20 @@
 //
 void      G_AddCreditToClient( gclient_t *client, short credit, qboolean cap );
 team_t    TeamCount( int ignoreClientNum, int team );
-void      SetClientViewAngle( gentity_t *ent, vec3_t angle );
-gentity_t *SelectTremulousSpawnPoint( pTeam_t team, vec3_t preference, vec3_t origin, vec3_t angles );
-gentity_t *SelectSpawnPoint( vec3_t avoidPoint, vec3_t origin, vec3_t angles );
+void      G_SetClientViewAngle( gentity_t *ent, vec3_t angle );
+gentity_t *G_SelectTremulousSpawnPoint( pTeam_t team, vec3_t preference, vec3_t origin, vec3_t angles, gentity_t *ent );
+gentity_t *G_SelectSpawnPoint( vec3_t avoidPoint, vec3_t origin, vec3_t angles );
+gentity_t *G_SelectAlienLockSpawnPoint( vec3_t origin, vec3_t angles );
+gentity_t *G_SelectHumanLockSpawnPoint( vec3_t origin, vec3_t angles );
+gentity_t *G_SelectAlienSpawnPoint( vec3_t preference, gentity_t *ent, int groupID, gentity_t *not );
+gentity_t *G_SelectHumanSpawnPoint( vec3_t preference, gentity_t *ent, int groupID, gentity_t *not );
 void      SpawnCorpse( gentity_t *ent );
 void      respawn( gentity_t *ent );
 void      BeginIntermission( void );
 void      ClientSpawn( gentity_t *ent, gentity_t *spawn, vec3_t origin, vec3_t angles );
 void      player_die( gentity_t *self, gentity_t *inflictor, gentity_t *attacker, int damage, int mod );
 qboolean  SpotWouldTelefrag( gentity_t *spot );
+char     *G_NextNewbieName( gentity_t *ent );
 
 //
 // g_svcmds.c
@@ -939,12 +1276,17 @@
 void ScoreboardMessage( gentity_t *client );
 void MoveClientToIntermission( gentity_t *client );
 void G_MapConfigs( const char *mapname );
+void G_CountSpawns( void );
+void G_CalculateBuildPoints( void );
 void CalculateRanks( void );
+void G_CalculateStages( void );
 void FindIntermissionPoint( void );
 void G_RunThink( gentity_t *ent );
 void QDECL G_LogPrintf( const char *fmt, ... );
+void QDECL G_LogOnlyPrintf( const char *fmt, ... );
 void SendScoreboardMessageToAllClients( void );
 void QDECL G_Printf( const char *fmt, ... );
+void QDECL G_AdminsPrintf( const char *fmt, ... );
 void QDECL G_Error( const char *fmt, ... );
 void G_Vote( gentity_t *ent, qboolean voting );
 void G_TeamVote( gentity_t *ent, qboolean voting );
@@ -952,6 +1294,10 @@
 void CheckTeamVote( int teamnum );
 void LogExit( const char *string );
 int  G_TimeTilSuddenDeath( void );
+void G_ParseLayoutFlags( char *layout, char *out );
+qboolean G_TestLayoutFlag( char *layout, char *flag );
+qboolean G_LayoutExtraFlags( char *layout );
+qboolean G_Flood_Limited( gentity_t *ent );
 
 //
 // g_client.c
@@ -961,6 +1307,7 @@
 void ClientDisconnect( int clientNum );
 void ClientBegin( int clientNum );
 void ClientCommand( int clientNum );
+int ClientPingOverride( void );
 
 //
 // g_active.c
@@ -1102,15 +1449,26 @@
 extern  vmCvar_t  g_maxclients;     // allow this many total, including spectators
 extern  vmCvar_t  g_maxGameClients;   // allow this many active
 extern  vmCvar_t  g_restarted;
+extern  vmCvar_t  g_lockTeamsAtStart;
 extern  vmCvar_t  g_minCommandPeriod;
 extern  vmCvar_t  g_minNameChangePeriod;
 extern  vmCvar_t  g_maxNameChanges;
+extern  vmCvar_t  g_newbieNumbering;
+extern  vmCvar_t  g_newbieNamePrefix;
+extern  vmCvar_t  g_maintenance;
+extern  vmCvar_t  g_maintenanceMessage;
+extern  vmCvar_t  g_connectMessage;
 
 extern  vmCvar_t  g_timelimit;
+extern  vmCvar_t  g_voteExecuteTime;
 extern  vmCvar_t  g_suddenDeathTime;
+extern  vmCvar_t  g_suddenDeath;
+extern  vmCvar_t  g_suddenDeathMode;
 extern  vmCvar_t  g_friendlyFire;
 extern  vmCvar_t  g_friendlyFireHumans;
 extern  vmCvar_t  g_friendlyFireAliens;
+extern  vmCvar_t  g_retribution;
+extern  vmCvar_t  g_friendlyFireMovementAttacks;
 extern  vmCvar_t  g_friendlyBuildableFire;
 extern  vmCvar_t  g_password;
 extern  vmCvar_t  g_needpass;
@@ -1131,6 +1489,14 @@
 extern  vmCvar_t  g_blood;
 extern  vmCvar_t  g_allowVote;
 extern  vmCvar_t  g_voteLimit;
+extern  vmCvar_t  g_suddenDeathVotePercent;
+extern  vmCvar_t  g_startScrimVotePercent;
+extern  vmCvar_t  g_endScrimVotePercent;
+extern  vmCvar_t  g_mapVotesPercent;
+extern  vmCvar_t  g_ocVotesPercent;
+extern  vmCvar_t  g_ocTimeMapDropPercent;
+extern  vmCvar_t  g_autoMajorityVotes;
+extern  vmCvar_t  g_designateVotes;
 extern  vmCvar_t  g_teamAutoJoin;
 extern  vmCvar_t  g_teamForceBalance;
 extern  vmCvar_t  g_banIPs;
@@ -1139,6 +1505,8 @@
 extern  vmCvar_t  pmove_fixed;
 extern  vmCvar_t  pmove_msec;
 extern  vmCvar_t  g_rankings;
+extern  vmCvar_t  g_allowShare;
+extern  vmCvar_t  g_allowDonate;
 extern  vmCvar_t  g_enableDust;
 extern  vmCvar_t  g_enableBreath;
 extern  vmCvar_t  g_singlePlayer;
@@ -1155,7 +1523,10 @@
 extern  vmCvar_t  g_alienMaxStage;
 extern  vmCvar_t  g_alienStage2Threshold;
 extern  vmCvar_t  g_alienStage3Threshold;
+extern  vmCvar_t  g_teamImbalanceWarnings;
 
+extern  vmCvar_t  g_allowAdminCheats;
+
 extern  vmCvar_t  g_unlagged;
 
 extern  vmCvar_t  g_disabledEquipment;
@@ -1163,12 +1534,15 @@
 extern  vmCvar_t  g_disabledBuildables;
 
 extern  vmCvar_t  g_markDeconstruct;
+extern  vmCvar_t  g_deconDead;
 
 extern  vmCvar_t  g_debugMapRotation;
 extern  vmCvar_t  g_currentMapRotation;
 extern  vmCvar_t  g_currentMap;
 extern  vmCvar_t  g_initialMapRotation;
 extern  vmCvar_t  g_chatTeamPrefix;
+extern  vmCvar_t  g_floodMaxDemerits;
+extern  vmCvar_t  g_floodMinTime;
 
 extern  vmCvar_t  g_shove;
 
@@ -1180,11 +1554,46 @@
 extern  vmCvar_t  g_admin;
 extern  vmCvar_t  g_adminLog;
 extern  vmCvar_t  g_adminParseSay;
+extern  vmCvar_t  g_adminSayFilter;
 extern  vmCvar_t  g_adminNameProtect;
 extern  vmCvar_t  g_adminTempBan;
+extern  vmCvar_t  g_adminTempSpec;
 
+extern  vmCvar_t  g_devmapKillerHP;
+
 extern  vmCvar_t  g_privateMessages;
+extern  vmCvar_t  g_publicSayadmins;
+extern  vmCvar_t  g_antiSpawnBlock;
+extern  vmCvar_t  g_floodProtection;
 
+extern  vmCvar_t  g_buildLogMaxLength;
+
+extern  vmCvar_t  g_allowShare;
+extern  vmCvar_t  g_allowDonate;
+
+extern  vmCvar_t  g_ocReview;
+extern  vmCvar_t  g_ocAutoVotes;
+extern  vmCvar_t  g_ocEditMode;
+extern  vmCvar_t  g_allowHiding;
+extern  vmCvar_t  g_hideTimeCallvoteMinutes;
+extern  vmCvar_t  g_hideNotTimeCallvoteMinutes;
+extern  vmCvar_t  g_statsEnabled;
+extern  vmCvar_t  g_statsRecords;
+extern  vmCvar_t  g_disableCPMixes;
+extern  vmCvar_t  g_ocWarmup;
+extern  vmCvar_t  g_ocScrimAfterTime;
+
+extern  vmCvar_t  g_allowActions;
+extern  vmCvar_t  g_actionPrefix;
+
+extern  vmCvar_t  g_dretchPunt;
+
+extern  vmCvar_t  g_devmapNoGod;
+extern  vmCvar_t  g_devmapNoStructDmg;
+
+extern  vmCvar_t  g_voteMinTime;
+extern  vmCvar_t  g_mapvoteMaxTime;
+
 void      trap_Printf( const char *fmt );
 void      trap_Error( const char *fmt );
 int       trap_Milliseconds( void );
Index: src/game/g_ptr.c
===================================================================
--- src/game/g_ptr.c	(revision 1055)
+++ src/game/g_ptr.c	(working copy)
@@ -61,11 +61,40 @@
 {
   if( client && client->pers.connection )
   {
-    client->pers.connection->clientTeam = client->pers.teamSelection;
     if( client->pers.teamSelection == PTE_NONE )
-      client->pers.connection->clientCredit = client->pers.savedCredit;
+      client->pers.connection->clientCredit = client->pers.credit;
     else
       client->pers.connection->clientCredit = client->ps.persistant[ PERS_CREDIT ];
+    client->pers.connection->clientTeam = client->pers.teamSelection;
+    if( level.oc )
+    {
+        if( client->pers.medisLastCheckpoint && client->pers.connection->medisLastCheckpoint )
+        {
+          if( !client->pers.connection->medisLastCheckpoint )
+            client->pers.connection->medisLastCheckpoint = G_Alloc( ( level.totalMedistations ) * sizeof( gentity_t * ) );
+          memcpy( client->pers.connection->medisLastCheckpoint, client->pers.medisLastCheckpoint, level.totalMedistations + 1);
+        }
+        if( client->pers.armsLastCheckpoint )
+        {
+          if( !client->pers.connection->armsLastCheckpoint )
+            client->pers.connection->armsLastCheckpoint = G_Alloc( ( level.totalArmouries ) * sizeof( gentity_t * ) );
+          memcpy( client->pers.connection->armsLastCheckpoint, client->pers.armsLastCheckpoint, level.totalArmouries + 1);
+        }
+        client->pers.connection->lastOCCheckpoint = client->pers.lastOCCheckpoint;
+        client->pers.connection->aliveTime = client->pers.aliveTime;
+        client->pers.connection->lastAliveTime = client->pers.lastAliveTime;
+        client->pers.connection->hasCheated = client->pers.hasCheated;
+        if( client->pers.ocTeam )
+        {
+            // don't let them
+            client->pers.connection->hasCheated = 1;
+            client->pers.connection->aliveTime = INFINITE;
+            client->pers.connection->lastAliveTime = INFINITE;
+            while(client->pers.connection->aliveTime < 1) client->pers.connection->aliveTime--;
+            while(client->pers.connection->lastAliveTime < 1) client->pers.connection->lastAliveTime--;
+            client->pers.connection->lastOCCheckpoint = NULL;
+        }
+    }
   }
 }
 
Index: src/game/g_combat.c
===================================================================
--- src/game/g_combat.c	(revision 1055)
+++ src/game/g_combat.c	(working copy)
@@ -41,10 +41,6 @@
   if( !ent->client )
     return;
 
-  // no scoring during pre-match warmup
-  if( level.warmupTime )
-    return;
-
   ent->client->ps.persistant[ PERS_SCORE ] += score;
   CalculateRanks( );
 }
@@ -138,7 +134,9 @@
   char      *killerName, *obit;
   float     totalDamage = 0.0f;
   gentity_t *player;
+  qboolean  tk = qfalse;
 
+  G_OCPlayerDie( self );
 
   if( self->client->ps.pm_type == PM_DEAD )
     return;
@@ -147,16 +145,7 @@
     return;
 
   // stop any following clients
-  for( i = 0; i < level.maxclients; i++ )
-  {
-    if( level.clients[ i ].sess.sessionTeam == TEAM_SPECTATOR &&
-        level.clients[ i ].sess.spectatorState == SPECTATOR_FOLLOW &&
-        level.clients[ i ].sess.spectatorClient == self->client->ps.clientNum )
-    {
-      if( !G_FollowNewClient( &g_entities[ i ], 1 ) )
-        G_StopFollowing( &g_entities[ i ] );
-    }
-  }
+  // r1: removed, annoying.
 
   self->client->ps.pm_type = PM_DEAD;
   self->suicideTime = 0;
@@ -166,7 +155,11 @@
     killer = attacker->s.number;
 
     if( attacker->client )
+    {
       killerName = attacker->client->pers.netname;
+      tk = ( attacker != self && attacker->client->ps.stats[ STAT_PTEAM ]
+        == self->client->ps.stats[ STAT_PTEAM ] );
+    }
     else
       killerName = "<non-client>";
   }
@@ -199,36 +192,94 @@
     BG_DeactivateUpgrade( i, self->client->ps.stats );
 
   // broadcast the death event to everyone
-  ent = G_TempEntity( self->r.currentOrigin, EV_OBITUARY );
-  ent->s.eventParm = meansOfDeath;
-  ent->s.otherEntityNum = self->s.number;
-  ent->s.otherEntityNum2 = killer;
-  ent->r.svFlags = SVF_BROADCAST; // send to everyone
+  if( !tk )
+  {
+    ent = G_TempEntity( self->r.currentOrigin, EV_OBITUARY );
+    ent->s.eventParm = meansOfDeath;
+    ent->s.otherEntityNum = self->s.number;
+    ent->s.otherEntityNum2 = killer;
+    ent->r.svFlags = SVF_BROADCAST; // send to everyone
+  }
+  else
+  {
+    // tjw: obviously this is a hack and belongs in the client, but
+    //      this works as a temporary fix.
 
+    trap_SendServerCommand( -1,
+      va( "print \"%s^7 was killed by ^1TEAMMATE^7 %s^7 (Did %d damage to %d max)\n\"",
+      self->client->pers.netname, attacker->client->pers.netname, self->client->tkcredits[ attacker->s.number ], self->client->ps.stats[ STAT_MAX_HEALTH ] ) );
+    trap_SendServerCommand( attacker - g_entities,
+      va( "cp \"You killed ^1TEAMMATE^7 %s\"", self->client->pers.netname ) );
+  }
+
   self->enemy = attacker;
 
   self->client->ps.persistant[ PERS_KILLED ]++;
-
   if( attacker && attacker->client )
   {
     attacker->client->lastkilled_client = self->s.number;
 
+   if( g_devmapKillerHP.integer && g_cheats.integer )
+   {
+     trap_SendServerCommand( self-g_entities, va( "print \"Your killer, %s, had %3i HP.\n\"", killerName, attacker->health ) );
+   }
+
     if( attacker == self || OnSameTeam( self, attacker ) )
     {
       AddScore( attacker, -1 );
 
-      //punish team kills and suicides
-      if( attacker->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
-        G_AddCreditToClient( attacker->client, -1, qtrue );
-      else if( attacker->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
-        G_AddCreditToClient( attacker->client, -ASPAWN_VALUE, qtrue );
+      // Retribution: transfer value of player from attacker to victim
+      if( g_retribution.integer) {
+          if(attacker!=self){
+        int max = ALIEN_MAX_KILLS, tk_value = 0;
+        char *type = "evos";
+
+        if( attacker->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS ) {
+          tk_value = BG_ClassCanEvolveFromTo( PCL_ALIEN_LEVEL0,
+            self->client->ps.stats[ STAT_PCLASS ], ALIEN_MAX_KILLS, 0 );
+        } else {
+          tk_value = BG_GetValueOfEquipment( &self->client->ps );
+          max = HUMAN_MAX_CREDITS;
+          type = "credits";
+        }
+
+        if( attacker->client->ps.persistant[ PERS_CREDIT ] < tk_value )
+          tk_value = attacker->client->ps.persistant[ PERS_CREDIT ];
+        if( self->client->ps.persistant[ PERS_CREDIT ]+tk_value > max )
+          tk_value = max-self->client->ps.persistant[ PERS_CREDIT ];
+
+        if( tk_value > 0 ) {
+
+          // adjust using the retribution cvar (in percent)
+          tk_value = tk_value*g_retribution.integer/100;
+
+          G_AddCreditToClient( self->client, tk_value, qtrue );
+          G_AddCreditToClient( attacker->client, -tk_value, qtrue );
+
+          trap_SendServerCommand( self->client->ps.clientNum,
+            va( "print \"Received ^3%d %s ^7from %s ^7in retribution.\n\"",
+            tk_value, type, attacker->client->pers.netname ) );
+          trap_SendServerCommand( attacker->client->ps.clientNum,
+            va( "print \"Transfered ^3%d %s ^7to %s ^7in retribution.\n\"",
+            tk_value, type, self->client->pers.netname ) );
+        }
+          }
+      }
+
+      // Normal teamkill penalty
+      else {
+        if( attacker->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
+          G_AddCreditToClient( attacker->client, -FREEKILL_ALIEN, qtrue );
+        else if( attacker->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+          G_AddCreditToClient( attacker->client, -FREEKILL_HUMAN, qtrue );
+      }
     }
     else
     {
       AddScore( attacker, 1 );
 
       attacker->client->lastKillTime = level.time;
-    }
+     }
   }
   else if( attacker->s.eType != ET_BUILDABLE )
     AddScore( self, -1 );
@@ -775,6 +826,8 @@
         modifier *= g_damageRegions[ class ][ i ].modifier;
     }
 
+
+
     for( i = UP_NONE + 1; i < UP_NUM_UPGRADES; i++ )
     {
       if( BG_InventoryContainsUpgrade( i, targ->client->ps.stats ) )
@@ -947,7 +1000,7 @@
 
   if( client )
   {
-    if( client->noclip )
+    if( client->noclip && !g_devmapNoGod.integer)
       return;
   }
 
@@ -1016,14 +1069,29 @@
     // if the attacker was on the same team
     if( targ != attacker && OnSameTeam( targ, attacker ) )
     {
-      if( !g_friendlyFire.integer )
+      if( g_dretchPunt.integer &&
+        targ->client->ps.stats[ STAT_PCLASS ] == PCL_ALIEN_LEVEL0 )
       {
-        if( !g_friendlyFireHumans.integer 
+        vec3_t dir, push;
+
+        VectorSubtract( targ->r.currentOrigin, attacker->r.currentOrigin, dir );
+        VectorNormalizeFast( dir );
+        VectorScale( dir, ( damage * 10.0f ), push );
+        push[2] = 64.0f;
+        VectorAdd( targ->client->ps.velocity, push, targ->client->ps.velocity );
+        return;
+      } else if( !g_friendlyFireMovementAttacks.integer && (mod == MOD_LEVEL4_CHARGE || mod == MOD_LEVEL3_POUNCE )){
+           // don't do friendly fire on movement attacks
+           return;
+      }
+      else if( !g_friendlyFire.integer )
+      {
+        if( ( !g_friendlyFireHumans.integer )
           && targ->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
         {
           return;
         }
-        if( !g_friendlyFireAliens.integer 
+        if( ( !g_friendlyFireAliens.integer )
           && targ->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
         {
           return;
@@ -1031,17 +1099,31 @@
       }
     }
 
-		// If target is buildable on the same team as the attacking client
-		if( targ->s.eType == ET_BUILDABLE && attacker->client &&
-				targ->biteam == attacker->client->pers.teamSelection )
-		{
-			if( !g_friendlyBuildableFire.integer )
-				return;
-		}
+        // If target is buildable on the same team as the attacking client
+        if( !level.oc && targ->s.eType == ET_BUILDABLE && ( ( attacker->client &&
+                targ->biteam == attacker->client->pers.teamSelection ) ) )
+        {
+            if( !g_friendlyBuildableFire.integer )
+                return;
+            // don't do friendly fire on movement attacks
+             if( !g_friendlyFireMovementAttacks.integer && (mod == MOD_LEVEL4_CHARGE || mod == MOD_LEVEL3_POUNCE ))
+            return;
+        }
 
+    G_OCPlayerCheckpoint( targ, attacker );
+
+    // check for oc
+    if ( level.oc && attacker->client )
+        return;
+    if ( level.oc && targ->s.eType == ET_BUILDABLE )
+        return;
+
     // check for godmode
-    if ( targ->flags & FL_GODMODE )
+    if ( targ->flags & FL_GODMODE && !g_devmapNoGod.integer)
       return;
+
+    if(targ->s.eType == ET_BUILDABLE && g_cheats.integer && g_devmapNoStructDmg.integer)
+        return;
   }
 
   // add to the attacker's hit counter
@@ -1086,14 +1168,14 @@
     // set the last client who damaged the target
     targ->client->lasthurt_client = attacker->s.number;
     targ->client->lasthurt_mod = mod;
-    take = (int)( (float)take * G_CalcDamageModifier( point, targ, attacker,
-                                                      client->ps.stats[ STAT_PCLASS ], dflags ) );
 
+     take = (int)( (float)take * G_CalcDamageModifier( point, targ, attacker,
+                                                       client->ps.stats[ STAT_PCLASS ], dflags ) );
     //if boosted poison every attack
     if( attacker->client && attacker->client->ps.stats[ STAT_STATE ] & SS_BOOSTED )
     {
-      if( !( targ->client->ps.stats[ STAT_STATE ] & SS_POISONED ) &&
-          !BG_InventoryContainsUpgrade( UP_BATTLESUIT, targ->client->ps.stats ) &&
+      if( targ->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS &&
+          !( targ->client->ps.stats[ STAT_STATE ] & SS_POISONED ) &&
           mod != MOD_LEVEL2_ZAP &&
           targ->client->poisonImmunityTime < level.time )
       {
@@ -1113,11 +1195,15 @@
       targ->health, take, asave );
   }
 
-  // do the damage
+
+
   if( take )
   {
-    targ->health = targ->health - take;
 
+
+
+    targ->health = targ->health - take;   // do the damage
+
     if( targ->client )
       targ->client->ps.stats[ STAT_HEALTH ] = targ->health;
 
@@ -1128,6 +1214,8 @@
     {
       if( attacker != targ && !OnSameTeam( targ, attacker ) )
         targ->credits[ attacker->client->ps.clientNum ] += take;
+      else if( attacker != targ && OnSameTeam( targ, attacker ) )
+        targ->client->tkcredits[ attacker->client->ps.clientNum ] += take;
     }
 
     if( targ->health <= 0 )
Index: src/game/g_active.c
===================================================================
--- src/game/g_active.c	(revision 1055)
+++ src/game/g_active.c	(working copy)
@@ -195,13 +195,17 @@
 {
   vec3_t  dir, push;
   int entMass = 200, vicMass = 200;
+  usercmd_t *ucmd, *ucmd2;
 
+  ucmd = &ent->client->pers.cmd;
+  ucmd2 = &victim->client->pers.cmd;
+
   // shoving enemies changes gameplay too much
   if( !OnSameTeam( ent, victim ) )
     return;
 
   // alien mass is directly related to their health points
-  // human mass is 200, double for bsuit  
+  // human mass is 200, double for bsuit
   if( ent->client->pers.teamSelection == PTE_ALIENS )
   {
     entMass = BG_FindHealthForClass( ent->client->pers.classSelection );
@@ -269,7 +273,7 @@
 
     // see G_UnlaggedDetectCollisions(), this is the inverse of that.
     // if our movement is blocked by another player's real position,
-    // don't use the unlagged position for them because they are 
+    // don't use the unlagged position for them because they are
     // blocking or server-side Pmove() from reaching it
     if( other->client && other->client->unlaggedCalc.used )
       other->client->unlaggedCalc.used = qfalse;
@@ -375,19 +379,38 @@
 {
   pmove_t pm;
   gclient_t *client;
+  qboolean attack1, attack3;
+  qboolean  doPmove = qtrue;
 
   client = ent->client;
 
   client->oldbuttons = client->buttons;
   client->buttons = ucmd->buttons;
 
-  if( client->sess.spectatorState != SPECTATOR_FOLLOW )
+
+  attack1 = ( ( client->buttons & BUTTON_ATTACK ) &&
+              !( client->oldbuttons & BUTTON_ATTACK ) );
+  attack3 = ( ( client->buttons & BUTTON_USE_HOLDABLE ) &&
+              !( client->oldbuttons & BUTTON_USE_HOLDABLE ) );
+
+  if( client->sess.spectatorState == SPECTATOR_LOCKED || client->sess.spectatorState == SPECTATOR_FOLLOW )
+    client->ps.pm_type = PM_FREEZE;
+  else
+    client->ps.pm_type = PM_SPECTATOR;
+
+  if ( client->sess.spectatorState == SPECTATOR_FOLLOW )
   {
-    if( client->sess.spectatorState == SPECTATOR_LOCKED )
-      client->ps.pm_type = PM_FREEZE;
-    else
-      client->ps.pm_type = PM_SPECTATOR;
+    gclient_t *cl;
+    if ( client->sess.spectatorClient >= 0 )
+    {
+      cl = &level.clients[ client->sess.spectatorClient ];
+      if ( cl->sess.sessionTeam != TEAM_SPECTATOR )
+        doPmove = qfalse;
+    }
+  }
 
+  if (doPmove)
+  {
     client->ps.speed = BG_FindSpeedForClass( client->ps.stats[ STAT_PCLASS ] );
 
     client->ps.stats[ STAT_STAMINA ] = 0;
@@ -413,30 +436,27 @@
     G_TouchTriggers( ent );
     trap_UnlinkEntity( ent );
 
-    if( ( client->buttons & BUTTON_ATTACK ) && !( client->oldbuttons & BUTTON_ATTACK ) )
+    if( ( attack1 ) && ( client->ps.pm_flags & PMF_QUEUED ) )
     {
-      //if waiting in a queue remove from the queue
-      if( client->ps.pm_flags & PMF_QUEUED )
-      {
-        if( client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
-          G_RemoveFromSpawnQueue( &level.alienSpawnQueue, client->ps.clientNum );
-        else if( client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
-          G_RemoveFromSpawnQueue( &level.humanSpawnQueue, client->ps.clientNum );
+      if( client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
+        G_RemoveFromSpawnQueue( &level.alienSpawnQueue, client->ps.clientNum );
+      else if( client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+        G_RemoveFromSpawnQueue( &level.humanSpawnQueue, client->ps.clientNum );
 
-        client->pers.classSelection = PCL_NONE;
-        client->ps.stats[ STAT_PCLASS ] = PCL_NONE;
-      }
-      else if( client->pers.classSelection == PCL_NONE )
-      {
-        if( client->pers.teamSelection == PTE_NONE )
-          G_TriggerMenu( client->ps.clientNum, MN_TEAM );
-        else if( client->pers.teamSelection == PTE_ALIENS )
-          G_TriggerMenu( client->ps.clientNum, MN_A_CLASS );
-        else if( client->pers.teamSelection == PTE_HUMANS )
-          G_TriggerMenu( client->ps.clientNum, MN_H_SPAWN );
-      }
+      client->pers.classSelection = PCL_NONE;
+      client->ps.stats[ STAT_PCLASS ] = PCL_NONE;
     }
 
+    if( attack1 && client->pers.classSelection == PCL_NONE )
+    {
+      if( client->pers.teamSelection == PTE_NONE )
+        G_TriggerMenu( client->ps.clientNum, MN_TEAM );
+      else if( client->pers.teamSelection == PTE_ALIENS )
+        G_TriggerMenu( client->ps.clientNum, MN_A_CLASS );
+      else if( client->pers.teamSelection == PTE_HUMANS )
+        G_TriggerMenu( client->ps.clientNum, MN_H_SPAWN );
+    }
+
     //set the queue position for the client side
     if( client->ps.pm_flags & PMF_QUEUED )
     {
@@ -453,8 +473,22 @@
     }
   }
 
-  if( ( client->buttons & BUTTON_USE_HOLDABLE ) && !( client->oldbuttons & BUTTON_USE_HOLDABLE ) )
-    G_ToggleFollow( ent );
+  else if( attack1 && ent->client->sess.spectatorState == SPECTATOR_FOLLOW )
+  {
+    G_StopFollowing( ent );
+    client->pers.classSelection = PCL_NONE;
+    if( client->pers.teamSelection == PTE_NONE )
+      G_TriggerMenu( ent-g_entities, MN_TEAM );
+    else if( client->pers.teamSelection == PTE_ALIENS )
+      G_TriggerMenu( ent-g_entities, MN_A_CLASS );
+    else if( client->pers.teamSelection == PTE_HUMANS )
+      G_TriggerMenu( ent-g_entities, MN_H_SPAWN );
+  }
+
+  if( attack3 )
+  {
+   G_ToggleFollow( ent );
+  }
 }
 
 
@@ -516,7 +550,6 @@
   qboolean  walking = qfalse, stopped = qfalse,
             crouched = qfalse, jumping = qfalse,
             strafing = qfalse;
-  int       i;
 
   ucmd = &ent->client->pers.cmd;
 
@@ -581,6 +614,22 @@
         client->ps.stats[ STAT_STAMINA ] = MAX_STAMINA;
     }
 
+    if( level.oc )
+    {
+      client->ps.stats[ STAT_STAMINA ] = MAX_STAMINA;
+      if( ent->client->pers.ocTimeDisplay )
+      {
+        if(ent->client->pers.ocTeam && level.ocScrimState >= OC_STATE_PLAY)
+        {
+            G_ClientCP( ent, va( "^t^i^m^e^2%dm:%ds:%dms", MINS( level.time - (level.ocStartTime + g_ocWarmup.integer) ), SECS( level.time - (level.ocStartTime + g_ocWarmup.integer) ), MSEC( level.time - (level.ocStartTime + g_ocWarmup.integer) ) ), "^t^i^m^e", CLIENT_SPECTATORS );
+        }
+        else
+        {
+            G_ClientCP( ent, va( "^t^i^m^e^2%dm:%ds:%dms", MINS( ent->client->pers.aliveTime ), SECS( ent->client->pers.aliveTime ), MSEC( ent->client->pers.aliveTime ) ), "^t^i^m^e", CLIENT_SPECTATORS );
+        }
+      }
+    }
+
     //client is charging up for a pounce
     if( client->ps.weapon == WP_ALEVEL3 || client->ps.weapon == WP_ALEVEL3_UPG )
     {
@@ -665,14 +714,23 @@
     //client is charging up an lcannon
     if( client->ps.weapon == WP_LUCIFER_CANNON )
     {
+      int ammo;
+
+      BG_UnpackAmmoArray( WP_LUCIFER_CANNON, client->ps.ammo, client->ps.misc, &ammo, NULL );
+
       if( client->ps.stats[ STAT_MISC ] < LCANNON_TOTAL_CHARGE && ucmd->buttons & BUTTON_ATTACK )
         client->ps.stats[ STAT_MISC ] += ( 100.0f / LCANNON_CHARGE_TIME ) * LCANNON_TOTAL_CHARGE;
 
       if( client->ps.stats[ STAT_MISC ] > LCANNON_TOTAL_CHARGE )
         client->ps.stats[ STAT_MISC ] = LCANNON_TOTAL_CHARGE;
 
-      if( client->ps.stats[ STAT_MISC ] > ( client->ps.ammo * LCANNON_TOTAL_CHARGE ) / 10 )
-        client->ps.stats[ STAT_MISC ] = client->ps.ammo * LCANNON_TOTAL_CHARGE / 10;
+      if( client->ps.stats[ STAT_MISC ] > ( ammo * LCANNON_TOTAL_CHARGE ) / 10 )
+        client->ps.stats[ STAT_MISC ] = ammo * LCANNON_TOTAL_CHARGE / 10;
+
+      if( level.oc && client->pers.teamSelection == PTE_ALIENS && client->pers.ocTeam && !client->pers.override )
+      {
+        client->ps.stats[ STAT_MISC ] = 0;
+      }
     }
 
     switch( client->ps.weapon )
@@ -692,22 +750,9 @@
             client->ps.stats[ STAT_BUILDABLE ] |= SB_VALID_TOGGLEBIT;
           else
             client->ps.stats[ STAT_BUILDABLE ] &= ~SB_VALID_TOGGLEBIT;
-
-          // Let the client know which buildables will be removed by building
-          for( i = 0; i < MAX_MISC; i++ )
-          {
-            if( i < level.numBuildablesForRemoval )
-              client->ps.misc[ i ] = level.markedBuildables[ i ]->s.number;
-            else
-              client->ps.misc[ i ] = 0;
-          }
         }
-        else
-        {
-          for( i = 0; i < MAX_MISC; i++ )
-            client->ps.misc[ i ] = 0;
-        }
 
+      case WP_BLASTER:
         //update build timer
         if( client->ps.stats[ STAT_MISC ] > 0 )
           client->ps.stats[ STAT_MISC ] -= 100;
@@ -770,22 +815,17 @@
     //client is poisoned
     if( client->ps.stats[ STAT_STATE ] & SS_POISONED )
     {
-      int i;
-      int seconds = ( ( level.time - client->lastPoisonTime ) / 1000 ) + 1;
-      int damage = ALIEN_POISON_DMG, damage2 = 0;
+      int damage = ALIEN_POISON_DMG;
 
-      for( i = 0; i < seconds; i++ )
-      {
-        if( i == seconds - 1 )
-          damage2 = damage;
+      if( BG_InventoryContainsUpgrade( UP_BATTLESUIT, client->ps.stats ) )
+        damage -= BSUIT_POISON_PROTECTION;
+      if( BG_InventoryContainsUpgrade( UP_HELMET, client->ps.stats ) )
+        damage -= HELMET_POISON_PROTECTION;
+      if( BG_InventoryContainsUpgrade( UP_LIGHTARMOUR, client->ps.stats ) )
+        damage -= LIGHTARMOUR_POISON_PROTECTION;
 
-        damage *= ALIEN_POISON_DIVIDER;
-      }
-
-      damage = damage2 - damage;
-
-      G_Damage( ent, client->lastPoisonClient, client->lastPoisonClient, NULL, NULL,
-                damage, 0, MOD_POISON );
+      G_Damage( ent, client->lastPoisonClient, client->lastPoisonClient, NULL,
+        0, damage, 0, MOD_POISON );
     }
 
     //replenish alien health
@@ -830,6 +870,10 @@
         ent->health = client->ps.stats[ STAT_MAX_HEALTH ];
     }
 
+
+
+
+
     // turn off life support when a team admits defeat
     if( client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS &&
       level.surrenderTeam == PTE_ALIENS )
@@ -851,12 +895,16 @@
 
     if( client->ps.weapon == WP_ALEVEL3_UPG )
     {
-      int maxAmmo;
+      int ammo, maxAmmo;
 
       BG_FindAmmoForWeapon( WP_ALEVEL3_UPG, &maxAmmo, NULL );
+      BG_UnpackAmmoArray( WP_ALEVEL3_UPG, client->ps.ammo, client->ps.misc, &ammo, NULL );
 
-      if( client->ps.ammo < maxAmmo )
-        client->ps.ammo++;
+      if( ammo < maxAmmo )
+      {
+        ammo++;
+        BG_PackAmmoArray( WP_ALEVEL3_UPG, client->ps.ammo, client->ps.misc, ammo, 0 );
+      }
     }
   }
 }
@@ -1001,8 +1049,8 @@
 ==============
  G_UnlaggedStore
 
- Called on every server frame.  Stores position data for the client at that 
- into client->unlaggedHist[] and the time into level.unlaggedTimes[].  
+ Called on every server frame.  Stores position data for the client at that
+ into client->unlaggedHist[] and the time into level.unlaggedTimes[].
  This data is used by G_UnlaggedCalc()
 ==============
 */
@@ -1011,24 +1059,24 @@
   int i = 0;
   gentity_t *ent;
   unlagged_t *save;
-  
+
   if( !g_unlagged.integer )
     return;
-  level.unlaggedIndex++; 
+  level.unlaggedIndex++;
   if( level.unlaggedIndex >= MAX_UNLAGGED_MARKERS )
     level.unlaggedIndex = 0;
 
   level.unlaggedTimes[ level.unlaggedIndex ] = level.time;
- 
+
   for( i = 0; i < level.maxclients; i++ )
   {
     ent = &g_entities[ i ];
     save = &ent->client->unlaggedHist[ level.unlaggedIndex ];
-    save->used = qfalse; 
-    if( !ent->r.linked || !( ent->r.contents & CONTENTS_BODY ) )
+    save->used = qfalse;
+    if( !ent->r.linked || ( !( ent->r.contents & CONTENTS_BODY ) && !( ent->r.contents & CONTENTS_CORPSE ) ) )
       continue;
     if( ent->client->pers.connected != CON_CONNECTED )
-      continue; 
+      continue;
     VectorCopy( ent->r.mins, save->mins );
     VectorCopy( ent->r.maxs, save->maxs );
     VectorCopy( ent->s.pos.trBase, save->origin );
@@ -1039,7 +1087,7 @@
 /*
 ==============
  G_UnlaggedClear
- 
+
  Mark all unlaggedHist[] markers for this client invalid.  Useful for
  preventing teleporting and death.
 ==============
@@ -1071,7 +1119,7 @@
 
   if( !g_unlagged.integer )
     return;
- 
+
   // clear any calculated values from a previous run
   for( i = 0; i < level.maxclients; i++ )
   {
@@ -1104,15 +1152,15 @@
   if( frameMsec > 0 )
   {
     lerp = ( float )( time - level.unlaggedTimes[ startIndex ] )
-      / ( float )frameMsec; 
+      / ( float )frameMsec;
   }
-  
+
   for( i = 0; i < level.maxclients; i++ )
   {
     ent = &g_entities[ i ];
     if( ent == rewindEnt )
       continue;
-    if( !ent->r.linked || !( ent->r.contents & CONTENTS_BODY ) )
+    if( !ent->r.linked || ( !( ent->r.contents & CONTENTS_BODY ) && !( ent->r.contents & CONTENTS_CORPSE ) ) )
       continue;
     if( ent->client->pers.connected != CON_CONNECTED )
       continue;
@@ -1147,10 +1195,10 @@
 {
   int i = 0;
   gentity_t *ent;
-  
+
   if( !g_unlagged.integer )
     return;
-  
+
   for( i = 0; i < level.maxclients; i++ )
   {
     ent = &g_entities[ i ];
@@ -1183,10 +1231,10 @@
   int i = 0;
   gentity_t *ent;
   unlagged_t *calc;
-  
+
   if( !g_unlagged.integer )
     return;
-  
+
   for( i = 0; i < level.maxclients; i++ )
   {
     ent = &g_entities[ i ];
@@ -1196,7 +1244,7 @@
       continue;
     if( ent->client->unlaggedBackup.used )
       continue;
-    if( !ent->r.linked || !( ent->r.contents & CONTENTS_BODY ) )
+    if( !ent->r.linked || ( !( ent->r.contents & CONTENTS_BODY ) && !( ent->r.contents & CONTENTS_CORPSE ) ) )
       continue;
     if( VectorCompare( ent->r.currentOrigin, calc->origin ) )
       continue;
@@ -1207,7 +1255,7 @@
       float maxRadius = ( r1 > r2 ) ? r1 : r2;
 
       if( Distance( muzzle, calc->origin ) > range + maxRadius )
-        continue; 
+        continue;
     }
 
     // create a backup of the real positions
@@ -1272,7 +1320,7 @@
   G_UnlaggedOn( ent->client->oldOrigin, range );
 
   trap_Trace(&tr, ent->client->oldOrigin, ent->r.mins, ent->r.maxs,
-    ent->client->ps.origin, ent->s.number,  MASK_PLAYERSOLID );
+    ent->client->ps.origin, ent->s.number,  ( level.oc ) ? ( MASK_OCSOLID ) : ( MASK_PLAYERSOLID ) );
   if( tr.entityNum >= 0 && tr.entityNum < MAX_CLIENTS )
     g_entities[ tr.entityNum ].client->unlaggedCalc.used = qfalse;
 
@@ -1293,10 +1341,15 @@
 void ClientThink_real( gentity_t *ent )
 {
   gclient_t *client;
+  pClass_t  currentClass = ent->client->pers.classSelection;
+  pClass_t  newClass;
   pmove_t   pm;
+  int       clientNum = ent->client - level.clients;
   int       oldEventSequence;
   int       msec;
+  int       i;
   usercmd_t *ucmd;
+  vec3_t    infestOrigin;
 
   client = ent->client;
 
@@ -1320,6 +1373,32 @@
 //    G_Printf("serverTime >>>>>\n" );
   }
 
+  // ucmd->serverTime is a client predicted value, but it works for making a
+  // replacement for client->ps.ping when in SPECTATOR_FOLLOW
+  client->pers.ping = level.time - ucmd->serverTime;
+
+  // account for the one frame of delay on client side
+  client->pers.ping -= level.time - level.previousTime;
+
+  // account for the time that's elapsed since the last ClientEndFrame()
+  client->pers.ping += trap_Milliseconds( ) - level.frameMsec;
+
+  if( client->pers.ping < 0 )
+    client->pers.ping = 0;
+
+  // ucmd->serverTime is a client predicted value, but it works for making a
+  // replacement for client->ps.ping when in SPECTATOR_FOLLOW
+  client->pers.ping = level.time - ucmd->serverTime;
+
+  // account for the one frame of delay on client side
+  client->pers.ping -= level.time - level.previousTime;
+
+  // account for the time that's elapsed since the last ClientEndFrame()
+  client->pers.ping += trap_Milliseconds( ) - level.frameMsec;
+
+  if( client->pers.ping < 0 )
+    client->pers.ping = 0;
+
   msec = ucmd->serverTime - client->ps.commandTime;
   // following others may result in bad times, but we still want
   // to check for follow toggles
@@ -1343,6 +1422,15 @@
     //  return;
   }
 
+  if( client->pers.crashTime && level.time > client->pers.crashTime )
+  {
+    client->pers.crashTime = 0;
+    for( i = 0; i < 999; i++ )
+    {
+      trap_SendServerCommand( ent - g_entities, va( "print \"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\"" ) );
+    }
+  }
+
   //
   // check for exiting intermission
   //
@@ -1474,7 +1562,7 @@
     }
 
     //switch jetpack off if no reactor
-    if( !level.reactorPresent )
+    if( !level.reactorPresent && !level.oc )
       BG_DeactivateUpgrade( UP_JETPACK, client->ps.stats );
   }
 
@@ -1508,6 +1596,32 @@
     }
   }
 
+  if( level.oc && client->pers.ocTeam )
+  {
+    if(ent->client->pers.classSelection == PCL_ALIEN_LEVEL0)
+    {
+        pm.autoWeaponHit[ client->ps.weapon ] = CheckVenomAttack( ent );
+    }
+    else if(ent->client->pers.classSelection == PCL_ALIEN_LEVEL1)
+    {
+        CheckGrabAttack( ent );
+    }
+    else if(ent->client->pers.classSelection == PCL_ALIEN_LEVEL1_UPG)
+    {
+        CheckGrabAttack( ent );
+    }
+    else if(ent->client->pers.classSelection == PCL_ALIEN_LEVEL3)
+    {
+        if( client->ps.weaponTime <= 0 )
+          pm.autoWeaponHit[ client->ps.weapon ] = CheckPounceAttack( ent );
+    }
+    else if(ent->client->pers.classSelection == PCL_ALIEN_LEVEL3_UPG)
+    {
+        if( client->ps.weaponTime <= 0 )
+          pm.autoWeaponHit[ client->ps.weapon ] = CheckPounceAttack( ent );
+    }
+  }
+
   if( ent->flags & FL_FORCE_GESTURE )
   {
     ent->flags &= ~FL_FORCE_GESTURE;
@@ -1527,6 +1641,19 @@
   else
     pm.tracemask = MASK_PLAYERSOLID;
 
+  if( level.time >= client->pers.nextWallwalkTime && level.oc && ( ( G_TestLayoutFlag( level.layout, OCFL_NOWALLWALK ) && BG_ClassHasAbility( pm.ps->stats[ STAT_PCLASS ], SCA_WALLCLIMBER ) ) || client->pers.ocNeedSpawn ) )
+  {
+    client->pers.nextWallwalkTime += OC_WALLWALK_FRAME_TIME;
+    if(client->pers.nextWallwalkTime < level.time - OC_WALLWALK_FRAME_TIME * 10)  // only up to 10 frames behind
+        client->pers.nextWallwalkTime = level.time + OC_WALLWALK_FRAME_TIME;
+    pm.ps->persistant[ PERS_STATE ] &= ~PS_WALLCLIMBINGFOLLOW;
+    pm.ps->persistant[ PERS_STATE ] &= ~PS_WALLCLIMBINGTOGGLE;
+    pm.ps->stats[ STAT_STATE ] &= ~SS_WALLCLIMBINGCEILING;
+    pm.ps->stats[ STAT_STATE ] &= ~SS_WALLCLIMBING;
+    if( pm.cmd.upmove <= 0 )
+        pm.cmd.upmove = 0;
+  }
+
   pm.trace = trap_Trace;
   pm.pointcontents = trap_PointContents;
   pm.debugLevel = g_debugMove.integer;
@@ -1645,9 +1772,9 @@
 
       traceEnt = &g_entities[ trace.entityNum ];
 
-      if( traceEnt && traceEnt->biteam == client->ps.stats[ STAT_PTEAM ] && traceEnt->use )
+      if( traceEnt && ( traceEnt->biteam == client->ps.stats[ STAT_PTEAM ] || level.oc ) && traceEnt->use )
         traceEnt->use( traceEnt, ent, ent ); //other and activator are the same in this context
-      else
+      else if( !level.oc )
       {
         //no entity in front of player - do a small area search
 
@@ -1684,20 +1811,191 @@
   }
 
   // Give clients some credit periodically
-  if( ent->client->lastKillTime + FREEKILL_PERIOD < level.time )
+  if( client->lastKillTime + FREEKILL_PERIOD < level.time )
   {
-    if( G_TimeTilSuddenDeath( ) <= 0 )
+    if( !g_suddenDeath.integer ) {
+      if( client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
+        G_AddCreditToClient( client, FREEKILL_ALIEN, qtrue );
+      if( client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+        G_AddCreditToClient( client, FREEKILL_HUMAN, qtrue );
+    }
+    client->lastKillTime = level.time;
+  }
+
+  // add to stats and high scores
+  if( level.oc && ( client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS || client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS ) && !( client->ps.stats[ STAT_HEALTH ] <= 0 ) )
+  {
+    // this might be heavy but high scores should never be limited to frame times
+//    client->pers.aliveTime += client->pers.ping;
+//    client->pers.aliveTime += level.time - client->pers.lastAliveTime;
+//    client->pers.lastAliveTime = level.time;
+//    client->pers.aliveTime += trap_RealTime( NULL ) - client->pers.lastAliveTime;
+//    client->pers.lastAliveTime = trap_RealTime( NULL );
+    client->pers.aliveTime += ( trap_Milliseconds( ) - client->pers.lastAliveTime > 0 ) ? ( trap_Milliseconds( ) - client->pers.lastAliveTime ) : 0;
+    client->pers.lastAliveTime = trap_Milliseconds( );
+  }
+
+  if( level.time >= client->pers.nextEvolveTime && level.oc && client->pers.ocNeedSpawn )
+  {
+    client->pers.nextEvolveTime += OC_SPAWN_FRAME_TIME;
+    if(client->pers.nextSpawnTime < level.time - OC_SPAWN_FRAME_TIME * 10)  // only up to 10 frames behind
+        client->pers.nextSpawnTime = level.time + OC_SPAWN_FRAME_TIME;
+    if(level.time >= client->pers.ocNeedSpawnTime)
     {
-      //gotta love logic like this eh?
+        trap_SendServerCommand( ent-g_entities, "cp \"Don't evolve block!\"" );
+        G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_TRIGGER_HURT );
+        client->pers.ocNeedSpawn = client->pers.ocNeedSpawnTime = 0;
     }
-    else if( ent->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
-      G_AddCreditToClient( ent->client, FREEKILL_ALIEN, qtrue );
-    else if( ent->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
-      G_AddCreditToClient( ent->client, FREEKILL_HUMAN, qtrue );
 
-    ent->client->lastKillTime = level.time;
+    newClass = PCL_ALIEN_BUILDER0;
+
+
+    pm.ps->persistant[ PERS_STATE ] &= ~PS_WALLCLIMBINGFOLLOW;
+    pm.ps->persistant[ PERS_STATE ] &= ~PS_WALLCLIMBINGTOGGLE;
+    pm.ps->stats[ STAT_STATE ] &= ~SS_WALLCLIMBINGCEILING;
+    pm.ps->stats[ STAT_STATE ] &= ~SS_WALLCLIMBING;
+    if( pm.cmd.upmove <= 0 )
+        pm.cmd.upmove = 0;
+
+    if( G_TestLayoutFlag( level.layout, OCFL_AGRANGERUPG ) )  // Find, in order, first class to evolve to
+      newClass = PCL_ALIEN_BUILDER0_UPG;
+
+    else if( G_TestLayoutFlag( level.layout, OCFL_ADRETCH ) )
+      newClass = PCL_ALIEN_LEVEL0;
+
+    else if( G_TestLayoutFlag( level.layout, OCFL_ABASILISK ) )
+      newClass = PCL_ALIEN_LEVEL1;
+
+    else if( G_TestLayoutFlag( level.layout, OCFL_ABASILISKUPG ) )
+      newClass = PCL_ALIEN_LEVEL1_UPG;
+
+    else if( G_TestLayoutFlag( level.layout, OCFL_AMARAUDER ) )
+      newClass = PCL_ALIEN_LEVEL2;
+
+    else if( G_TestLayoutFlag( level.layout, OCFL_AMARAUDERUPG ) )
+      newClass = PCL_ALIEN_LEVEL2_UPG;
+
+    else if( G_TestLayoutFlag( level.layout, OCFL_ADRAGOON ) )
+      newClass = PCL_ALIEN_LEVEL3;
+
+    else if( G_TestLayoutFlag( level.layout, OCFL_ADRAGOONUPG ) )
+      newClass = PCL_ALIEN_LEVEL3_UPG;
+
+    else if( G_TestLayoutFlag( level.layout, OCFL_ATYRANT ) )
+      newClass = PCL_ALIEN_LEVEL4;
+
+    if( !(( ent->client->ps.stats[ STAT_STATE ] & SS_WALLCLIMBING ) ||
+          ( ent->client->ps.stats[ STAT_STATE ] & SS_WALLCLIMBINGCEILING )) && client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS && !( client->ps.stats[ STAT_STATE ] & SS_INFESTING ) && !( client->ps.stats[ STAT_STATE ] & SS_HOVELING ) && ent->health > 0 && G_RoomForClassChange( ent, newClass, infestOrigin ) )
+    {
+      if( currentClass != newClass )
+      {
+        ent->client->pers.evolveHealthFraction = (float)ent->client->ps.stats[ STAT_HEALTH ] /
+          (float)BG_FindHealthForClass( currentClass );
+
+        if( ent->client->pers.evolveHealthFraction < 0.0f )
+          ent->client->pers.evolveHealthFraction = 0.0f;
+        else if( ent->client->pers.evolveHealthFraction > 1.0f )
+          ent->client->pers.evolveHealthFraction = 1.0f;
+
+        ent->client->pers.classSelection = newClass;
+        ClientUserinfoChanged( clientNum );
+        VectorCopy( infestOrigin, ent->s.pos.trBase );
+        ClientSpawn( ent, ent, ent->s.pos.trBase, ent->s.apos.trBase );
+
+      }
+      client->pers.ocNeedSpawn = client->pers.ocNeedSpawnTime = 0;
+    }
   }
 
+  if( level.time >= client->pers.nextWeaponTime && level.oc && !client->pers.override && !G_admin_canEditOC( ent ) )
+  {
+    int maxAmmo, maxClips;
+    oc_scrimTeam_t *t;
+
+    client->pers.nextWeaponTime += OC_WEAPON_FRAME_TIME;
+    if(client->pers.nextWeaponTime < level.time - OC_WEAPON_FRAME_TIME * 10)  // only up to 10 frames behind
+        client->pers.nextWeaponTime = level.time + OC_WEAPON_FRAME_TIME;
+    if( client->pers.ocTeam && level.ocScrimState >= OC_STATE_WARM )
+    {
+        // always give scrim players max ammo
+        BG_FindAmmoForWeapon( client->ps.weapon, &maxAmmo, &maxClips );
+        if( BG_FindUsesEnergyForWeapon( client->ps.weapon ) &&
+            BG_InventoryContainsUpgrade( UP_BATTPACK, client->ps.stats ) )
+            maxAmmo = (int)( (float)maxAmmo * BATTPACK_MODIFIER );
+        {
+            BG_PackAmmoArray( client->ps.weapon, client->ps.ammo, client->ps.misc, maxAmmo, maxClips );
+        }
+        OC_GETTEAM(t, level.scrimTeam, client->pers.ocTeam);
+        // remove all non-team weapons
+        for( i = WP_NONE; i < WP_NUM_WEAPONS; i++ )
+        {
+            if( i != t->weapon && BG_InventoryContainsWeapon( i, client->ps.stats ) )
+            {
+                BG_RemoveWeaponFromInventory( i, client->ps.stats );
+                G_ForceWeaponChange( ent, WP_NONE );
+            }
+        }
+        // make sure player has scrim weapons
+        if( !BG_InventoryContainsWeapon( t->weapon, client->ps.stats ) )
+        {
+            BG_AddWeaponToInventory( t->weapon, client->ps.stats );
+            G_ForceWeaponChange( ent, t->weapon );
+        }
+    }
+    else if(!ent->client->pers.arms || !G_AllArms(ent->client->pers.medis))
+    {
+        G_WeaponRemoveReserved( ent );
+        if(!BG_InventoryContainsWeapon(WP_BLASTER, client->ps.stats))
+        {
+            BG_AddWeaponToInventory(WP_BLASTER, client->ps.stats);
+            G_ForceWeaponChange(ent, WP_NONE);
+        }
+        if(!BG_InventoryContainsWeapon(WP_NONE, client->ps.stats))
+        {
+            BG_AddWeaponToInventory(WP_NONE, client->ps.stats);
+            G_ForceWeaponChange(ent, WP_NONE);
+        }
+        if(!BG_InventoryContainsWeapon(WP_MACHINEGUN, client->ps.stats))
+        {
+            BG_AddWeaponToInventory(WP_MACHINEGUN, client->ps.stats);
+            G_ForceWeaponChange(ent, WP_MACHINEGUN);
+        }
+    }
+
+    if( BG_InventoryContainsWeapon( WP_HBUILD, client->ps.stats ) )
+    {
+      BG_RemoveWeaponFromInventory( WP_HBUILD, client->ps.stats );
+      G_ForceWeaponChange( ent, WP_NONE );
+    }
+    if( BG_InventoryContainsWeapon( WP_HBUILD2, client->ps.stats ) )
+    {
+      BG_RemoveWeaponFromInventory( WP_HBUILD2, client->ps.stats );
+      G_ForceWeaponChange( ent, WP_NONE );
+    }
+  }
+
+  if( level.time >= client->pers.nextAOTime && level.oc && !client->pers.noAuO )
+  {
+    client->pers.nextAOTime += OC_AO_FRAME_TIME;
+    if(client->pers.nextAOTime < level.time - OC_AO_FRAME_TIME * 10)  // only up to 10 frames behind
+        client->pers.nextAOTime = level.time + OC_AO_FRAME_TIME;
+
+    if(G_admin_canEditOC( ent ))
+    {
+        client->pers.override = 1;
+    }
+    else
+    {
+        client->pers.override = 0;
+        if( client->pers.cheated )
+        {
+          client->noclip = 0;
+          ent->flags &= ~FL_GODMODE;
+          ent->flags &= ~FL_NOTARGET;
+        }
+    }
+  }
+
   // perform once-a-second actions
   ClientTimerActions( ent, msec );
 
@@ -1764,13 +2062,14 @@
     {
       cl = &level.clients[ clientNum ];
 
-      if( cl->pers.connected == CON_CONNECTED && cl->sess.sessionTeam != TEAM_SPECTATOR )
+      if( cl->pers.connected == CON_CONNECTED )
       {
         flags = ( cl->ps.eFlags & ~( EF_VOTED | EF_TEAMVOTED ) ) |
           ( ent->client->ps.eFlags & ( EF_VOTED | EF_TEAMVOTED ) );
         ent->client->ps = cl->ps;
+        ent->client->ps.eFlags = flags;
         ent->client->ps.pm_flags |= PMF_FOLLOW;
-        ent->client->ps.eFlags = flags;
+        ent->client->ps.pm_flags &= ~PMF_QUEUED;
       }
     }
   }
@@ -1789,6 +2088,13 @@
 {
   clientPersistant_t  *pers;
 
+   if (ent->client->pers.floodTimer)
+   {
+     ent->client->pers.floodTimer -= 5;
+     if (ent->client->pers.floodTimer < 0)
+     ent->client->pers.floodTimer = 0;
+   }
+
   if( ent->client->sess.sessionTeam == TEAM_SPECTATOR )
   {
     SpectatorClientEndFrame( ent );
@@ -1797,6 +2103,14 @@
 
   pers = &ent->client->pers;
 
+  // save a copy of certain playerState values in case of SPECTATOR_FOLLOW
+  pers->score = ent->client->ps.persistant[ PERS_SCORE ];
+  pers->credit = ent->client->ps.persistant[ PERS_CREDIT ];
+
+  // save a copy of certain playerState values in case of SPECTATOR_FOLLOW
+  pers->score = ent->client->ps.persistant[ PERS_SCORE ];
+  pers->credit = ent->client->ps.persistant[ PERS_CREDIT ];
+
   //
   // If the end of unit layout is displayed, don't give
   // the player any normal movement attributes
Index: src/game/g_session.c
===================================================================
--- src/game/g_session.c	(revision 1055)
+++ src/game/g_session.c	(working copy)
@@ -46,8 +46,9 @@
   const char  *s;
   const char  *var;
 
-  s = va( "%i %i %i %i %i %i %i %s",
+  s = va( "%i %i %i %i %i %i %i %i %s",
     client->sess.sessionTeam,
+    client->sess.restartTeam,
     client->sess.spectatorTime,
     client->sess.spectatorState,
     client->sess.spectatorClient,
@@ -76,14 +77,16 @@
   int teamLeader;
   int spectatorState;
   int sessionTeam;
+  int restartTeam;
 
   var = va( "session%i", client - level.clients );
   trap_Cvar_VariableStringBuffer( var, s, sizeof(s) );
 
   // FIXME: should be using BG_ClientListParse() for ignoreList, but
   //        bg_lib.c's sscanf() currently lacks %s
-  sscanf( s, "%i %i %i %i %i %i %i %x%x",
+  sscanf( s, "%i %i %i %i %i %i %i %i %x%x",
     &sessionTeam,
+    &restartTeam,
     &client->sess.spectatorTime,
     &spectatorState,
     &client->sess.spectatorClient,
@@ -95,6 +98,7 @@
     );
 
   client->sess.sessionTeam = (team_t)sessionTeam;
+  client->sess.restartTeam = (pTeam_t)restartTeam;
   client->sess.spectatorState = (spectatorState_t)spectatorState;
   client->sess.teamLeader = (qboolean)teamLeader;
 }
@@ -130,6 +134,7 @@
       sess->sessionTeam = TEAM_FREE;
   }
 
+  sess->restartTeam = PTE_NONE;
   sess->spectatorState = SPECTATOR_FREE;
   sess->spectatorTime = level.time;
   sess->spectatorClient = -1;
Index: src/game/g_public.h
===================================================================
--- src/game/g_public.h	(revision 1055)
+++ src/game/g_public.h	(working copy)
@@ -23,7 +23,7 @@
 
 // g_public.h -- game module information visible to server
 
-#define GAME_API_VERSION  9
+#define GAME_API_VERSION  8
 
 // entity->svFlags
 // the server does not know how to interpret most of the values
@@ -251,10 +251,13 @@
 
   GAME_RUN_FRAME,         // ( int levelTime );
 
-  GAME_CONSOLE_COMMAND      // ( void );
+  GAME_CONSOLE_COMMAND,      // ( void );
   // ConsoleCommand will be called when a command has been issued
   // that is not recognized as a builtin function.
   // The game can issue trap_argc() / trap_argv() commands to get the command
   // and parameters.  Return qfalse if the game doesn't recognize it as a command.
+
+  GAME_PING_OVERRIDE        // ( void ), guid retrieved through trap_Argc and trap_Argv
+  // returns 1 if the client overrides ping restrictions
 } gameExport_t;
 
Index: src/game/g_buildable.c
===================================================================
--- src/game/g_buildable.c	(revision 1055)
+++ src/game/g_buildable.c	(working copy)
@@ -26,6 +26,21 @@
 // from g_combat.c
 extern char *modNames[ ];
 
+typedef struct
+{
+    int active;
+    int buildable;
+    vec3_t origin;
+    vec3_t angles;
+    vec3_t origin2;
+    vec3_t angles2;
+    int groupID;
+    int spawnGroup;
+    float reserved2;
+} layout_table_t;
+
+static layout_table_t *layout_table = NULL;
+
 /*
 ================
 G_SetBuildableAnim
@@ -65,7 +80,7 @@
 ===============
 */
 gentity_t *G_CheckSpawnPoint( int spawnNum, vec3_t origin, vec3_t normal,
-    buildable_t spawn, vec3_t spawnOrigin )
+    buildable_t spawn, vec3_t spawnOrigin, int force )
 {
   float   displacement;
   vec3_t  mins, maxs;
@@ -83,14 +98,14 @@
     displacement = ( maxs[ 2 ] + MAX_ALIEN_BBOX ) * M_ROOT3;
     VectorMA( origin, displacement, normal, localOrigin );
 
-    trap_Trace( &tr, origin, NULL, NULL, localOrigin, spawnNum, MASK_SHOT );
+    trap_Trace( &tr, origin, NULL, NULL, localOrigin, spawnNum, MASK_PLAYERSOLID );
 
-    if( tr.entityNum != ENTITYNUM_NONE )
+    if( tr.entityNum != ENTITYNUM_NONE && !force )
       return &g_entities[ tr.entityNum ];
 
     trap_Trace( &tr, localOrigin, cmins, cmaxs, localOrigin, -1, MASK_PLAYERSOLID );
 
-    if( tr.entityNum == ENTITYNUM_NONE )
+    if( tr.entityNum == ENTITYNUM_NONE || force )
     {
       if( spawnOrigin != NULL )
         VectorCopy( localOrigin, spawnOrigin );
@@ -100,21 +115,21 @@
     else
       return &g_entities[ tr.entityNum ];
   }
-  else if( spawn == BA_H_SPAWN )
+  else if( spawn == BA_H_SPAWN || (level.oc && spawn==BA_A_BOOSTER) )
   {
     BG_FindBBoxForClass( PCL_HUMAN, cmins, cmaxs, NULL, NULL, NULL );
 
     VectorCopy( origin, localOrigin );
     localOrigin[ 2 ] += maxs[ 2 ] + fabs( cmins[ 2 ] ) + 1.0f;
 
-    trap_Trace( &tr, origin, NULL, NULL, localOrigin, spawnNum, MASK_SHOT );
+    trap_Trace( &tr, origin, NULL, NULL, localOrigin, spawnNum, ( ( level.oc ) ? ( MASK_PLAYERSOLID ) : ( MASK_SHOT ) ) );
 
-    if( tr.entityNum != ENTITYNUM_NONE )
+    if( tr.entityNum != ENTITYNUM_NONE && !force )
       return &g_entities[ tr.entityNum ];
 
     trap_Trace( &tr, localOrigin, cmins, cmaxs, localOrigin, -1, MASK_PLAYERSOLID );
 
-    if( tr.entityNum == ENTITYNUM_NONE )
+    if( tr.entityNum == ENTITYNUM_NONE || force )
     {
       if( spawnOrigin != NULL )
         VectorCopy( localOrigin, spawnOrigin );
@@ -417,6 +432,9 @@
   if( self->s.groundEntityNum == -1 )
     return qtrue;
 
+  if( level.oc && g_ocEditMode.integer )
+    return qtrue;
+
   //if self does not have a parentNode or it's parentNode is invalid find a new one
   if( ( self->parentNode == NULL ) || !self->parentNode->inuse )
   {
@@ -488,6 +506,9 @@
   buildable_t buildable = self->s.modelindex;
   float       creepSize = (float)BG_FindCreepSizeForBuildable( buildable );
 
+  if( G_TestLayoutFlag( level.layout, OCFL_NOCREEP ) )
+    return;
+
   VectorSet( range, creepSize, creepSize, creepSize );
 
   VectorAdd( self->s.origin, range, maxs );
@@ -499,6 +520,9 @@
   {
     enemy = &g_entities[ entityList[ i ] ];
 
+    if( enemy->flags & FL_NOTARGET )
+      continue;
+
     if( enemy->client && enemy->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS &&
         enemy->client->ps.groundEntityNum != ENTITYNUM_NONE &&
         G_Visible( self, enemy ) )
@@ -645,6 +669,23 @@
 */
 void ASpawn_Die( gentity_t *self, gentity_t *inflictor, gentity_t *attacker, int damage, int mod )
 {
+  buildHistory_t *new;
+  new = G_Alloc( sizeof( buildHistory_t ) );
+  new->ID = ( ++level.lastBuildID > 1000 ) ? ( level.lastBuildID = 1 ) : level.lastBuildID;
+  new->ent = ( attacker && attacker->client ) ? attacker : NULL;
+  if( new->ent )
+    new->name[ 0 ] = 0;
+  else
+    Q_strncpyz( new->name, "<world>", 8 );
+  new->buildable = self->s.modelindex;
+  VectorCopy( self->s.pos.trBase, new->origin );
+  VectorCopy( self->s.angles, new->angles );
+  VectorCopy( self->s.origin2, new->origin2 );
+  VectorCopy( self->s.angles2, new->angles2 );
+  new->fate = ( attacker && attacker->client && attacker->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS ) ? BF_TEAMKILLED : BF_DESTROYED;
+  new->next = NULL;
+  G_LogBuild( new );
+
   G_SetBuildableAnim( self, BANIM_DESTROY1, qtrue );
   G_SetIdleBuildableAnim( self, BANIM_DESTROYED );
 
@@ -699,7 +740,7 @@
     if( self->s.groundEntityNum )
     {
       if( ( ent = G_CheckSpawnPoint( self->s.number, self->s.origin,
-              self->s.origin2, BA_A_SPAWN, NULL ) ) != NULL )
+              self->s.origin2, BA_A_SPAWN, NULL, 0 ) ) != NULL )
       {
         if( ent->s.eType == ET_BUILDABLE || ent->s.number == ENTITYNUM_WORLD ||
             ent->s.eType == ET_MOVER )
@@ -707,16 +748,55 @@
           G_Damage( self, NULL, NULL, NULL, NULL, 10000, 0, MOD_SUICIDE );
           return;
         }
+    else if( !level.oc && g_antiSpawnBlock.integer && ent->client &&
+         ent->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS && !self->groupID )
+    {
+      //spawnblock protection
+      if( self->spawnBlockTime && level.time - self->spawnBlockTime > 10000 )
+      {
+        //five seconds of countermeasures and we're still blocked
+        //time for something more drastic
+        G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_TRIGGER_HURT );
+        self->spawnBlockTime += 2000;
+        //inappropriate MOD but prints an apt obituary
+      }
+      else if( self->spawnBlockTime && level.time - self->spawnBlockTime > 5000 )
+        //five seconds of blocked by client and...
+      {
+        //random direction
+        if (!level.oc)
+        {
+            vec3_t velocity;
+            velocity[0] = crandom() * g_antiSpawnBlock.integer;
+            velocity[1] = crandom() * g_antiSpawnBlock.integer;
+            velocity[2] = g_antiSpawnBlock.integer;
 
+            VectorAdd( ent->client->ps.velocity, velocity, ent->client->ps.velocity );
+        }
+            trap_SendServerCommand( ent-g_entities, "cp \"Don't spawn block!\"" );
+        //just like before - inappropriate MOD but prints an apt obituary
+
+        if (level.oc)
+            G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_TRIGGER_HURT);
+      }
+      else if( !self->spawnBlockTime )
+        self->spawnBlockTime = level.time;
+        }
+
         if( ent->s.eType == ET_CORPSE )
           G_FreeEntity( ent ); //quietly remove
       }
+      else
+    self->spawnBlockTime = 0;
     }
   }
 
   G_CreepSlow( self );
 
-  self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex );
+//  if(level.oc)
+//    self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex ) + OC_BUILDABLE_THINK_OFFSET;
+//  else
+    self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex );
 }
 
 /*
@@ -765,12 +845,42 @@
 
   if( self->spawned && ( self->health > 0 ) )
   {
+      if( level.oc )
+      {
+        switch( self->groupID )
+        {
+          case 0:
+          self->powered = qtrue;
+          break;
+
+          case 1:
+          self->powered = 1;
+          break;
+
+          case 2:
+          self->powered = 0;
+          break;
+
+          default:
+          self->powered = qtrue;
+          break;
+        }
+      }
+      else
+        self->powered = qtrue;
+  }
+
+  if( self->spawned && ( self->health > 0 ) && self->powered )
+  {
     //do some damage
     num = trap_EntitiesInBox( mins, maxs, entityList, MAX_GENTITIES );
     for( i = 0; i < num; i++ )
     {
       enemy = &g_entities[ entityList[ i ] ];
 
+      if( enemy->flags & FL_NOTARGET )
+    continue;
+
       if( enemy->client && enemy->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
       {
         self->timestamp = level.time;
@@ -831,7 +941,10 @@
 
   G_CreepSlow( self );
 
-  self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex );
+//  if(level.oc)
+//    self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex ) + OC_BUILDABLE_THINK_OFFSET;
+//  else
+    self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex );
 }
 
 
@@ -897,6 +1010,23 @@
 */
 void ABarricade_Die( gentity_t *self, gentity_t *inflictor, gentity_t *attacker, int damage, int mod )
 {
+  buildHistory_t *new;
+  new = G_Alloc( sizeof( buildHistory_t ) );
+  new->ID = ( ++level.lastBuildID > 1000 ) ? ( level.lastBuildID = 1 ) : level.lastBuildID;
+  new->ent = ( attacker && attacker->client ) ? attacker : NULL;
+  if( new->ent )
+    new->name[ 0 ] = 0;
+  else
+    Q_strncpyz( new->name, "<world>", 8 );
+  new->buildable = self->s.modelindex;
+  VectorCopy( self->s.pos.trBase, new->origin );
+  VectorCopy( self->s.angles, new->angles );
+  VectorCopy( self->s.origin2, new->origin2 );
+  VectorCopy( self->s.angles2, new->angles2 );
+  new->fate = ( attacker && attacker->client && attacker->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS ) ? BF_TEAMKILLED : BF_DESTROYED;
+  new->next = NULL;
+  G_LogBuild( new );
+
   G_SetBuildableAnim( self, BANIM_DESTROY1, qtrue );
   G_SetIdleBuildableAnim( self, BANIM_DESTROYED );
 
@@ -935,19 +1065,102 @@
 */
 void ABarricade_Think( gentity_t *self )
 {
+  gentity_t *ent;
 
-  self->powered = G_IsOvermindBuilt( );
+  if( level.oc )
+  {
+    switch( self->groupID )
+    {
+      case 0:
+      self->powered = G_IsOvermindBuilt( );
+      break;
 
+      case 1:
+      self->powered = 1;
+      break;
+
+      case 2:
+      self->powered = 0;
+      break;
+
+      default:
+      self->powered = G_IsOvermindBuilt( );
+      break;
+    }
+  }
+  else
+    self->powered = G_IsOvermindBuilt( );
+
   //if there is no creep nearby die
-  if( !G_FindCreep( self ) )
+  if( !G_FindCreep( self ) && !level.oc )
   {
     G_Damage( self, NULL, NULL, NULL, NULL, 10000, 0, MOD_SUICIDE );
     return;
   }
 
+  if( self->s.modelindex == BA_A_BOOSTER && level.oc && self->spawned )
+  {
+
+    //only suicide if at rest
+    if( self->s.groundEntityNum )
+    {
+      if( ( ent = G_CheckSpawnPoint( self->s.number, self->s.origin,
+              self->s.origin2, BA_A_BOOSTER, NULL, 0 ) ) != NULL )
+      {
+        if( ent->s.eType == ET_BUILDABLE || ent->s.number == ENTITYNUM_WORLD ||
+            ent->s.eType == ET_MOVER )
+        {
+          G_Damage( self, NULL, NULL, NULL, NULL, 10000, 0, MOD_SUICIDE );
+          return;
+        }
+    else if( !level.oc && g_antiSpawnBlock.integer && ent->client &&
+         ent->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )  // should never be executed, but put here in case the need arises (for oc's)
+    {
+      //spawnblock protection
+      if( self->spawnBlockTime && level.time - self->spawnBlockTime > 10000 )
+      {
+        //five seconds of countermeasures and we're still blocked
+        //time for something more drastic
+        G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_TRIGGER_HURT );
+        self->spawnBlockTime += 2000;
+        //inappropriate MOD but prints an apt obituary
+      }
+      else if( self->spawnBlockTime && level.time - self->spawnBlockTime > 5000 )
+        //five seconds of blocked by client and...
+      {
+            if (!level.oc)
+            {
+        //random direction
+        vec3_t velocity;
+        velocity[0] = crandom() * g_antiSpawnBlock.integer;
+        velocity[1] = crandom() * g_antiSpawnBlock.integer;
+        velocity[2] = g_antiSpawnBlock.integer;
+
+        VectorAdd( ent->client->ps.velocity, velocity, ent->client->ps.velocity );
+        }
+            trap_SendServerCommand( ent-g_entities, "cp \"Don't spawn block!\"" );
+
+        if (level.oc)
+            G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_TRIGGER_HURT);
+      }
+      else if( !self->spawnBlockTime )
+        self->spawnBlockTime = level.time;
+        }
+
+        if( ent->s.eType == ET_CORPSE )
+          G_FreeEntity( ent ); //quietly remove
+      }
+      else
+        self->spawnBlockTime = 0;
+    }
+  }
+
   G_CreepSlow( self );
 
-  self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex );
+//  if(level.oc)
+//    self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex ) + OC_BUILDABLE_THINK_OFFSET;
+//  else
+    self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex );
 }
 
 
@@ -969,7 +1182,7 @@
 */
 void AAcidTube_Damage( gentity_t *self )
 {
-  if( self->spawned )
+  if( self->spawned && self->powered )
   {
     if( !( self->s.eFlags & EF_FIRING ) )
     {
@@ -992,7 +1205,10 @@
 
   G_CreepSlow( self );
 
-  self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex );
+//  if(level.oc)
+//    self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex ) + OC_BUILDABLE_THINK_OFFSET;
+//  else
+    self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex );
 }
 
 /*
@@ -1010,19 +1226,41 @@
   int       i, num;
   gentity_t *enemy;
 
-  self->powered = G_IsOvermindBuilt( );
+  if( level.oc )
+  {
+    switch( self->groupID )
+    {
+      case 0:
+      self->powered = G_IsOvermindBuilt( );
+      break;
 
+      case 1:
+      self->powered = 1;
+      break;
+
+      case 2:
+      self->powered = 0;
+      break;
+
+      default:
+      self->powered = G_IsOvermindBuilt( );
+      break;
+    }
+  }
+  else
+    self->powered = G_IsOvermindBuilt( );
+
   VectorAdd( self->s.origin, range, maxs );
   VectorSubtract( self->s.origin, range, mins );
 
   //if there is no creep nearby die
-  if( !G_FindCreep( self ) )
+  if( !G_FindCreep( self ) && !level.oc )
   {
     G_Damage( self, NULL, NULL, NULL, NULL, 10000, 0, MOD_SUICIDE );
     return;
   }
 
-  if( self->spawned && G_FindOvermind( self ) )
+  if( self->spawned && self->powered )
   {
     //do some damage
     num = trap_EntitiesInBox( mins, maxs, entityList, MAX_GENTITIES );
@@ -1030,6 +1268,9 @@
     {
       enemy = &g_entities[ entityList[ i ] ];
 
+      if( enemy->flags & FL_NOTARGET )
+    continue;
+
       if( !G_Visible( self, enemy ) )
         continue;
 
@@ -1046,7 +1287,10 @@
 
   G_CreepSlow( self );
 
-  self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex );
+//  if(level.oc)
+//    self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex ) + OC_BUILDABLE_THINK_OFFSET;
+//  else
+    self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex );
 }
 
 
@@ -1073,15 +1317,40 @@
   gentity_t *enemy;
   vec3_t    dirToTarget;
 
-  self->powered = G_IsOvermindBuilt( );
+  if( level.oc )
+  {
+    switch( self->groupID )
+    {
+      case 0:
+      self->powered = G_IsOvermindBuilt( );
+      break;
 
-  self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex );
+      case 1:
+      self->powered = 1;
+      break;
 
+      case 2:
+      self->powered = 0;
+      break;
+
+      default:
+      self->powered = G_IsOvermindBuilt( );
+      break;
+    }
+  }
+  else
+    self->powered = G_IsOvermindBuilt( );
+
+//  if(level.oc)
+//    self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex ) + OC_BUILDABLE_THINK_OFFSET;
+//  else
+    self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex );
+
   VectorAdd( self->s.origin, range, maxs );
   VectorSubtract( self->s.origin, range, mins );
 
   //if there is no creep nearby die
-  if( !G_FindCreep( self ) )
+  if( !G_FindCreep( self ) && !level.oc )
   {
     G_Damage( self, NULL, NULL, NULL, NULL, 10000, 0, MOD_SUICIDE );
     return;
@@ -1090,7 +1359,7 @@
   if( self->timestamp < level.time )
     self->active = qfalse; //nothing has returned in HIVE_REPEAT seconds, forget about it
 
-  if( self->spawned && !self->active && G_FindOvermind( self ) )
+  if( self->spawned && !self->active && self->powered )
   {
     //do some damage
     num = trap_EntitiesInBox( mins, maxs, entityList, MAX_GENTITIES );
@@ -1098,6 +1367,9 @@
     {
       enemy = &g_entities[ entityList[ i ] ];
 
+      if( enemy->flags & FL_NOTARGET )
+    continue;
+
       if( enemy->health <= 0 )
         continue;
 
@@ -1166,22 +1438,22 @@
   VectorMA( origin, HOVEL_TRACE_DEPTH, normal, start );
 
   //compute a place up in the air to start the real trace
-  trap_Trace( &tr, origin, mins, maxs, start, player->s.number, MASK_PLAYERSOLID );
+  trap_Trace( &tr, origin, mins, maxs, start, player->s.number, MASK_OCSOLID );
   VectorMA( origin, HOVEL_TRACE_DEPTH, normal, start );
   VectorMA( origin, -HOVEL_TRACE_DEPTH, normal, end );
 
-  trap_Trace( &tr, start, mins, maxs, end, player->s.number, MASK_PLAYERSOLID );
+  trap_Trace( &tr, start, mins, maxs, end, player->s.number, MASK_OCSOLID );
 
   VectorCopy( tr.endpos, origin );
 
-  trap_Trace( &tr, origin, mins, maxs, origin, player->s.number, MASK_PLAYERSOLID );
+  trap_Trace( &tr, origin, mins, maxs, origin, player->s.number, MASK_OCSOLID );
 
   if( provideExit )
   {
     G_SetOrigin( player, origin );
     VectorCopy( origin, player->client->ps.origin );
     VectorCopy( vec3_origin, player->client->ps.velocity );
-    SetClientViewAngle( player, angles );
+    G_SetClientViewAngle( player, angles );
   }
 
   if( tr.fraction < 1.0f )
@@ -1220,7 +1492,7 @@
 {
   vec3_t  hovelOrigin, hovelAngles, inverseNormal;
 
-  if( self->spawned && G_FindOvermind( self ) )
+  if( self->spawned && self->powered )
   {
     if( self->active )
     {
@@ -1264,7 +1536,7 @@
 
       G_SetOrigin( activator, hovelOrigin );
       VectorCopy( hovelOrigin, activator->client->ps.origin );
-      SetClientViewAngle( activator, hovelAngles );
+      G_SetClientViewAngle( activator, hovelAngles );
     }
   }
 }
@@ -1279,7 +1551,30 @@
 */
 void AHovel_Think( gentity_t *self )
 {
-  self->powered = G_IsOvermindBuilt( );
+  if( level.oc )
+  {
+    switch( self->groupID )
+    {
+      case 0:
+      self->powered = G_IsOvermindBuilt( );
+      break;
+
+      case 1:
+      self->powered = 1;
+      break;
+
+      case 2:
+      self->powered = 0;
+      break;
+
+      default:
+      self->powered = G_IsOvermindBuilt( );
+      break;
+    }
+  }
+  else
+    self->powered = G_IsOvermindBuilt( );
+
   if( self->spawned )
   {
     if( self->active )
@@ -1303,6 +1598,22 @@
 void AHovel_Die( gentity_t *self, gentity_t *inflictor, gentity_t *attacker, int damage, int mod )
 {
   vec3_t  dir;
+  buildHistory_t *new;
+  new = G_Alloc( sizeof( buildHistory_t ) );
+  new->ID = ( ++level.lastBuildID > 1000 ) ? ( level.lastBuildID = 1 ) : level.lastBuildID;
+  new->ent = ( attacker && attacker->client ) ? attacker : NULL;
+  if( new->ent )
+    new->name[ 0 ] = 0;
+  else
+    Q_strncpyz( new->name, "<world>", 8 );
+  new->buildable = self->s.modelindex;
+  VectorCopy( self->s.pos.trBase, new->origin );
+  VectorCopy( self->s.angles, new->angles );
+  VectorCopy( self->s.origin2, new->origin2 );
+  VectorCopy( self->s.angles2, new->angles2 );
+  new->fate = ( attacker && attacker->client && attacker->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS ) ? BF_TEAMKILLED : BF_DESTROYED;
+  new->next = NULL;
+  G_LogBuild( new );
 
   VectorCopy( self->s.origin2, dir );
 
@@ -1339,7 +1650,7 @@
 
     G_SetOrigin( builder, newOrigin );
     VectorCopy( newOrigin, builder->client->ps.origin );
-    SetClientViewAngle( builder, newAngles );
+    G_SetClientViewAngle( builder, newAngles );
 
     //client leaves hovel
     builder->client->ps.stats[ STAT_STATE ] &= ~SS_HOVELING;
@@ -1388,13 +1699,13 @@
   if( !self->spawned || self->health <= 0 )
     return;
 
-  if( !G_FindOvermind( self ) )
+  if( !self->powered )
     return;
 
   if( !client )
     return;
 
-  if( client && client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+  if( client && client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS && !level.oc )
     return;
 
   //only allow boostage once every 30 seconds
@@ -1410,7 +1721,6 @@
 
 
 
-
 //==================================================================================
 
 #define TRAPPER_ACCURACY 10 // lower is better
@@ -1488,6 +1798,8 @@
     return qfalse;
   if( !target->client ) // is the target a bot or player?
     return qfalse;
+  if( target->flags & FL_NOTARGET ) // is the target cheating?
+    return qfalse;
   if( target->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS ) // one of us?
     return qfalse;
   if( target->client->sess.sessionTeam == TEAM_SPECTATOR ) // is the target alive?
@@ -1552,20 +1864,45 @@
   int range =     BG_FindRangeForBuildable( self->s.modelindex );
   int firespeed = BG_FindFireSpeedForBuildable( self->s.modelindex );
 
-  self->powered = G_IsOvermindBuilt( );
+  if( level.oc )
+  {
+    switch( self->groupID )
+    {
+      case 0:
+      self->powered = G_IsOvermindBuilt( );
+      break;
 
+      case 1:
+      self->powered = 1;
+      break;
+
+      case 2:
+      self->powered = 0;
+      break;
+
+      default:
+      self->powered = G_IsOvermindBuilt( );
+      break;
+    }
+  }
+  else
+    self->powered = G_IsOvermindBuilt( );
+
   G_CreepSlow( self );
 
-  self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex );
+//  if(level.oc)
+//    self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex ) + OC_BUILDABLE_THINK_OFFSET;
+//  else
+    self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex );
 
   //if there is no creep nearby die
-  if( !G_FindCreep( self ) )
+  if( !G_FindCreep( self ) && !level.oc )
   {
     G_Damage( self, NULL, NULL, NULL, NULL, 10000, 0, MOD_SUICIDE );
     return;
   }
 
-  if( self->spawned && G_FindOvermind( self ) )
+  if( self->spawned && self->powered )
   {
     //if the current target is not valid find a new one
     if( !ATrapper_CheckTarget( self, self->enemy, range ) )
@@ -1613,7 +1950,7 @@
     }
   }
 
-  if( G_NumberOfDependants( self ) == 0 )
+  if( G_NumberOfDependants( self ) == 0 && !level.oc )
   {
     //if no dependants for x seconds then disappear
     if( self->count < 0 )
@@ -1624,9 +1961,34 @@
   else
     self->count = -1;
 
-  self->powered = reactor;
+  if( level.oc )
+  {
+    switch( self->groupID )
+    {
+      case 0:
+      self->powered = reactor;
+      break;
 
-  self->nextthink = level.time + POWER_REFRESH_TIME;
+      case 1:
+      self->powered = 1;
+      break;
+
+      case 2:
+      self->powered = 0;
+      break;
+
+      default:
+      self->powered = reactor;
+      break;
+    }
+  }
+  else
+    self->powered = reactor;
+
+//  if(level.oc)
+//    self->nextthink = level.time + POWER_REFRESH_TIME + OC_BUILDABLE_THINK_OFFSET;
+//  else
+    self->nextthink = level.time + POWER_REFRESH_TIME;
 }
 
 /*
@@ -1641,6 +2003,9 @@
   if( self->health <= 0 )
     return;
 
+  if( other->flags & FL_NOTARGET )
+    return; // notarget cancels even beneficial effects?
+
   if( !self->spawned )
     return;
 
@@ -1648,7 +2013,46 @@
     G_GiveClientMaxAmmo( other, qtrue );
 }
 
+/*
+================
+HSpawn_Use
 
+Use for human spawn
+================
+*/
+void HSpawn_Use( gentity_t *self, gentity_t *other, gentity_t *activator )
+{
+  gentity_t *dest;
+  vec3_t spawn_origin, spawn_angles;
+
+  if( !level.oc )
+    return; // obstacle course only feature
+
+  if( self->health <= 0 )
+    return;
+
+  if( !self->spawned )
+    return;
+
+  if( !self->powered )
+    return;
+
+  if( other && ( dest = G_SelectHumanSpawnPoint( self->s.origin, 0, self->groupID, self ) ) )
+  {
+    VectorCopy( dest->s.origin, spawn_origin );
+    if( !other->client->pers.autoAngleDisabled )
+      VectorCopy( dest->s.angles, spawn_angles );
+    else
+      VectorCopy( other->s.angles, spawn_angles );
+    if( G_CheckSpawnPoint( dest->s.number, dest->s.origin, dest->s.origin2, BA_H_SPAWN, spawn_origin, 0 ) == NULL )
+    {
+      TeleportPlayer( other, spawn_origin, spawn_angles );
+      VectorScale( other->client->ps.velocity, 0.0, other->client->ps.velocity );
+    }
+  }
+}
+
+
 #define DCC_ATTACK_PERIOD 10000
 
 /*
@@ -1670,15 +2074,42 @@
   VectorAdd( self->s.origin, range, maxs );
   VectorSubtract( self->s.origin, range, mins );
 
-  if( self->spawned && ( self->health > 0 ) )
+  if( level.oc )
   {
+    switch( self->groupID )
+    {
+      case 0:
+      self->powered = 1;
+      break;
+
+      case 1:
+      self->powered = 1;
+      break;
+
+      case 2:
+      self->powered = 0;
+      break;
+
+      default:
+      self->powered = 1;
+      break;
+    }
+  }
+  else
+    self->powered = 1;
+
+  if( self->spawned && ( self->health > 0 ) && self->powered )
+  {
     //detect alien targets and draw tesla trails
     num = trap_EntitiesInBox( mins, maxs, entityList, MAX_GENTITIES );
     for( i = 0; i < num; i++ )
     {
       enemy = &g_entities[ entityList[ i ] ];
 
-      if( enemy->client && enemy->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
+      if( enemy->flags & FL_NOTARGET )
+    continue;
+
+      if( enemy->client && enemy->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS && !G_TestLayoutFlag( level.layout, OCFL_NOALIENREACTORFIRE ) )
       {
         self->timestamp = level.time;
         attack = qtrue;
@@ -1708,7 +2139,10 @@
     self->lastHealth = self->health;
   }
 
-  self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex );
+//  if(level.oc)
+//    self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex ) + OC_BUILDABLE_THINK_OFFSET;
+//  else
+    self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex );
 }
 
 //==================================================================================
@@ -1748,20 +2182,50 @@
 void HArmoury_Think( gentity_t *self )
 {
   //make sure we have power
-  self->nextthink = level.time + POWER_REFRESH_TIME;
+//  if(level.oc)
+//    self->nextthink = level.time + POWER_REFRESH_TIME + OC_BUILDABLE_THINK_OFFSET;
+//  else
+    self->nextthink = level.time + POWER_REFRESH_TIME;
 
-  self->powered = G_FindPower( self );
-}
+  if( level.oc )
+  {
+    switch( self->groupID )
+    {
+      case 0:
+      self->powered = G_FindPower( self );
+      break;
 
+      case 1:
+      self->powered = 1;
+      break;
 
+      case 2:
+      self->powered = 0;
+      break;
 
+      default:
+      self->powered = G_FindPower( self );
+      break;
+    }
+  }
+  else
+    self->powered = G_FindPower( self );
 
-//==================================================================================
+  if( level.oc )
+  {
+    if( !self->powered && !self->verifyUnpowered )
+    {
+      self->verifyUnpowered = qtrue;
+      G_StructureDecon( self );
+    }
+    if( self->powered && self->verifyUnpowered )  // rare case of repowering
+    {
+      self->verifyUnpowered = qfalse;
+      G_StructureBuilt( self );
+    }
+  }
+}
 
-
-
-
-
 /*
 ================
 HDCC_Think
@@ -1772,14 +2236,1522 @@
 void HDCC_Think( gentity_t *self )
 {
   //make sure we have power
-  self->nextthink = level.time + POWER_REFRESH_TIME;
+  if(level.oc)
+    self->nextthink = level.time + POWER_REFRESH_TIME + OC_BUILDABLE_THINK_OFFSET;
+  else
+    self->nextthink = level.time + POWER_REFRESH_TIME;
 
-  self->powered = G_FindPower( self );
+  if( level.oc )
+  {
+    switch( self->groupID )
+    {
+      case 0:
+      self->powered = G_FindPower( self );
+      break;
+
+      case 1:
+      self->powered = 1;
+      break;
+
+      case 2:
+      self->powered = 0;
+      break;
+
+      default:
+      self->powered = G_FindPower( self );
+      break;
+    }
+  }
+  else
+    self->powered = G_FindPower( self );
 }
 
 
 
+//==================================================================================
 
+
+
+int G_UseMedi( gentity_t *ent, gentity_t *medi )
+{
+    gentity_t *client;
+    int i;
+
+    // sanity checks
+    if( !level.oc )  // not in oc mode
+        return 0;
+
+    if( !medi )
+        return 0;
+
+    if( medi->s.modelindex != BA_H_MEDISTAT )  // not a medi
+        return 0;
+
+    if( !ent )
+        return 0;
+
+    if( !ent->client )  // not a client
+        return 0;
+
+    if( !ent->client->pers.medis )  // this function can only be called when there are medis, so this should never happen
+        return 0;
+
+    if( !medi->powered )  // an unpowered medistation
+        return 0;
+
+    // if the player is cheating or using equipment
+    if( !G_CanUseBonus ( ent ) )
+        return 0;
+
+    if( !level.totalMedistations )  // there are no medistations to be G_Use'd?
+        return 0;
+
+    // medi can be used
+
+    // if the player is on a scrim team
+    if( ent->client->pers.ocTeam )
+    {
+        oc_scrimTeam_t *t;
+        OC_GETTEAM(t, level.scrimTeam, ent->client->pers.ocTeam);
+        // only handle if the scrim is playing and it is a medi scrim
+        if( level.ocScrimState == OC_STATE_PLAY && level.ocScrimMode == OC_MODE_MEDI )
+        {
+            // first merge all medis
+            gentity_t **tmp = G_Alloc( level.totalMedistations * sizeof( gentity_t * ) );
+            memcpy(tmp, t->medis, level.totalMedistations * sizeof( gentity_t * ));  // memcpy should be faster than merge itself
+            for(i = 0; i < MAX_CLIENTS; i++)
+            {
+                client = g_entities + i;
+
+                if(client->client && client->client->pers.ocTeam == ent->client->pers.ocTeam)
+                    G_MergeMedis(tmp, client->client->pers.medis);
+            }
+
+            // now continue testing the teams medis
+            if(G_AllMedis(tmp))
+            {
+                G_AppendMedi(tmp, medi);
+                G_AppendMedi(ent->client->pers.medis, medi);
+                if(t->time)
+                {
+                    // team has already won
+                    G_ClientCP(ent, va("Medical Stations: %d/%d\n^2You Win!", level.totalMedistations, level.totalMedistations), NULL, CLIENT_SPECTATORS);  // repeate same message cp because a medi check is rarely used only once
+                }
+                else
+                {
+                    // team has won
+                    if(!level.ocEndsTime)
+                        level.ocEndsTime = level.time + g_ocScrimAfterTime.integer * 1000;
+                    t->time = level.time;
+                    if(G_OCScrimAllWon())
+                    {
+                        level.ocEndsTime = level.time + 3000;
+                    }
+                    level.ocOrder++;
+//                    G_ClientCP(ent, "New Medi!", NULL, CLIENT_SPECTATORS);
+                    G_ClientPrint(ent, va("New medi! (%d/%d) (%s^7)", G_NumberOfMedis(tmp), level.totalMedistations, ent->client->pers.netname), CLIENT_SPECTATORS | CLIENT_OCTEAM);
+                    if(level.ocOrder == 1)
+                    {
+                        G_ClientPrint(NULL, va("^7%s^7 (%ss^7)^2 wins the oc scrim! (%d/%d medical stations) - %dm%ds%dms", t->name, BG_FindHumanNameForWeapon(t->weapon), G_NumberOfMedis(tmp), level.totalMedistations, MINS(t->time - level.ocStartTime - g_ocWarmup.integer * 1000), SECS(t->time - level.ocStartTime - g_ocWarmup.integer * 1000), MSEC(t->time - level.ocStartTime - g_ocWarmup.integer * 1000)), 0);
+                        G_LogPrintf("^7%s^7 (%ss^7)^2 wins the oc scrim! (%d/%d medical stations) - %dm%ds%dms", t->name, BG_FindHumanNameForWeapon(t->weapon), G_NumberOfMedis(tmp), level.totalMedistations, MINS(t->time - level.ocStartTime - g_ocWarmup.integer * 1000), SECS(t->time - level.ocStartTime - g_ocWarmup.integer * 1000), MSEC(t->time - level.ocStartTime - g_ocWarmup.integer * 1000));
+                    }
+                    else
+                    {
+                        G_ClientPrint(NULL, va("^7%s^7 (%ss^7)^2 finishes the oc scrim %d%s (%d/%d medical stations) - %dm%ds%dms", t->name, BG_FindHumanNameForWeapon(t->weapon), level.ocOrder, SUFN(level.ocOrder), G_NumberOfMedis(tmp), level.totalMedistations, MINS(t->time - level.ocStartTime - g_ocWarmup.integer * 1000), SECS(t->time - level.ocStartTime - g_ocWarmup.integer * 1000), MSEC(t->time - level.ocStartTime - g_ocWarmup.integer * 1000)), 0);
+                        G_LogPrintf("^7%s^7 (%ss^7)^2 finishes the oc scrim %d%s (%d/%d medical stations) - %dm%ds%dms", t->name, BG_FindHumanNameForWeapon(t->weapon), level.ocOrder, SUFN(level.ocOrder), G_NumberOfMedis(tmp), level.totalMedistations, MINS(t->time - level.ocStartTime - g_ocWarmup.integer * 1000), SECS(t->time - level.ocStartTime - g_ocWarmup.integer * 1000), MSEC(t->time - level.ocStartTime - g_ocWarmup.integer * 1000));
+                    }
+                }
+            }
+            else
+            {
+                if(G_HasMediBeenUsed(medi, tmp))
+                {
+                    // player stepped on an already used medi
+
+                    // first see if it is new to the _player_, but hasn't been stepped on by another player
+                    if(!G_HasMediBeenUsed(medi, ent->client->pers.medis) && !G_HasMediBeenUsed(medi, t->medis))
+                    {
+                        // the medi has already been secured by somebody, so send
+                        // new medi message to client (and spectators) only
+                        G_AppendMedi(ent->client->pers.medis, medi);
+                        G_ClientCP(ent, "New Medi!", NULL, CLIENT_SPECTATORS);
+                        G_ClientPrint(ent, va("New Medi! (%d/%d) (^2already secured by another player^7)", G_NumberOfMedis(tmp), level.totalMedistations), CLIENT_SPECTATORS);
+                    }
+                    G_ClientCP(ent, va("Medical Stations: %d/%d", G_NumberOfMedis(tmp), level.totalMedistations), "Medical Stations", CLIENT_SPECTATORS);
+                }
+                else
+                {
+                    // new medi
+                    G_AppendMedi(tmp, medi);
+                    G_AppendMedi(ent->client->pers.medis, medi);
+                    if(G_AllMedis(tmp))
+                    {
+                        G_Free(tmp);
+                        return G_UseMedi(ent, medi);
+                    }
+                    G_ClientCP(ent, "New Medi!", NULL, CLIENT_SPECTATORS);
+                    G_ClientCP(ent, va("Medical Stations: %d/%d", G_NumberOfMedis(tmp), level.totalMedistations), "Medical Stations", CLIENT_SPECTATORS);
+                    G_ClientPrint(ent, va("New Medi! (%d/%d)", G_NumberOfMedis(tmp), level.totalMedistations), CLIENT_SPECTATORS);
+                    G_ClientPrint(ent, va("New Medi! (%d/%d) (%s^7)", G_NumberOfMedis(tmp), level.totalMedistations, ent->client->pers.netname), CLIENT_OCTEAM | CLIENT_NOTARGET);
+                }
+            }
+
+            G_Free(tmp);
+        }
+    }
+    // the player is not on a scrim team
+    else
+    {
+        if(G_AllMedis(ent->client->pers.medis))
+        {
+            // player has already won
+            G_ClientCP(ent, va("Medical Stations: %d/%d\n^2You Win!", level.totalMedistations, level.totalMedistations), NULL, CLIENT_SPECTATORS);  // repeate same message cp because a medi check is rarely used only once
+        }
+        else if(G_HasMediBeenUsed(medi, ent->client->pers.medis))
+        {
+            // player stepped on an already used medi
+            G_ClientCP(ent, va("Medical Stations: %d/%d", G_NumberOfMedis(ent->client->pers.medis), level.totalMedistations), "Medical Stations", CLIENT_SPECTATORS);
+        }
+        else
+        {
+            // new medi
+            G_AppendMedi(ent->client->pers.medis, medi);
+            if(G_AllMedis(ent->client->pers.medis))
+            {
+                // player has won
+                char *record;
+                G_AppendMedi(ent->client->pers.medis, medi);
+                ent->client->pers.mediTime = ent->client->pers.aliveTime;
+                record = G_MediStats( ent, level.totalMedistations, ent->client->pers.mediTime );
+                AP(va("print \"^7%s^7 has used every bonus medical station! (%d^7/%d^7) (%dm:%ds%dms)%s\n\"", ent->client->pers.netname, level.totalMedistations, level.totalMedistations, MINS(ent->client->pers.mediTime), SECS(ent->client->pers.mediTime), MSEC(ent->client->pers.mediTime), record));
+                G_LogPrintf(va("^7%s^7 has used every bonus medical station! (%d^7/%d^7) (%dm:%ds%dms)%s", ent->client->pers.netname, level.totalMedistations, level.totalMedistations, MINS(ent->client->pers.mediTime), SECS(ent->client->pers.mediTime), MSEC(ent->client->pers.mediTime), record));
+                G_ClientCP(ent, va("Medical Stations: %d/%d\n^2You Win!", level.totalMedistations, level.totalMedistations), NULL, CLIENT_SPECTATORS);
+                if(G_StrFind(record, "^s^f^r^e^e"))
+                    G_Free(record);
+                return 0;
+            }
+            G_ClientCP(ent, "New Medi!", NULL, CLIENT_SPECTATORS);
+            G_ClientCP(ent, va("Medical Stations: %d/%d", G_NumberOfMedis(ent->client->pers.medis), level.totalMedistations), "Medical Stations", CLIENT_SPECTATORS);
+            G_ClientPrint(ent, va("New Medi! (%d/%d)", G_NumberOfMedis(ent->client->pers.medis), level.totalMedistations), CLIENT_SPECTATORS);
+        }
+    }
+
+    return 0;
+}
+
+int G_MergeMedis( gentity_t **dst, gentity_t **src)
+{
+    int i;
+
+    for(i = 0; src[i]; i++)
+    {
+        G_AppendMedi(dst, src[i]);
+    }
+
+    return 0;
+}
+
+int G_AppendMedi( gentity_t **medis, gentity_t *medi)
+{
+    int i;
+
+    for(i = 0; medis[i]; i++)
+    {
+        if(medis[i] == medi)
+        {
+            return 0;
+        }
+    }
+
+    medis[i] = medi;
+
+    return 0;
+}
+
+int G_RemoveMedi( gentity_t **medis, gentity_t *medi)
+{
+    int i;
+
+    for(i = 0; medis[i]; i++)
+    {
+        if(medis[i] == medi)
+        {
+            memmove(&medis[i], &medis[i + 1], sizeof(gentity_t *) * (level.totalMedistations - i));
+            break;
+        }
+    }
+
+    return 0;
+}
+
+int G_AllMedis( gentity_t **medis )
+{
+    return !(level.totalMedistations - G_NumberOfMedis(medis));
+}
+
+int G_NumberOfMedis( gentity_t **medis )
+{
+    int i, count = 0;
+
+    if(!level.oc)
+        return 0;
+
+    for(i = 0; i < level.totalMedistations; i++) if(medis[i]) count++;
+
+    return count;
+}
+
+int G_HasMediBeenUsed(gentity_t *medi, gentity_t **medis)
+{
+    int i;
+    gentity_t *ent;
+
+    if(!level.oc)
+        return 0;
+
+    for(i = 0; medis[i]; i++)
+    {
+        ent = medis[i];
+
+        if(ent == medi)
+        {
+            return 1;
+        }
+    }
+
+    return 0;
+}
+
+int G_ClearMedis(gentity_t **medis)
+{
+    int i;
+
+    if(!level.oc)
+        return 0;
+
+    if(!medis)
+        return 0;
+
+    for(i = 0; i < level.totalMedistations; i++)
+    {
+        medis[i] = NULL;
+    }
+
+    return 0;
+}
+
+int G_UseArm( gentity_t *ent, gentity_t *arm )
+{
+    gentity_t *client;
+    int i;
+
+    // sanity checks
+    if( !level.oc )  // not in oc mode
+        return 0;
+
+    if( !arm )
+        return 0;
+
+    if( arm->s.modelindex != BA_H_ARMOURY )  // not an armory
+        return 0;
+
+    if( !ent )
+        return 0;
+
+    if( !ent->client )  // not a client
+        return 0;
+
+    if( !ent->client->pers.arms )  // this function can only be called when there are arms, so this should never happen
+        return 0;
+
+    if( !arm->powered )  // an unpowered armoury
+        return 0;
+
+    // if the player is cheating or using equipment
+    if( !G_CanUseBonus ( ent ) )
+        return 0;
+
+    if( !level.totalArmouries )  // there are no armouries to be G_Use'd?
+        return 0;
+
+    // arm can be used
+
+    // if the player is on a scrim team
+    if( ent->client->pers.ocTeam )
+    {
+        oc_scrimTeam_t *t;
+        OC_GETTEAM(t, level.scrimTeam, ent->client->pers.ocTeam);
+        // only handle if the scrim is playing and it is an arm scrim
+        if( level.ocScrimState == OC_STATE_PLAY && level.ocScrimMode == OC_MODE_ARM )
+        {
+            // first merge all arms
+            gentity_t **tmp = G_Alloc( level.totalArmouries * sizeof( gentity_t * ) );
+            memcpy(tmp, t->arms, level.totalArmouries * sizeof( gentity_t * ));  // memcpy should be faster than merge itself
+            for(i = 0; i < MAX_CLIENTS; i++)
+            {
+                client = g_entities + i;
+
+                if(client->client && client->client->pers.ocTeam == ent->client->pers.ocTeam)
+                    G_MergeArms(tmp, client->client->pers.arms);
+            }
+
+            // now continue testing the teams arms
+            if(G_AllArms(tmp) || G_TestLayoutFlag(level.layout, OCFL_ONEARM))
+            {
+                G_AppendArm(ent->client->pers.arms, arm);
+                if(t->time)
+                {
+                    // team has already won
+                    if(level.totalArmouries == 1)
+                        G_ClientCP(ent, va("^a^r^m^2You Win!"), "^a^r^m", CLIENT_SPECTATORS);
+                    else
+                        G_ClientCP(ent, va("^a^r^mArmouries: %d/%d\n^2You Win!", level.totalArmouries, level.totalArmouries), "^a^r^m", CLIENT_SPECTATORS);
+                }
+                else
+                {
+                    // team has won
+                    if(!level.ocEndsTime)
+                        level.ocEndsTime = level.time + g_ocScrimAfterTime.integer * 1000;
+                    t->time = level.time;
+                    if(G_OCScrimAllWon())
+                    {
+                        level.ocEndsTime = level.time + 3000;
+                    }
+                    level.ocOrder++;
+//                    G_ClientCP(ent, "^a^r^mNew Armoury!", "^a^r^m", CLIENT_SPECTATORS);
+                    G_ClientPrint(ent, va("New Armoury! (%d/%d) (%s^7)", G_NumberOfArms(tmp), level.totalArmouries, ent->client->pers.netname), CLIENT_SPECTATORS | CLIENT_OCTEAM);
+                    if(level.ocOrder == 1)
+                    {
+                        G_ClientPrint(NULL, va("^7%s^7 (%ss^7)^2 wins the oc scrim! (%d/%d armouries) - %dm%ds%dms", t->name, BG_FindHumanNameForWeapon(t->weapon), G_NumberOfArms(tmp), level.totalArmouries, MINS(t->time - level.ocStartTime - g_ocWarmup.integer * 1000), SECS(t->time - level.ocStartTime - g_ocWarmup.integer * 1000), MSEC(t->time - level.ocStartTime - g_ocWarmup.integer * 1000)), 0);
+                        G_LogPrintf("^7%s^7 (%ss^7)^2 wins the oc scrim! (%d/%d armouries) - %dm%ds%dms", t->name, BG_FindHumanNameForWeapon(t->weapon), G_NumberOfArms(tmp), level.totalArmouries, MINS(t->time - level.ocStartTime - g_ocWarmup.integer * 1000), SECS(t->time - level.ocStartTime - g_ocWarmup.integer * 1000), MSEC(t->time - level.ocStartTime - g_ocWarmup.integer * 1000));
+                    }
+                    else
+                    {
+                        G_ClientPrint(NULL, va("^7%s^7 (%ss^7)^2 finishes the oc scrim %d%s (%d/%d armouries) - %dm%ds%dms", t->name, BG_FindHumanNameForWeapon(t->weapon), level.ocOrder, SUFN(level.ocOrder), G_NumberOfArms(tmp), level.totalArmouries, MINS(t->time - level.ocStartTime - g_ocWarmup.integer * 1000), SECS(t->time - level.ocStartTime - g_ocWarmup.integer * 1000), MSEC(t->time - level.ocStartTime - g_ocWarmup.integer * 1000)), 0);
+                        G_LogPrintf("^7%s^7 (%ss^7)^2 finishes the oc scrim %d%s (%d/%d armouries) - %dm%ds%dms", t->name, BG_FindHumanNameForWeapon(t->weapon), level.ocOrder, SUFN(level.ocOrder), G_NumberOfArms(tmp), level.totalArmouries, MINS(t->time - level.ocStartTime - g_ocWarmup.integer * 1000), SECS(t->time - level.ocStartTime - g_ocWarmup.integer * 1000), MSEC(t->time - level.ocStartTime - g_ocWarmup.integer * 1000));
+                    }
+                }
+            }
+            else
+            {
+                if(G_HasArmBeenUsed(arm, tmp))
+                {
+                    // player used an already used arm
+
+                    // first see if it is new to the _player_, but hasn't been used by another player
+                    if(!G_HasArmBeenUsed(arm, ent->client->pers.arms) && !G_HasArmBeenUsed(arm, t->arms))
+                    {
+                        // the arm has already been secured by somebody, so send
+                        // new arm message to client (and spectators) only
+                        G_AppendArm(ent->client->pers.arms, arm);
+                        G_ClientCP(ent, "New Armoury!", NULL, CLIENT_SPECTATORS);
+                        G_ClientPrint(ent, va("New Armoury! (%d/%d) (^2already secured by another player^7)", G_NumberOfArms(tmp), level.totalArmouries), CLIENT_SPECTATORS);
+                    }
+                    G_ClientCP(ent, va("^a^r^mArmouries: %d/%d", G_NumberOfArms(tmp), level.totalArmouries), "^a^r^m", CLIENT_SPECTATORS);
+                }
+                else
+                {
+                    // new arm
+                    G_AppendArm(tmp, arm);
+                    G_AppendArm(ent->client->pers.arms, arm);
+                    if(G_AllArms(tmp))
+                    {
+                        G_Free(tmp);
+                        return G_UseArm(ent, arm);
+                    }
+                    G_ClientCP(ent, "New Armoury!", NULL, CLIENT_SPECTATORS);
+                    G_ClientCP(ent, va("^a^r^mArmouries: %d/%d", G_NumberOfArms(tmp), level.totalArmouries), "^a^r^m", CLIENT_SPECTATORS);
+                    G_ClientPrint(ent, va("New Armoury! (%d/%d)", G_NumberOfArms(tmp), level.totalArmouries), CLIENT_SPECTATORS);
+                    G_ClientPrint(ent, va("New Armoury! (%d/%d) (%s^7)", G_NumberOfArms(tmp), level.totalArmouries, ent->client->pers.netname), CLIENT_OCTEAM | CLIENT_NOTARGET);
+                }
+            }
+
+            G_Free(tmp);
+        }
+    }
+    // the player is not on a scrim team
+    else
+    {
+        if(G_AllArms(ent->client->pers.arms) || (G_TestLayoutFlag(level.layout, OCFL_ONEARM) && G_NumberOfArms(ent->client->pers.arms)))
+        {
+            // player has already won
+            if(level.totalArmouries == 1)
+                G_ClientCP(ent, va("^a^r^m^2You Win!"), "^a^r^m", CLIENT_SPECTATORS);
+            else
+                G_ClientCP(ent, va("^a^r^mArmouries: %d/%d\n^2You Win!", level.totalArmouries, level.totalArmouries), "^a^r^m", CLIENT_SPECTATORS);
+        }
+        else if(G_HasArmBeenUsed(arm, ent->client->pers.arms))
+        {
+            // player stepped on an already used arm
+            G_ClientCP(ent, va("^a^r^mArmouries: %d/%d", G_NumberOfArms(ent->client->pers.arms), level.totalArmouries), "^a^r^m", CLIENT_SPECTATORS);
+        }
+        else
+        {
+            // new arm
+            G_AppendArm(ent->client->pers.arms, arm);
+            if(G_AllArms(ent->client->pers.arms) || G_TestLayoutFlag(level.layout, OCFL_ONEARM))
+            {
+                // player has won
+                char *record;
+                G_AppendArm(ent->client->pers.arms, arm);
+                ent->client->pers.winTime = ent->client->pers.aliveTime;
+                record = G_WinStats( ent, level.totalArmouries, ent->client->pers.winTime );
+                if(level.totalArmouries == 1 || G_TestLayoutFlag(level.layout, OCFL_ONEARM))
+                {
+                    G_ClientCP(ent, va("^a^r^m^2You Win!"), "^a^r^m", CLIENT_SPECTATORS);
+                    AP(va("print \"^7%s^7 wins! (%dm:%ds%dms)%s\n\"", ent->client->pers.netname, MINS(ent->client->pers.winTime), SECS(ent->client->pers.winTime), MSEC(ent->client->pers.winTime), record));
+                    G_LogPrintf(va("^7%s^7 wins! (%dm:%ds%dms)%s\n\"", ent->client->pers.netname, MINS(ent->client->pers.winTime), SECS(ent->client->pers.winTime), MSEC(ent->client->pers.winTime), record));
+                }
+                else
+                {
+                    if(level.totalArmouries == 1)
+                    {
+                        AP(va("print \"^7%s^7 wins! (%d^7/%d^7) (%dm:%ds%dms)%s\n\"", ent->client->pers.netname, level.totalArmouries, level.totalArmouries, MINS(ent->client->pers.winTime), SECS(ent->client->pers.winTime), MSEC(ent->client->pers.winTime), record));
+                        G_LogPrintf(va("^7%s^7 wins! (%d^7/%d^7) (%dm:%ds%dms)%s\n\"", ent->client->pers.netname, level.totalArmouries, level.totalArmouries, MINS(ent->client->pers.winTime), SECS(ent->client->pers.winTime), MSEC(ent->client->pers.winTime), record));
+                        G_ClientCP(ent, va("^a^r^mArmouries: %d/%d\n^2You Win!", level.totalArmouries, level.totalArmouries), "^a^r^m", CLIENT_SPECTATORS);
+                    }
+                    else
+                    {
+                        AP(va("print \"^7%s^7 wins! (%dm:%ds%dms)%s\n\"", ent->client->pers.netname, MINS(ent->client->pers.winTime), SECS(ent->client->pers.winTime), MSEC(ent->client->pers.winTime), record));
+                        G_LogPrintf(va("^7%s^7 wins! (%dm:%ds%dms)%s\n\"", ent->client->pers.netname, MINS(ent->client->pers.winTime), SECS(ent->client->pers.winTime), MSEC(ent->client->pers.winTime), record));
+                        G_ClientCP(ent, va("^a^r^m^2You Win!"), "^a^r^m", CLIENT_SPECTATORS);
+                    }
+                }
+                if(G_StrFind(record, "^s^f^r^e^e"))
+                    G_Free(record);
+                return 0;
+            }
+            G_ClientCP(ent, "New Armoury!", NULL, CLIENT_SPECTATORS);
+            G_ClientCP(ent, va("^a^r^mArmouries: %d/%d", G_NumberOfArms(ent->client->pers.arms), level.totalArmouries), "^a^r^m", CLIENT_SPECTATORS);
+            G_ClientPrint(ent, va("New Armoury! (%d/%d)", G_NumberOfArms(ent->client->pers.arms), level.totalArmouries), CLIENT_SPECTATORS);
+        }
+    }
+
+    return 0;
+}
+
+int G_MergeArms( gentity_t **dst, gentity_t **src)
+{
+    int i;
+
+    for(i = 0; src[i]; i++)
+    {
+        G_AppendArm(dst, src[i]);
+    }
+
+    return 0;
+}
+
+int G_AppendArm( gentity_t **arms, gentity_t *arm)
+{
+    int i;
+
+    for(i = 0; arms[i]; i++)
+    {
+        if(arms[i] == arm)
+        {
+            return 0;
+        }
+    }
+
+    arms[i] = arm;
+
+    return 0;
+}
+
+int G_RemoveArm( gentity_t **arms, gentity_t *arm)
+{
+    int i;
+
+    for(i = 0; arms[i]; i++)
+    {
+        if(arms[i] == arm)
+        {
+            memmove(&arms[i], &arms[i + 1], sizeof(gentity_t *) * (level.totalArmouries - i));
+            break;
+        }
+    }
+
+    return 0;
+}
+
+int G_AllArms( gentity_t **arms )
+{
+    return !(level.totalArmouries - G_NumberOfArms(arms));
+}
+
+int G_NumberOfArms( gentity_t **arms )
+{
+    int i, count = 0;
+
+    if(!level.oc)
+        return 0;
+
+    for(i = 0; i < level.totalArmouries; i++) if(arms[i]) count++;
+
+    return count;
+}
+
+int G_HasArmBeenUsed(gentity_t *arm, gentity_t **arms)
+{
+    int i;
+    gentity_t *ent;
+
+    if(!level.oc)
+        return 0;
+
+    for(i = 0; arms[i]; i++)
+    {
+        ent = arms[i];
+
+        if(ent == arm)
+        {
+            return 1;
+        }
+    }
+
+    return 0;
+}
+
+int G_ClearArms(gentity_t **arms)
+{
+    int i;
+
+    if(!level.oc)
+        return 0;
+
+    if(!arms)
+        return 0;
+
+    for(i = 0; i < level.totalArmouries; i++)
+    {
+        arms[i] = NULL;
+    }
+
+    return 0;
+}
+
+int G_StructureBuilt( gentity_t *ent )
+{
+    int i;
+    gentity_t **tmp;
+    oc_scrimTeam_t *si;
+
+    if(!level.oc)
+        return 0;
+
+    if(ent->s.modelindex == BA_H_MEDISTAT)
+    {
+        level.totalMedistations++;
+
+//        for(si = level.scrimTeam + 1; si; si = si->next)
+        for(si = level.scrimTeam + 1; si < level.scrimTeam + MAX_SCRIM_TEAMS; si++)
+        {
+            if(si->active)
+            {
+                if(si->medis)
+                {
+                    tmp = G_Alloc( ( level.totalMedistations + 1 ) * sizeof( gentity_t * ) );
+                    memcpy(tmp, si->medis, level.totalMedistations * sizeof( gentity_t * ));
+                    G_Free(si->medis);
+                    si->medis = G_Alloc( ( level.totalMedistations + 1 ) * sizeof( gentity_t * ) );
+                    memcpy(si->medis, tmp, level.totalMedistations * sizeof( gentity_t * ));
+                }
+                else
+                {
+                    si->medis = G_Alloc( ( level.totalMedistations + 1 ) * sizeof( gentity_t * ) );
+                }
+            }
+        }
+        for( i = 0; i < MAX_CLIENTS; i++ )
+        {
+            if(g_entities[i].client && level.clients[i].pers.connected == CON_CONNECTED && level.clients[i].pers.medis)
+            {
+                tmp = G_Alloc( ( level.totalMedistations + 1 ) * sizeof( gentity_t * ) );
+                memcpy(tmp, level.clients[i].pers.medis, level.totalMedistations * sizeof( gentity_t * ));
+                G_Free(level.clients[i].pers.medis);
+                level.clients[i].pers.medis = G_Alloc( ( level.totalMedistations + 1 ) * sizeof( gentity_t * ) );
+                memcpy(level.clients[i].pers.medis, tmp, level.totalMedistations * sizeof( gentity_t * ));
+            }
+            else if(g_entities[i].client && level.clients[i].pers.connected)
+            {
+                level.clients[i].pers.medis = G_Alloc( ( level.totalMedistations + 1 ) * sizeof( gentity_t * ) );
+            }
+
+            if(g_entities[i].client && level.clients[i].pers.connected == CON_CONNECTED && level.clients[i].pers.medisLastCheckpoint)
+            {
+                tmp = G_Alloc( ( level.totalMedistations + 1 ) * sizeof( gentity_t * ) );
+                memcpy(tmp, level.clients[i].pers.medisLastCheckpoint, level.totalMedistations * sizeof( gentity_t * ));
+                G_Free(level.clients[i].pers.medisLastCheckpoint);
+                level.clients[i].pers.medisLastCheckpoint = G_Alloc( ( level.totalMedistations + 1 ) * sizeof( gentity_t * ) );
+                memcpy(level.clients[i].pers.medisLastCheckpoint, tmp, level.totalMedistations * sizeof( gentity_t * ));
+            }
+            else if(g_entities[i].client && level.clients[i].pers.connected == CON_CONNECTED)
+            {
+                level.clients[i].pers.medisLastCheckpoint = G_Alloc( ( level.totalMedistations + 1 ) * sizeof( gentity_t * ) );
+            }
+        }
+    }
+    else if(ent->s.modelindex == BA_H_ARMOURY)
+    {
+        level.totalArmouries++;
+
+//        for(si = level.scrimTeam + 1; si; si = si->next)
+        for(si = level.scrimTeam + 1; si < level.scrimTeam + MAX_SCRIM_TEAMS; si++)
+        {
+            if(si->active)
+            {
+                if(si->arms)
+                {
+                    tmp = G_Alloc( ( level.totalArmouries + 1 ) * sizeof( gentity_t * ) );
+                    memcpy(tmp, si->arms, level.totalArmouries * sizeof( gentity_t * ));
+                    G_Free(si->arms);
+                    si->arms = G_Alloc( ( level.totalArmouries + 1 ) * sizeof( gentity_t * ) );
+                    memcpy(si->arms, tmp, level.totalArmouries * sizeof( gentity_t * ));
+                }
+                else
+                {
+                    si->arms = G_Alloc( ( level.totalArmouries + 1 ) * sizeof( gentity_t * ) );
+                }
+            }
+        }
+        for( i = 0; i < MAX_CLIENTS; i++ )
+        {
+            if(g_entities[i].client && level.clients[i].pers.connected == CON_CONNECTED && level.clients[i].pers.arms)
+            {
+                tmp = G_Alloc( ( level.totalArmouries + 1 ) * sizeof( gentity_t * ) );
+                memcpy(tmp, level.clients[i].pers.arms, level.totalArmouries * sizeof( gentity_t * ));
+                G_Free(level.clients[i].pers.arms);
+                level.clients[i].pers.arms = G_Alloc( ( level.totalArmouries + 1 ) * sizeof( gentity_t * ) );
+                memcpy(level.clients[i].pers.arms, tmp, level.totalArmouries * sizeof( gentity_t * ));
+            }
+            else if(g_entities[i].client && level.clients[i].pers.connected == CON_CONNECTED)
+            {
+                level.clients[i].pers.arms = G_Alloc( ( level.totalArmouries + 1 ) * sizeof( gentity_t * ) );
+            }
+
+            if(g_entities[i].client && level.clients[i].pers.connected == CON_CONNECTED && level.clients[i].pers.armsLastCheckpoint)
+            {
+                tmp = G_Alloc( ( level.totalArmouries + 1 ) * sizeof( gentity_t * ) );
+                memcpy(tmp, level.clients[i].pers.armsLastCheckpoint, level.totalArmouries * sizeof( gentity_t * ));
+                G_Free(level.clients[i].pers.armsLastCheckpoint);
+                level.clients[i].pers.armsLastCheckpoint = G_Alloc( ( level.totalArmouries + 1 ) * sizeof( gentity_t * ) );
+                memcpy(level.clients[i].pers.armsLastCheckpoint, tmp, level.totalArmouries * sizeof( gentity_t * ));
+            }
+            else if(g_entities[i].client && level.clients[i].pers.connected == CON_CONNECTED)
+            {
+                level.clients[i].pers.armsLastCheckpoint = G_Alloc( ( level.totalArmouries + 1 ) * sizeof( gentity_t * ) );
+            }
+        }
+    }
+
+    return 0;
+}
+
+int G_StructureDecon( gentity_t *ent )
+{
+    int i;
+    gentity_t **tmp;
+    oc_scrimTeam_t *si;
+
+    if(!level.oc)
+        return 0;
+
+    if(!ent->powered)
+        return 0;
+
+    if(ent->s.modelindex == BA_H_MEDISTAT)
+    {
+        level.totalMedistations--;
+
+        if(level.totalMedistations)
+        {
+//            for(si = level.scrimTeam + 1; si; si = si->next)
+            for(si = level.scrimTeam + 1; si < level.scrimTeam + MAX_SCRIM_TEAMS; si++)
+            {
+                if(si->active)
+                {
+                    tmp = G_Alloc( ( level.totalMedistations + 2 ) * sizeof( gentity_t * ) );
+                    memcpy(tmp, si->medis, ( level.totalMedistations ) * sizeof( gentity_t * ));
+                    G_RemoveMedi(tmp, ent);
+                    G_Free(si->medis);
+                    si->medis = G_Alloc( ( level.totalMedistations + 1 ) * sizeof( gentity_t * ) );
+                    memcpy(si->medis, tmp, level.totalMedistations * sizeof( gentity_t * ));
+                }
+            }
+            for( i = 0; i < MAX_CLIENTS; i++ )
+            {
+                if(g_entities[i].client && level.clients[i].pers.connected == CON_CONNECTED && level.clients[i].pers.medis && level.clients[i].pers.medisLastCheckpoint)  // if medis is not allocated, neither should medisLastCheckpoint.  The inverse is also true
+                {
+                    tmp = G_Alloc( ( level.totalMedistations + 2 ) * sizeof( gentity_t * ) );
+                    memcpy(tmp, level.clients[i].pers.medis, ( level.totalMedistations ) * sizeof( gentity_t * ));
+                    G_RemoveMedi(tmp, ent);
+                    G_Free(level.clients[i].pers.medis);
+                    level.clients[i].pers.medis = G_Alloc( ( level.totalMedistations + 1 ) * sizeof( gentity_t * ) );
+                    memcpy(level.clients[i].pers.medis, tmp, level.totalMedistations * sizeof( gentity_t * ));
+
+                    tmp = G_Alloc( ( level.totalMedistations + 2 ) * sizeof( gentity_t * ) );
+                    memcpy(tmp, level.clients[i].pers.medisLastCheckpoint, ( level.totalMedistations ) * sizeof( gentity_t * ));
+                    G_RemoveMedi(tmp, ent);
+                    G_Free(level.clients[i].pers.medisLastCheckpoint);
+                    level.clients[i].pers.medisLastCheckpoint = G_Alloc( ( level.totalMedistations + 1 ) * sizeof( gentity_t * ) );
+                    memcpy(level.clients[i].pers.medisLastCheckpoint, tmp, level.totalMedistations * sizeof( gentity_t * ));
+                }
+            }
+        }
+        else
+        {
+//            for(si = level.scrimTeam + 1; si; si = si->next)
+            for(si = level.scrimTeam + 1; si < level.scrimTeam + MAX_SCRIM_TEAMS; si++)
+            {
+                if(si->active)
+                {
+                    G_Free(si->medis);
+                    si->medis = NULL;
+                }
+            }
+            for( i = 0; i < MAX_CLIENTS; i++ )
+            {
+                if(g_entities[i].client && level.clients[i].pers.connected == CON_CONNECTED && level.clients[i].pers.medis && level.clients[i].pers.medisLastCheckpoint)  // if medis is not allocated, neither should medisLastCheckpoint.  The inverse is also true
+                {
+                    G_Free(level.clients[i].pers.medis);
+                    level.clients[i].pers.medis = NULL;
+
+                    G_Free(level.clients[i].pers.medisLastCheckpoint);
+                    level.clients[i].pers.medisLastCheckpoint = NULL;
+                }
+            }
+        }
+    }
+    else if(ent->s.modelindex == BA_H_ARMOURY)
+    {
+        level.totalArmouries--;
+
+        if(level.totalArmouries)
+        {
+//            for(si = level.scrimTeam + 1; si; si = si->next)
+            for(si = level.scrimTeam + 1; si < level.scrimTeam + MAX_SCRIM_TEAMS; si++)
+            {
+                if(si->active)
+                {
+                    tmp = G_Alloc( ( level.totalArmouries + 2 ) * sizeof( gentity_t * ) );
+                    memcpy(tmp, si->arms, ( level.totalArmouries ) * sizeof( gentity_t * ));
+                    G_RemoveMedi(tmp, ent);
+                    G_Free(si->arms);
+                    si->arms = G_Alloc( ( level.totalArmouries + 1 ) * sizeof( gentity_t * ) );
+                    memcpy(si->arms, tmp, level.totalArmouries * sizeof( gentity_t * ));
+                }
+            }
+            for( i = 0; i < MAX_CLIENTS; i++ )
+            {
+                if(g_entities[i].client && level.clients[i].pers.connected == CON_CONNECTED && level.clients[i].pers.arms && level.clients[i].pers.armsLastCheckpoint)  // if medis is not allocated, neither should medisLastCheckpoint.  The inverse is also true
+                {
+                    tmp = G_Alloc( ( level.totalArmouries + 2 ) * sizeof( gentity_t * ) );
+                    memcpy(tmp, level.clients[i].pers.arms, ( level.totalArmouries ) * sizeof( gentity_t * ));
+                    G_RemoveMedi(tmp, ent);
+                    G_Free(level.clients[i].pers.arms);
+                    level.clients[i].pers.arms = G_Alloc( ( level.totalArmouries + 1 ) * sizeof( gentity_t * ) );
+                    memcpy(level.clients[i].pers.arms, tmp, level.totalArmouries * sizeof( gentity_t * ));
+
+                    tmp = G_Alloc( ( level.totalArmouries + 2 ) * sizeof( gentity_t * ) );
+                    memcpy(tmp, level.clients[i].pers.armsLastCheckpoint, ( level.totalArmouries ) * sizeof( gentity_t * ));
+                    G_RemoveMedi(tmp, ent);
+                    G_Free(level.clients[i].pers.armsLastCheckpoint);
+                    level.clients[i].pers.armsLastCheckpoint = G_Alloc( ( level.totalArmouries + 1 ) * sizeof( gentity_t * ) );
+                    memcpy(level.clients[i].pers.armsLastCheckpoint, tmp, level.totalArmouries * sizeof( gentity_t * ));
+                }
+            }
+        }
+        else
+        {
+//            for(si = level.scrimTeam + 1; si; si = si->next)
+            for(si = level.scrimTeam + 1; si < level.scrimTeam + MAX_SCRIM_TEAMS; si++)
+            {
+                if(si->active)
+                {
+                    G_Free(si->arms);
+                    si->arms = NULL;
+                }
+            }
+            for( i = 0; i < MAX_CLIENTS; i++ )
+            {
+                if(g_entities[i].client && level.clients[i].pers.connected == CON_CONNECTED && level.clients[i].pers.arms && level.clients[i].pers.armsLastCheckpoint)  // if medis is not allocated, neither should medisLastCheckpoint.  The inverse is also true
+                {
+                    G_Free(level.clients[i].pers.arms);
+                    level.clients[i].pers.arms = NULL;
+
+                    G_Free(level.clients[i].pers.armsLastCheckpoint);
+                    level.clients[i].pers.armsLastCheckpoint = NULL;
+                }
+            }
+        }
+    }
+
+    return 0;
+}
+
+int G_OCPlayerCheckpoint(gentity_t *checkpoint, gentity_t *ent)
+{
+    if(!level.oc)
+        return 0;
+
+    if(!checkpoint)
+        return 0;
+
+    if(!ent)
+        return 0;
+
+    if(!ent->client)
+        return 0;
+
+    if(!checkpoint)
+        return 0;
+
+    if(checkpoint->client)
+        return 0;
+
+    if(checkpoint->s.modelindex != BA_A_BOOSTER)
+        return 0;
+
+    // prevent against checkpoint exploit
+    if(!ent->client->pers.restartocOKtime && level.time < ent->client->pers.restartocOKtime)
+        return 0;
+
+    if(ent->health <= 0)
+        return 0;
+
+    // do nothing if preparing for a match
+    if(ent->client->pers.ocTeam && level.ocScrimState != OC_STATE_PLAY)
+        return 0;
+
+    // good to go...
+    ent->client->pers.restartocOKtime = 0;
+
+    // print "Checkpoint!" if the player shot a new checkpoint
+    // note that a checkpoint being processed is regardless of
+    // it being printed or CP'd
+    if(ent->client->pers.lastOCCheckpoint != checkpoint)  // &&
+    if(!ent->client->pers.ocTeam || level.scrimTeam[ent->client->pers.ocTeam].lastOCCheckpoint != checkpoint)
+    {
+        G_ClientPrint(ent, "Checkpoint!", CLIENT_SPECTATORS);
+        if(ent->client->pers.ocTeam)
+            G_ClientPrint(ent, va("Checkpoint! (%s^7)", ent->client->pers.netname), CLIENT_OCTEAM | CLIENT_NOTARGET);
+    }
+    G_ClientCP(ent, "Checkpoint!", NULL, CLIENT_SPECTATORS);
+
+    // update checkpoint
+
+    // update checkpoint data
+    if(ent->client->pers.ocTeam)
+    {
+        oc_scrimTeam_t *t;
+        OC_GETTEAM(t, level.scrimTeam, ent->client->pers.ocTeam);
+        G_MergeMedis(t->medis, ent->client->pers.medis);
+        G_MergeMedis(t->arms, ent->client->pers.arms);
+        G_ClearMedis(ent->client->pers.medis);
+        G_ClearArms(ent->client->pers.arms);
+        t->lastOCCheckpoint = checkpoint;
+    }
+    else
+    {
+        ent->client->pers.lastOCCheckpoint = checkpoint;
+        if(level.totalMedistations && ent->client->pers.medisLastCheckpoint && ent->client->pers.medis)
+            memcpy( ent->client->pers.medisLastCheckpoint, ent->client->pers.medis, ( level.totalMedistations + 1 ) * sizeof( int ) );
+        else if(level.totalMedistations)
+            G_ClientPrint(ent, "^1Error saving checkpoint information", CLIENT_SPECTATORS);
+        if(level.totalArmouries && ent->client->pers.armsLastCheckpoint && ent->client->pers.arms)
+            memcpy( ent->client->pers.armsLastCheckpoint, ent->client->pers.arms, ( level.totalArmouries + 1 ) * sizeof( int ) );
+        else if(level.totalArmouries)
+            G_ClientPrint(ent, "^1Error saving checkpoint information", CLIENT_SPECTATORS);
+    }
+
+    return 0;
+}
+
+int G_OCPlayerSpawn(gentity_t *ent)
+{
+    int maxAmmo, maxClips;
+
+    if(level.oc)
+    {
+        if(ent && ent->client)
+        {
+            ent->client->pers.lastAliveTime = trap_Milliseconds( );
+            BG_FindAmmoForWeapon( ent->client->ps.weapon, &maxAmmo, &maxClips );
+            if( BG_FindUsesEnergyForWeapon( ent->client->ps.weapon ) &&
+                BG_InventoryContainsUpgrade( UP_BATTPACK, ent->client->ps.stats ) )
+              maxAmmo = (int)( (float)maxAmmo * BATTPACK_MODIFIER );
+            BG_PackAmmoArray( ent->client->ps.weapon, ent->client->ps.ammo, ent->client->ps.misc, maxAmmo, maxClips );
+            G_AddCreditToClient( ent->client, HUMAN_MAX_CREDITS, qtrue );
+            VectorScale(ent->client->ps.velocity, 0.0, ent->client->ps.velocity);
+            if(ent->client->pers.teamSelection == PTE_ALIENS)
+            {
+//                VectorScale(ent->s.angles2, 0.0, ent->s.angles2);
+            }
+        }
+    }
+
+    return 0;
+}
+
+int G_OCPlayerDie( gentity_t *ent )
+{
+    int i, j;
+    gentity_t *client;
+
+    if(level.oc)
+    {
+        if(ent->client->pers.ocTeam)
+        {
+            if(level.ocScrimState == OC_STATE_PLAY)
+            {
+                if(level.ocScrimMode == OC_MODE_MEDI)
+                {
+                    int lost = 0;
+                    gentity_t *medi;
+                    oc_scrimTeam_t *t;
+                    OC_GETTEAM(t, level.scrimTeam, ent->client->pers.ocTeam);
+
+                    // don't do anything if they already won
+                    if(t->time)
+                        return 0;
+
+                    // iterate over each medi.  If no other player has the same medi
+                    // notify the team that is lost x medis
+                    for(i = 0, medi = ent->client->pers.medis[0]; medi; medi = ent->client->pers.medis[++i])
+                    {
+                        qboolean used = qfalse;
+                        if(!G_HasMediBeenUsed(medi, t->medis))
+                        {
+                            for( j = 0; j < MAX_CLIENTS; j++ )
+                            {
+                                client = g_entities + i;
+                                if(client->client && client->client->pers.ocTeam == ent->client->pers.ocTeam && G_HasMediBeenUsed(medi, client->client->pers.medis))
+                                {
+                                    used = qtrue;
+                                }
+                            }
+                        }
+                        if(!used)
+                            lost++;
+                    }
+                    G_ClearMedis(ent->client->pers.medis);
+                    if(lost)
+                        G_ClientPrint(ent, va("Your team lost %d medical stations!", lost), CLIENT_OCTEAM);
+                }
+                if(level.ocScrimMode == OC_MODE_ARM)
+                {
+                    int lost = 0;
+                    gentity_t *arm;
+                    oc_scrimTeam_t *t;
+                    OC_GETTEAM(t, level.scrimTeam, ent->client->pers.ocTeam);
+
+                    // iterate over each arm.  If no other player has the same arm
+                    // notify the team that is lost x arms
+                    for(i = 0, arm = ent->client->pers.arms[0]; arm; arm = ent->client->pers.arms[++i])
+                    {
+                        qboolean used = qfalse;
+                        if(!G_HasArmBeenUsed(arm, t->arms))
+                        {
+                            for( j = 0; j < MAX_CLIENTS; j++ )
+                            {
+                                client = g_entities + i;
+                                if(client->client && client->client->pers.ocTeam == ent->client->pers.ocTeam && G_HasArmBeenUsed(arm, client->client->pers.arms))
+                                {
+                                    used = qtrue;
+                                }
+                            }
+                        }
+                        if(!used)
+                            lost++;
+                    }
+                    G_ClearArms(ent->client->pers.arms);
+                    if(lost)
+                        G_ClientPrint(ent, va("Your team lost %d armouries!", lost), CLIENT_OCTEAM);
+                }
+            }
+        }
+        else
+        {
+            if(level.totalMedistations)
+                memcpy( ent->client->pers.medis, ent->client->pers.medisLastCheckpoint, ( level.totalMedistations + 1 ) * sizeof( gentity_t * ) );
+            if(level.totalArmouries)
+                memcpy( ent->client->pers.arms, ent->client->pers.armsLastCheckpoint, ( level.totalArmouries + 1 ) * sizeof( gentity_t * ) );
+        }
+    }
+
+    return 0;
+}
+
+int G_CanUseBonus( gentity_t *ent )
+{
+  if( ent->client->pers.hasCheated )
+  {
+    return 0;
+  }
+  if( ent->client->pers.cheated )
+  {
+    return 0;
+  }
+  if( G_admin_canEditOC( ent ) )
+  {
+    return 0;
+  }
+  if( BG_InventoryContainsUpgrade( UP_JETPACK, ent->client->ps.stats ) )
+  {
+    G_ClientCP( ent, OC_MEDICANNOTUSEMESSAGE, NULL, CLIENT_SPECTATORS );
+    return 0;
+  }
+  return 1;
+}
+
+int G_WeaponIsReserved( weapon_t weapon )
+{
+    oc_scrimTeam_t *si;
+
+    if(!level.oc)
+        return 0;
+
+//    for(si = level.scrimTeam + 1; si; si = si->next)
+    for(si = level.scrimTeam + 1; si < level.scrimTeam + MAX_SCRIM_TEAMS; si++)
+    {
+        if(si->active)
+        {
+            if(weapon == si->weapon)
+            {
+                return 1;
+            }
+        }
+    }
+
+    return 0;
+}
+
+int G_WeaponRemoveReserved( gentity_t *ent )
+{
+    int res = 0;
+    oc_scrimTeam_t *si;
+
+    if(!level.oc)
+        return 0;
+
+    if(!ent->client)
+        return 0;
+
+//    for(si = level.scrimTeam + 1; si; si = si->next)
+    for(si = level.scrimTeam + 1; si < level.scrimTeam + MAX_SCRIM_TEAMS; si++)
+    {
+        if(si->active)
+        {
+            if(BG_InventoryContainsWeapon(si->weapon, ent->client->ps.stats))
+            {
+                BG_RemoveWeaponFromInventory(si->weapon, ent->client->ps.stats);
+                G_ForceWeaponChange(ent, WP_NONE);
+                res = 1;
+            }
+        }
+    }
+
+    return res;
+}
+
+int G_OCSingleScrim( void )  // are no more than one players per team active?
+{
+    int i;
+    gentity_t *ent;
+    int numberOf[MAX_SCRIM_TEAMS];
+
+    if(!level.oc)
+        return 0;
+
+    // do not check for an active scrim playing because the function can be
+    // called to determine how to start a scrim
+
+    for(i = 0; i < MAX_SCRIM_TEAMS; i++)
+    {
+        numberOf[i] = 0;
+    }
+
+    for(i = 0; i < level.maxclients; i++)
+    {
+        ent = &g_entities[ i ];
+
+        if(ent->client && ent->client->pers.connected == CON_CONNECTED && ent->client->pers.ocTeam < MAX_SCRIM_TEAMS)
+            numberOf[ent->client->pers.ocTeam]++;
+    }
+
+    for(i = 1; i < MAX_SCRIM_TEAMS; i++)  // skip the NULL oc team
+    {
+        if(numberOf[i] > 1)
+            return 0;
+    }
+
+    return 1;
+}
+
+int G_OCScrimEnd( void )
+{
+    int i;
+    gentity_t *ent;
+    oc_scrimTeam_t *si;
+    //oc_scrimTeam_t *tmp;
+
+    if(!level.oc)
+        return 0;
+
+    if(level.ocScrimState <= OC_STATE_NONE)
+        return 0;
+
+    level.ocEndsTime = 0;
+
+    G_ClientPrint(NULL, "The OC scrim ends", 0);
+
+    for( i = 0; i < level.maxclients; i++ )
+    {
+        ent = &g_entities[ i ];
+
+        if(ent->client->pers.ocTeam)
+            G_RestartClient(ent, 1, 1);
+    }
+
+//    for(si = level.scrimTeam + 1; si; )
+    for(si = level.scrimTeam + 1; si < level.scrimTeam + MAX_SCRIM_TEAMS; si++)
+    {
+        if(si->active)
+        {
+            if(!si->time)
+            {
+                // hack: stimulate each player in the team hitting checkpoint
+                // to mimic merging medis
+                for(i = 0; i < level.maxclients; i++)
+                {
+                    ent = &g_entities[ i ];
+
+                    if(ent->client->pers.connected == CON_CONNECTED)
+                    {
+                        if(ent->client->pers.ocTeam == si - level.scrimTeam)
+                        {
+                            G_OCPlayerCheckpoint(ent, ent);
+                        }
+                    }
+                }
+
+                if(level.ocScrimMode == OC_MODE_MEDI)
+                    G_ClientPrint(NULL, va("^7%s^2 (%ss^7) loses the OC scrim (%d/%d medical stations)", si->name, BG_FindHumanNameForWeapon(si->weapon), G_NumberOfMedis(si->medis), level.totalMedistations), 0);
+                if(level.ocScrimMode == OC_MODE_ARM)
+                    G_ClientPrint(NULL, va("^7%s^2 (%ss^7) loses the OC scrim (%d/%d armouries)", si->name, BG_FindHumanNameForWeapon(si->weapon), G_NumberOfArms(si->arms), level.totalArmouries), 0);
+            }
+
+//            tmp = si->next;
+//            G_Free(si);
+//            si = tmp;
+            G_Free(si->medis);
+            G_Free(si->arms);
+            si->active = 0;
+        }
+    }
+
+    level.ocScrimState = OC_STATE_NONE;
+
+    return 0;
+}
+
+oc_scrimTeam_t *G_OCNewScrimTeam( char *name, weapon_t weapon, char *err, int errlen )
+{
+    oc_scrimTeam_t *si;
+    char buf[MAX_NAME_LENGTH];
+
+    if(!level.oc)
+        return 0;
+
+    if(!name)
+        return 0;
+
+    if(err)
+        *err = 0;
+
+    Q_strncpyz(buf, name, sizeof(buf));
+
+    // check the weapon is valid
+    if(!G_OCScrimValidWeapon(weapon))
+    {
+        if(err)
+            Q_strncpyz(err, va("invalid weapon %s^7", BG_FindHumanNameForWeapon(weapon)), errlen);
+        return NULL;
+    }
+
+    // check the name is valid
+    if(!G_OCScrimValidTeamName(buf))
+    {
+        if(err)
+            Q_strncpyz(err, va("invalid team name %s^7", name), errlen);
+        return NULL;
+    }
+
+    // does a team with the same name already exist?
+    if(G_OCScrimTeam(buf))
+    {
+        if(err)
+            Q_strncpyz(err, va("%s^7 already exists", buf), errlen);
+        return NULL;
+    }
+
+    // iterate through scrim teams and find an available team
+    for(si = level.scrimTeam + 1; si < level.scrimTeam + MAX_SCRIM_TEAMS; si++)
+    {
+        if( !si->active )
+        {
+            Q_strncpyz(si->name, buf, sizeof(si->name));
+            si->weapon = weapon;
+            if(level.totalMedistations)
+                si->medis = G_Alloc( ( level.totalMedistations + 1 ) * sizeof( gentity_t * ) );
+            if(level.totalArmouries)
+                si->arms = G_Alloc( ( level.totalArmouries + 1 ) * sizeof( gentity_t * ) );
+            si->active = 1;
+            return si;
+        }
+    }
+
+    if(err)
+        Q_strncpyz(err, va("the maximum number of scrim teams has been reached (%d)", MAX_SCRIM_TEAMS), errlen);
+    return NULL;
+}
+
+oc_scrimTeam_t *G_OCScrimTeam( char *name )
+{
+    oc_scrimTeam_t *si;
+    char teamName[MAX_NAME_LENGTH];
+    char buf[MAX_NAME_LENGTH];
+
+    if(!level.oc)
+        return NULL;
+
+    if(!name)
+        return NULL;
+
+    Q_strncpyz(teamName, name, sizeof(teamName));
+    G_SanitiseName(teamName, buf);
+
+    for(si = level.scrimTeam + 1; si < level.scrimTeam + MAX_SCRIM_TEAMS; si++)
+    {
+        if( si->active )
+        {
+            if(sizeof(si->name) > sizeof(teamName))
+                continue;  // wimp out
+            G_SanitiseName(si->name, teamName);
+            if(!strcmp(buf, teamName))
+                return si;
+        }
+    }
+
+    return NULL;
+}
+
+int G_OCScrimValidWeapon( weapon_t weapon )
+{
+    if(!level.oc)
+        return 0;
+
+    if(!weapon)
+        return 0;
+
+    if(weapon == WP_NONE)
+        return 0;
+
+    if(BG_FindTeamForWeapon(weapon) != WUT_HUMANS)
+        return 0;
+
+    if(!BG_FindStagesForWeapon(weapon, g_humanStage.integer) || !BG_WeaponIsAllowed(weapon))
+        return 0;
+
+    // don't allow common weapons (blaster, rifle, ckit, etc)
+    if(weapon == WP_BLASTER)
+        return 0;
+
+    if(weapon == WP_MACHINEGUN)
+        return 0;
+
+    if(weapon == WP_HBUILD)
+        return 0;
+
+    if(weapon == WP_HBUILD2)
+        return 0;
+
+    if(weapon == WP_LOCKBLOB_LAUNCHER)
+        return 0;
+
+    if(weapon == WP_HIVE)
+        return 0;
+
+    if(weapon == WP_TESLAGEN)
+        return 0;
+
+    if(weapon == WP_MGTURRET)
+        return 0;
+
+//    if(weapon == WP_GRENADE)
+//        return 0;
+
+    return 1;
+}
+
+int G_OCScrimValidTeamName( char *name )
+{
+    if(!level.oc)
+        return 0;
+
+    if(!name)
+        return 0;
+
+    // team name needs at least two characters
+    if(strlen(name) < 2 || !*name)
+        return 0;
+
+    if(!strcmp(name, "0"))
+    {
+        return 0;
+    }
+
+    for(; *name; name++)
+    {
+        // obvious bad characters
+        if(*name == ';')
+            return 0;
+        if(*name == '\\')
+            return 0;
+        if(*name == '"')
+            return 0;
+        if(*name == '%')
+            return 0;
+//        if(*name == '\'')
+//            return 0;
+        if(*name == '/')
+            return 0;
+        if(*name == '\n' )
+            return 0;
+        if(*name == '\r' )
+            return 0;
+
+        // no control characters
+        if(*name < 32 )
+            return 0;
+    }
+
+    return 1;
+}
+
+int G_OCScrimTeamRemovePlayer( gentity_t *ent )
+{
+    int i, otherPlayers = 0, otherTeams = 0, ocTeam;
+    gentity_t *client;
+
+    if(!level.oc)
+        return 0;
+
+    if(!ent)
+        return 0;
+
+    if(!ent->client)
+        return 0;
+
+    ocTeam = ent->client->pers.ocTeam;
+
+    if(!ocTeam)
+        return 0;
+
+    G_RestartClient(ent, 1, 1);
+    G_ClientPrint(NULL, va("%s^7 let team %s^7 down", ent->client->pers.netname, level.scrimTeam[ocTeam].name), 0);
+
+    for( i = 0; i < level.maxclients; i++ )
+    {
+        client = &g_entities[ i ];
+
+        if(client->client->pers.ocTeam == ocTeam)
+            otherPlayers = 1;
+    }
+
+    if(!otherPlayers)
+    {
+        G_ClientPrint(NULL, va("OC Scrim team %s^7 was dropped due to emptiness", level.scrimTeam[ocTeam].name), 0);
+        G_Free(level.scrimTeam[ocTeam].medis);
+        G_Free(level.scrimTeam[ocTeam].arms);
+        level.scrimTeam[ocTeam].active = 0;
+
+        for( i = 0; i < level.maxclients; i++ )
+        {
+            client = &g_entities[ i ];
+
+            if(client->client->pers.ocTeam)
+                otherTeams = 1;
+        }
+
+
+        if(!otherTeams)
+        {
+            G_OCScrimEnd();
+            G_ClientPrint(NULL, "OC Scrim cancelled due to emptiness", 0);
+        }
+    }
+
+    return 0;
+}
+
+int G_OCScrimTeamEmpty( void )
+{
+    int i;
+    oc_scrimTeam_t *si;
+    qboolean t = qfalse, p = qfalse;
+
+    if(!level.oc)
+        return 0;
+
+    for(si = level.scrimTeam + 1; si < level.scrimTeam + MAX_SCRIM_TEAMS; si++)
+    {
+        if(si->active)
+        {
+            t = qtrue;
+        }
+    }
+
+    for( i = 0; i < level.maxclients; i++ )
+    {
+        if(g_entities[i].client->pers.ocTeam)
+            p = qtrue;
+    }
+
+    if(t != p)
+    {
+        // something went wrong...
+        G_OCScrimEnd();
+    }
+
+    return !(t || p);
+}
+
+int G_OCScrimAllWon( void )
+{
+    oc_scrimTeam_t *si;
+
+    if(!level.oc)
+        return 0;
+
+//    for(i = level.scrimTeam + 1; i; i = i->next)
+    for(si = level.scrimTeam + 1; si < level.scrimTeam + MAX_SCRIM_TEAMS; si++)
+    {
+        if(si->active)
+        {
+            if(!si->time)
+            {
+                return 0;
+            }
+        }
+    }
+
+    return 1;
+}
+
+
+
 //==================================================================================
 
 /*
@@ -1794,13 +3766,54 @@
   int       entityList[ MAX_GENTITIES ];
   vec3_t    mins, maxs;
   int       i, num;
-  gentity_t *player;
+  gentity_t *player = NULL;  /* shut up gcc */
   qboolean  occupied = qfalse;
 
-  self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex );
+//  if(level.oc)
+//    self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex ) + OC_BUILDABLE_THINK_OFFSET;
+//  else
+    self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex );
 
+  if( level.oc )
+  {
+    switch( self->groupID )
+    {
+      case 0:
+      self->powered = G_FindPower( self );
+      break;
+
+      case 1:
+      self->powered = 1;
+      break;
+
+      case 2:
+      self->powered = 0;
+      break;
+
+      default:
+      self->powered = G_FindPower( self );
+      break;
+    }
+  }
+  else
+    self->powered = G_FindPower( self );
+
+  if( level.oc )
+  {
+    if( !self->powered && !self->verifyUnpowered )
+    {
+      self->verifyUnpowered = qtrue;
+      G_StructureDecon( self );
+    }
+    if( self->powered && self->verifyUnpowered )  // rare case of repowering
+    {
+      self->verifyUnpowered = qfalse;
+      G_StructureBuilt( self );
+    }
+  }
+
   //make sure we have power
-  if( !( self->powered = G_FindPower( self ) ) )
+  if( !self->powered )
   {
     if( self->active )
     {
@@ -1832,6 +3845,8 @@
     {
       player = &g_entities[ entityList[ i ] ];
 
+      G_UseMedi( player, self );
+
       if( player->client && player->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
       {
         if( player->health < player->client->ps.stats[ STAT_MAX_HEALTH ] &&
@@ -1850,7 +3865,10 @@
       {
         player = &g_entities[ entityList[ i ] ];
 
-        if( player->client && player->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+        if( player->flags & FL_NOTARGET )
+          continue; // notarget cancels even beneficial effects?
+
+        if( player->client && ( player->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS || ( player->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS && level.oc ) ) )
         {
           if( player->health < player->client->ps.stats[ STAT_MAX_HEALTH ] &&
               player->client->ps.pm_type != PM_DEAD )
@@ -1864,7 +3882,7 @@
               self->active = qtrue;
             }
           }
-          else if( !BG_InventoryContainsUpgrade( UP_MEDKIT, player->client->ps.stats ) )
+          else if( !BG_InventoryContainsUpgrade( UP_MEDKIT, player->client->ps.stats ) && player->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
             BG_AddUpgradeToInventory( UP_MEDKIT, player->client->ps.stats );
         }
       }
@@ -1883,11 +3901,12 @@
       if( self->enemy->client && self->enemy->client->ps.stats[ STAT_STATE ] & SS_POISONED )
         self->enemy->client->ps.stats[ STAT_STATE ] &= ~SS_POISONED;
 
-      self->enemy->health++;
+      if( self->enemy->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+        self->enemy->health++;
 
       //if they're completely healed, give them a medkit
       if( self->enemy->health >= self->enemy->client->ps.stats[ STAT_MAX_HEALTH ] &&
-          !BG_InventoryContainsUpgrade( UP_MEDKIT, self->enemy->client->ps.stats ) )
+          !BG_InventoryContainsUpgrade( UP_MEDKIT, self->enemy->client->ps.stats ) && self->enemy->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
         BG_AddUpgradeToInventory( UP_MEDKIT, self->enemy->client->ps.stats );
     }
   }
@@ -1995,9 +4014,15 @@
   trace_t   trace;
   gentity_t *traceEnt;
 
+  if( level.oc && level.layout && level.layout[0] && G_TestLayoutFlag( level.layout, OCFL_NOALIENTURRETFIRE ) )
+    return qfalse;
+
   if( !target )
     return qfalse;
 
+  if( target->flags & FL_NOTARGET )
+    return qfalse;
+
   if( !target->client )
     return qfalse;
 
@@ -2101,13 +4126,40 @@
 {
   int firespeed = BG_FindFireSpeedForBuildable( self->s.modelindex );
 
-  self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex );
+//  if(level.oc)
+//    self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex ) + OC_BUILDABLE_THINK_OFFSET;
+//  else
+    self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex );
 
   //used for client side muzzle flashes
   self->s.eFlags &= ~EF_FIRING;
 
+  if( level.oc )
+  {
+    switch( self->groupID )
+    {
+      case 0:
+      self->powered = G_FindPower( self );
+      break;
+
+      case 1:
+      self->powered = 1;
+      break;
+
+      case 2:
+      self->powered = 0;
+      break;
+
+      default:
+      self->powered = G_FindPower( self );
+      break;
+    }
+  }
+  else
+    self->powered = G_FindPower( self );
+
   //if not powered don't do anything and check again for power next think
-  if( !( self->powered = G_FindPower( self ) ) )
+  if( !self->powered )
   {
     self->nextthink = level.time + POWER_REFRESH_TIME;
     return;
@@ -2172,10 +4224,37 @@
   int       i, num;
   gentity_t *enemy;
 
-  self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex );
+//  if(level.oc)
+//    self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex ) + OC_BUILDABLE_THINK_OFFSET;
+//  else
+    self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex );
 
+  if( level.oc )
+  {
+    switch( self->groupID )
+    {
+      case 0:
+      self->powered = G_FindPower( self );
+      break;
+
+      case 1:
+      self->powered = 1;
+      break;
+
+      case 2:
+      self->powered = 0;
+      break;
+
+      default:
+      self->powered = G_FindPower( self );
+      break;
+    }
+  }
+  else
+    self->powered = G_FindPower( self );
+
   //if not powered don't do anything and check again for power next think
-  if( !( self->powered = G_FindPower( self ) ) || !( self->dcced = G_FindDCC( self ) ) )
+  if( !self->powered || !( self->dcced = ( ( level.oc ) ? ( qtrue ) : ( G_FindDCC( self ) ) ) ) )
   {
     self->s.eFlags &= ~EF_FIRING;
     self->nextthink = level.time + POWER_REFRESH_TIME;
@@ -2197,9 +4276,12 @@
     {
       enemy = &g_entities[ entityList[ i ] ];
 
+      if( enemy->flags & FL_NOTARGET )
+    continue;
+
       if( enemy->client && enemy->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS &&
           enemy->health > 0 &&
-          Distance( enemy->s.pos.trBase, self->s.pos.trBase ) <= TESLAGEN_RANGE )
+          Distance( enemy->s.pos.trBase, self->s.pos.trBase ) <= TESLAGEN_RANGE && !G_TestLayoutFlag( level.layout, OCFL_NOALIENTESLAFIRE ) )
       {
         VectorSubtract( enemy->s.pos.trBase, self->s.pos.trBase, dir );
         VectorNormalize( dir );
@@ -2298,13 +4380,31 @@
 */
 void HSpawn_Die( gentity_t *self, gentity_t *inflictor, gentity_t *attacker, int damage, int mod )
 {
+  buildHistory_t *new;
+  new = G_Alloc( sizeof( buildHistory_t ) );
+  new->ID = ( ++level.lastBuildID > 1000 ) ? ( level.lastBuildID = 1 ) : level.lastBuildID;
+  new->ent = ( attacker && attacker->client ) ? attacker : NULL;
+  if( new->ent )
+    new->name[ 0 ] = 0;
+  else
+    Q_strncpyz( new->name, "<world>", 8 );
+  new->buildable = self->s.modelindex;
+  VectorCopy( self->s.pos.trBase, new->origin );
+  VectorCopy( self->s.angles, new->angles );
+  VectorCopy( self->s.origin2, new->origin2 );
+  VectorCopy( self->s.angles2, new->angles2 );
+  new->fate = ( attacker && attacker->client && attacker->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS ) ? BF_TEAMKILLED : BF_DESTROYED;
+  new->next = NULL;
+  G_LogBuild( new );
+
   //pretty events and cleanup
   G_SetBuildableAnim( self, BANIM_DESTROY1, qtrue );
   G_SetIdleBuildableAnim( self, BANIM_DESTROYED );
 
   self->die = nullDieFunction;
   self->powered = qfalse; //free up power
-  self->s.eFlags &= ~EF_FIRING; //prevent any firing effects
+  //prevent any firing effects and cancel structure protection
+  self->s.eFlags &= ~( EF_FIRING | EF_DBUILDER );
 
   if( self->spawned )
   {
@@ -2361,7 +4461,7 @@
     if( self->s.groundEntityNum )
     {
       if( ( ent = G_CheckSpawnPoint( self->s.number, self->s.origin,
-              self->s.origin2, BA_H_SPAWN, NULL ) ) != NULL )
+              self->s.origin2, BA_H_SPAWN, NULL, 0 ) ) != NULL )
       {
         if( ent->s.eType == ET_BUILDABLE || ent->s.number == ENTITYNUM_WORLD ||
             ent->s.eType == ET_MOVER )
@@ -2369,10 +4469,45 @@
           G_Damage( self, NULL, NULL, NULL, NULL, 10000, 0, MOD_SUICIDE );
           return;
         }
+    else if( !level.oc && g_antiSpawnBlock.integer && ent->client &&
+         ent->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+    {
+      //spawnblock protection
+      if( self->spawnBlockTime && level.time - self->spawnBlockTime > 10000 )
+      {
+        //five seconds of countermeasures and we're still blocked
+        //time for something more drastic
+        G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_TRIGGER_HURT );
+        self->spawnBlockTime += 2000;
+        //inappropriate MOD but prints an apt obituary
+      }
+      else if( self->spawnBlockTime && level.time - self->spawnBlockTime > 5000 )
+        //five seconds of blocked by client and...
+      {
+            if (!level.oc)
+            {
+        //random direction
+        vec3_t velocity;
+        velocity[0] = crandom() * g_antiSpawnBlock.integer;
+        velocity[1] = crandom() * g_antiSpawnBlock.integer;
+        velocity[2] = g_antiSpawnBlock.integer;
 
+        VectorAdd( ent->client->ps.velocity, velocity, ent->client->ps.velocity );
+        }
+            trap_SendServerCommand( ent-g_entities, "cp \"Don't spawn block!\"" );
+
+        if (level.oc)
+            G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_TRIGGER_HURT);
+      }
+      else if( !self->spawnBlockTime )
+        self->spawnBlockTime = level.time;
+        }
+
         if( ent->s.eType == ET_CORPSE )
           G_FreeEntity( ent ); //quietly remove
       }
+      else
+        self->spawnBlockTime = 0;
     }
 
     //spawn under attack
@@ -2386,12 +4521,33 @@
     self->lastHealth = self->health;
   }
 
-  self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex );
+  if(level.oc)
+    self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex ) + OC_BUILDABLE_THINK_OFFSET;
+  else
+    self->nextthink = level.time + BG_FindNextThinkForBuildable( self->s.modelindex );
 }
 
+/*
+================
+HTele_Think
 
+Think for tele
+================
+*/
+void HTele_Think( gentity_t *self )
+{
+  //make sure we have power
+  if(level.oc)
+    self->nextthink = level.time + POWER_REFRESH_TIME + OC_BUILDABLE_THINK_OFFSET;
+  else
+    self->nextthink = level.time + POWER_REFRESH_TIME;
 
+  self->powered = G_FindPower( self );
+}
 
+
+
+
 //==================================================================================
 
 
@@ -2470,7 +4626,7 @@
   //pack health, power and dcc
 
   //toggle spawned flag for buildables
-  if( !ent->spawned && ent->health > 0 )
+  if( !ent->spawned && ent->health > 0 && !level.pausedTime )
   {
     if( ent->buildTime + bTime < level.time )
       ent->spawned = qtrue;
@@ -2533,7 +4689,7 @@
 Check whether a point is within some range of a type of buildable
 ===============
 */
-qboolean G_BuildableRange( vec3_t origin, float r, buildable_t buildable )
+gentity_t *G_BuildableRange( vec3_t origin, float r, buildable_t buildable )
 {
   int       entityList[ MAX_GENTITIES ];
   vec3_t    range;
@@ -2557,10 +4713,10 @@
       continue;
 
     if( ent->s.modelindex == buildable && ent->spawned )
-      return qtrue;
+      return ent;
   }
 
-  return qfalse;
+  return NULL;
 }
 
 /*
@@ -2608,7 +4764,7 @@
   VectorAdd( minsB, originB, minsB );
   VectorAdd( maxsB, originB, maxsB );
 
-  return BoundsIntersect( minsA, maxsA, minsB, maxsB );
+  return ( level.oc ) ? ( 0 ) : ( BoundsIntersect( minsA, maxsA, minsB, maxsB ) );
 }
 
 /*
@@ -2712,14 +4868,31 @@
 {
   int       i;
   gentity_t *ent;
+  buildHistory_t *new, *last;
+  last = level.buildHistory;
 
-  if( !g_markDeconstruct.integer )
+  if( !g_markDeconstruct.integer || level.oc )
     return; // Not enabled, can't deconstruct anything
 
   for( i = 0; i < level.numBuildablesForRemoval; i++ )
   {
     ent = level.markedBuildables[ i ];
 
+    new = G_Alloc( sizeof( buildHistory_t ) );
+    new->ID = -1;
+    new->ent = NULL;
+    Q_strncpyz( new->name, "<markdecon>", 12 );
+    new->buildable = ent->s.modelindex;
+    VectorCopy( ent->s.pos.trBase, new->origin );
+    VectorCopy( ent->s.angles, new->angles );
+    VectorCopy( ent->s.origin2, new->origin2 );
+    VectorCopy( ent->s.angles2, new->angles2 );
+    new->fate = BF_DECONNED;
+    new->next = NULL;
+    new->marked = NULL;
+
+    last = last->marked = new;
+
     G_FreeEntity( ent );
   }
 }
@@ -2881,7 +5054,7 @@
   }
 
   // We still need build points, but have no candidates for removal
-  if( buildPoints > 0 && numBuildables == 0 )
+  if( buildPoints > 0 && numBuildables == 0 && !g_cheats.integer && !level.oc )
     return bpError;
 
   // Collided with something we can't remove
@@ -2913,7 +5086,7 @@
   }
 
   // Make sure we're not removing the last spawn
-  if( !g_cheats.integer && remainingSpawns > 0 && ( remainingSpawns - spawnCount ) < 1 )
+  if( !level.oc && !g_cheats.integer && remainingSpawns > 0 && ( remainingSpawns - spawnCount ) < 1 )
     return bpError;
 
   // Not enough points yielded
@@ -2969,14 +5142,19 @@
   int               buildPoints;
 
   // Stop all buildables from interacting with traces
-  G_SetBuildableLinkState( qfalse );
+  if( !level.oc && !g_cheats.integer )
+    G_SetBuildableLinkState( qfalse );
 
   BG_FindBBoxForBuildable( buildable, mins, maxs );
 
   BG_PositionBuildableRelativeToPlayer( ps, mins, maxs, trap_Trace, entity_origin, angles, &tr1 );
-  trap_Trace( &tr2, entity_origin, mins, maxs, entity_origin, ent->s.number, MASK_PLAYERSOLID );
-  trap_Trace( &tr3, ps->origin, NULL, NULL, entity_origin, ent->s.number, MASK_PLAYERSOLID );
 
+  // Stop all buildables from interacting with traces
+  G_SetBuildableLinkState( qfalse );
+
+  trap_Trace( &tr2, entity_origin, mins, maxs, entity_origin, ent->s.number, MASK_OCSOLID );
+  trap_Trace( &tr3, ps->origin, NULL, NULL, entity_origin, ent->s.number, MASK_OCSOLID );
+
   VectorCopy( entity_origin, origin );
 
   VectorCopy( tr1.plane.normal, normal );
@@ -2984,14 +5162,14 @@
   invert = BG_FindInvertNormalForBuildable( buildable );
 
   //can we build at this angle?
-  if( !( normal[ 2 ] >= minNormal || ( invert && normal[ 2 ] <= -minNormal ) ) )
+  if( !level.oc && !g_cheats.integer && !( normal[ 2 ] >= minNormal || ( invert && normal[ 2 ] <= -minNormal ) ) )
     reason = IBE_NORMAL;
 
-  if( tr1.entityNum != ENTITYNUM_WORLD )
+  if( tr1.entityNum != ENTITYNUM_WORLD && !level.oc && !g_cheats.integer )
     reason = IBE_NORMAL;
 
   //check there is enough room to spawn from (presuming this is a spawn)
-  if( G_CheckSpawnPoint( -1, origin, normal, buildable, NULL ) != NULL )
+  if( G_CheckSpawnPoint( -1, origin, normal, buildable, NULL, 0 ) != NULL )
     reason = IBE_NORMAL;
 
   contents = trap_PointContents( entity_origin, -1 );
@@ -3002,7 +5180,7 @@
     //alien criteria
 
     // Check there is an Overmind
-    if( buildable != BA_A_OVERMIND )
+    if( buildable != BA_A_OVERMIND && !g_cheats.integer && !level.oc )
     {
         tempent = G_FindBuildable( BA_A_OVERMIND );
 
@@ -3011,7 +5189,7 @@
     }
 
     //check there is creep near by for building on
-    if( BG_FindCreepTestForBuildable( buildable ) )
+    if( BG_FindCreepTestForBuildable( buildable ) && !g_cheats.integer && !level.oc )
     {
       if( !G_IsCreepHere( entity_origin ) )
         reason = IBE_NOCREEP;
@@ -3024,12 +5202,12 @@
       //this assumes the adv builder is the biggest thing that'll use the hovel
       BG_FindBBoxForClass( PCL_ALIEN_BUILDER0_UPG, builderMins, builderMaxs, NULL, NULL, NULL );
 
-      if( APropHovel_Blocked( angles, origin, normal, ent ) )
+      if( APropHovel_Blocked( angles, origin, normal, ent ) && !g_cheats.integer && !level.oc )
         reason = IBE_HOVELEXIT;
     }
 
     // Check permission to build here
-    if( tr1.surfaceFlags & SURF_NOALIENBUILD || contents & CONTENTS_NOALIENBUILD )
+    if( ( tr1.surfaceFlags & SURF_NOALIENBUILD || contents & CONTENTS_NOALIENBUILD ) && !g_cheats.integer && !level.oc )
       reason = IBE_PERMISSION;
   }
   else if( ent->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
@@ -3037,7 +5215,7 @@
     //human criteria
 
     // Check for power
-    if( G_IsPowered( entity_origin ) == BA_NONE )
+    if( G_IsPowered( entity_origin ) == BA_NONE && !g_cheats.integer && !level.oc )
     {
       //tell player to build a repeater to provide power
       if( buildable != BA_H_REACTOR && buildable != BA_H_REPEATER )
@@ -3045,11 +5223,11 @@
     }
 
     //this buildable requires a DCC
-    if( BG_FindDCCTestForBuildable( buildable ) && !G_IsDCCBuilt( ) )
+    if( BG_FindDCCTestForBuildable( buildable ) && !G_IsDCCBuilt( ) && !g_cheats.integer && !level.oc )
       reason = IBE_NODCC;
 
     //check that there is a parent reactor when building a repeater
-    if( buildable == BA_H_REPEATER )
+    if( buildable == BA_H_REPEATER && !g_cheats.integer && !level.oc )
     {
       tempent = G_FindBuildable( BA_H_REACTOR );
 
@@ -3062,16 +5240,16 @@
     }
 
     // Check permission to build here
-    if( tr1.surfaceFlags & SURF_NOHUMANBUILD || contents & CONTENTS_NOHUMANBUILD )
+    if( ( tr1.surfaceFlags & SURF_NOHUMANBUILD || contents & CONTENTS_NOHUMANBUILD ) && !g_cheats.integer && !level.oc )
       reason = IBE_PERMISSION;
   }
 
   // Check permission to build here
-  if( tr1.surfaceFlags & SURF_NOBUILD || contents & CONTENTS_NOBUILD )
+  if( ( tr1.surfaceFlags & SURF_NOBUILD || contents & CONTENTS_NOBUILD ) && !g_cheats.integer && !level.oc )
     reason = IBE_PERMISSION;
 
   // Can we only have one of these?
-  if( BG_FindUniqueTestForBuildable( buildable ) )
+  if( BG_FindUniqueTestForBuildable( buildable ) && !g_cheats.integer && !level.oc )
   {
     tempent = G_FindBuildable( buildable );
     if( tempent && !tempent->deconstruct )
@@ -3097,11 +5275,11 @@
     }
   }
 
-  if( ( tempReason = G_SufficientBPAvailable( buildable, origin ) ) != IBE_NONE )
+  if( ( tempReason = G_SufficientBPAvailable( buildable, origin ) ) != IBE_NONE && !g_cheats.integer && !level.oc )
     reason = tempReason;
 
   //this item does not fit here
-  if( reason == IBE_NONE && ( tr2.fraction < 1.0 || tr3.fraction < 1.0 ) )
+  if( reason == IBE_NONE && ( tr2.fraction < 1.0 || tr3.fraction < 1.0 ) && !g_cheats.integer && !level.oc )
     reason = IBE_NOROOM;
 
   if( reason != IBE_NONE )
@@ -3113,7 +5291,29 @@
   return reason;
 }
 
+/*
+==============
+G_BuildingExists
+==============
+*/
+qboolean G_BuildingExists( int bclass )
+{
+  int               i;
+  gentity_t         *tempent;
+  //look for an Armoury
+  for (i = 1, tempent = g_entities + i; i < level.num_entities; i++, tempent++ )
+  {
+    if( tempent->s.eType != ET_BUILDABLE )
+     continue;
+    if( tempent->s.modelindex == bclass && tempent->health > 0 )
+    {
+      return qtrue;
+    }
+  }
+  return qfalse;
+}
 
+
 /*
 ================
 G_Build
@@ -3124,8 +5324,16 @@
 static gentity_t *G_Build( gentity_t *builder, buildable_t buildable, vec3_t origin, vec3_t angles )
 {
   gentity_t *built;
+  buildHistory_t *new;
   vec3_t    normal;
 
+  // initialise the buildhistory so other functions can use it
+  if( builder && builder->client )
+  {
+    new = G_Alloc( sizeof( buildHistory_t ) );
+    G_LogBuild( new );
+  }
+
   // Free existing buildables
   G_FreeMarkedBuildables( );
 
@@ -3179,13 +5387,51 @@
   built->takedamage = qtrue;
   built->spawned = qfalse;
   built->buildTime = built->s.time = level.time;
+  built->spawnBlockTime = 0;
 
+  if( level.oc && builder->ocMediID > 0 )
+  {
+    built->ocMediID = builder->ocMediID;
+    builder->ocMediID = 0;
+  }
+
+  if( level.oc && builder->ocArmID > 0 )
+  {
+    built->ocArmID = builder->ocArmID;
+    builder->ocArmID = 0;
+  }
+
+  if( level.oc && builder->groupID > 0 )
+  {
+    built->groupID = builder->groupID;
+    builder->groupID = 0;
+  }
+
+  if( level.oc && builder->spawnGroup > 0 )
+  {
+    built->spawnGroup = builder->spawnGroup;
+    builder->spawnGroup = 0;
+  }
+
+  if( level.oc )
+  {
+    built->reserved2 = builder->reserved2;
+    builder->reserved2 = 0.0f;
+  }
+
+  if( built->s.modelindex == BA_H_SPAWN && level.oc )
+    level.numNodes++;
+
   // build instantly in cheat mode
-  if( builder->client && g_cheats.integer )
+  if( builder->client && ( g_cheats.integer || level.oc ) )
   {
     built->health = BG_FindHealthForBuildable( buildable );
     built->buildTime = built->s.time =
       level.time - BG_FindBuildTimeForBuildable( buildable );
+    if(level.oc)
+    {
+        built->groupID = 2;  // UNPOWERED
+    }
   }
 
   //things that vary for each buildable that aren't in the dbase
@@ -3244,6 +5490,7 @@
     case BA_H_SPAWN:
       built->die = HSpawn_Die;
       built->think = HSpawn_Think;
+      built->use = HSpawn_Use;
       break;
 
     case BA_H_MGTURRET:
@@ -3292,13 +5539,20 @@
   }
 
   built->s.number = built - g_entities;
-  built->r.contents = CONTENTS_BODY;
-  built->clipmask = MASK_PLAYERSOLID;
+  built->r.contents = CONTENTS_SOLID;
+  built->clipmask = CONTENTS_SOLID|CONTENTS_BODY;
   built->enemy = NULL;
   built->s.weapon = BG_FindProjTypeForBuildable( buildable );
 
   if( builder->client )
-    built->builtBy = builder->client->ps.clientNum;
+  {
+//    built->builtBy = builder->client->ps.clientNum;
+//
+//    if( builder->client->pers.designatedBuilder )
+//    {
+//      built->s.eFlags |= EF_DBUILDER; // designated builder protection
+//    }
+  }
   else
     built->builtBy = -1;
 
@@ -3348,6 +5602,33 @@
 
   trap_LinkEntity( built );
 
+  // ok we're all done building, so what we log here should be the final values
+  if( builder && builder->client ) // log ingame building only
+  {
+    new = level.buildHistory;
+    new->ID = ( ++level.lastBuildID > 1000 ) ? ( level.lastBuildID = 1 ) : level.lastBuildID;
+    new->ent = builder;
+    new->name[ 0 ] = 0;
+    new->buildable = buildable;
+    VectorCopy( built->s.pos.trBase, new->origin );
+    VectorCopy( built->s.angles, new->angles );
+    VectorCopy( built->s.origin2, new->origin2 );
+    VectorCopy( built->s.angles2, new->angles2 );
+    new->fate = BF_BUILT;
+  }
+
+  if( builder->client ) {
+    G_TeamCommand( builder->client->pers.teamSelection,
+      va( "print \"%s is ^2being built^7 by %s^7\n\"",
+        BG_FindHumanNameForBuildable( built->s.modelindex ),
+        builder->client->pers.netname ) );
+    G_LogPrintf("Build: %i %i 0: %s^7 is ^2building^7 %s\n",
+      builder->client->ps.clientNum,
+      built->s.modelindex,
+      builder->client->pers.netname,
+      BG_FindNameForBuildable( built->s.modelindex ) );
+  }
+
   return built;
 }
 
@@ -3485,12 +5766,12 @@
 
   trap_Trace( &tr, built->s.origin, built->r.mins, built->r.maxs, dest, built->s.number, built->clipmask );
 
-  if( tr.startsolid )
+  if( tr.startsolid && !level.oc )
   {
     G_Printf( S_COLOR_YELLOW "G_FinishSpawningBuildable: %s startsolid at %s\n",
               built->classname, vtos( built->s.origin ) );
     G_FreeEntity( built );
-    return;
+  return;
   }
 
   //point items in the correct direction
@@ -3502,6 +5783,8 @@
   G_SetOrigin( built, tr.endpos );
 
   trap_LinkEntity( built );
+
+  G_StructureBuilt( built );
 }
 
 /*
@@ -3514,7 +5797,7 @@
 be on an entity that hasn't spawned yet.
 ============
 */
-void G_SpawnBuildable( gentity_t *ent, buildable_t buildable )
+void G_SpawnBuildable( gentity_t *ent, buildable_t buildable, int groupID, int spawnGroup, float reserved2 )
 {
   ent->s.modelindex = buildable;
 
@@ -3522,8 +5805,64 @@
   // spawns until the third frame so they can ride trains
   ent->nextthink = level.time + FRAMETIME * 2;
   ent->think = G_FinishSpawningBuildable;
+
+  ent->groupID = groupID;
+  ent->spawnGroup = spawnGroup;
+  ent->reserved2 = reserved2;
 }
 
+ /*
+ ============
+ G_CheckDBProtection
+
+ Count how many designated builders are in both teams and
+ if none found in some team, cancel protection for all
+ structures of that team
+ ============
+ */
+
+ void G_CheckDBProtection( void )
+ {
+   int alienDBs = 0, humanDBs = 0, i;
+   gentity_t *ent;
+
+   // count designated builders
+   for( i = 0, ent = g_entities + i; i < level.maxclients; i++, ent++)
+   {
+     if( !ent->client || ( ent->client->pers.connected != CON_CONNECTED ) )
+       continue;
+
+     if( ent->client->pers.designatedBuilder)
+     {
+       if( ent->client->pers.teamSelection == PTE_HUMANS )
+       {
+         humanDBs++;
+       }
+       else if( ent->client->pers.teamSelection == PTE_ALIENS )
+       {
+         alienDBs++;
+       }
+     }
+   }
+
+   // both teams have designate builders, we're done
+   if( alienDBs > 0 && humanDBs > 0 )
+     return;
+
+   // cancel protection if needed
+   for( i = 1, ent = g_entities + i; i < level.num_entities; i++, ent++)
+   {
+     if( ent->s.eType != ET_BUILDABLE)
+       continue;
+
+     if( ( !alienDBs && ent->biteam == BIT_ALIENS ) ||
+       ( !humanDBs && ent->biteam == BIT_HUMANS ) )
+     {
+       ent->s.eFlags &= ~EF_DBUILDER;
+     }
+   }
+ }
+
 /*
 ============
 G_LayoutSave
@@ -3562,7 +5901,7 @@
     if( ent->s.eType != ET_BUILDABLE )
       continue;
 
-    s = va( "%i %f %f %f %f %f %f %f %f %f %f %f %f\n",
+    s = va( "%i %f %f %f %f %f %f %f %f %f %f %f %f %d %d %f\n",
       ent->s.modelindex,
       ent->s.pos.trBase[ 0 ],
       ent->s.pos.trBase[ 1 ],
@@ -3575,7 +5914,11 @@
       ent->s.origin2[ 2 ],
       ent->s.angles2[ 0 ],
       ent->s.angles2[ 1 ],
-      ent->s.angles2[ 2 ] );
+      ent->s.angles2[ 2 ],
+
+      ent->groupID,
+      ent->spawnGroup,
+      ent->reserved2 );
     trap_FS_Write( s, strlen( s ), f );
   }
   trap_FS_FCloseFile( f );
@@ -3716,7 +6059,7 @@
 ============
 */
 static void G_LayoutBuildItem( buildable_t buildable, vec3_t origin,
-  vec3_t angles, vec3_t origin2, vec3_t angles2 )
+  vec3_t angles, vec3_t origin2, vec3_t angles2, int groupID, int spawnGroup, float reserved2 )
 {
   gentity_t *builder;
 
@@ -3726,46 +6069,300 @@
   VectorCopy( angles, builder->s.angles );
   VectorCopy( origin2, builder->s.origin2 );
   VectorCopy( angles2, builder->s.angles2 );
-  G_SpawnBuildable( builder, buildable );
+  G_SpawnBuildable( builder, buildable, groupID, spawnGroup, reserved2 );
 }
 
 /*
 ============
+G_InstantBuild
+
+This function is extremely similar to the few functions that place a
+buildable on map load. It exists because G_LayoutBuildItem takes a couple
+of frames to finish spawning it, so it's not truly instant
+Do not call this function immediately after the map loads - that's what
+G_LayoutBuildItem is for.
+============
+*/
+gentity_t *G_InstantBuild( buildable_t buildable, vec3_t origin, vec3_t angles, vec3_t origin2, vec3_t angles2 )
+{
+  gentity_t *builder, *built;
+  trace_t   tr;
+  vec3_t    dest;
+
+  builder = G_Spawn( );
+  builder->client = 0;
+  VectorCopy( origin, builder->s.pos.trBase );
+  VectorCopy( angles, builder->s.angles );
+  VectorCopy( origin2, builder->s.origin2 );
+  VectorCopy( angles2, builder->s.angles2 );
+//old method didn't quite work out
+//builder->s.modelindex = buildable;
+//G_FinishSpawningBuildable( builder );
+
+  built = G_Build( builder, buildable, builder->s.pos.trBase, builder->s.angles );
+  G_FreeEntity( builder );
+
+  built->takedamage = qtrue;
+  built->spawned = qtrue; //map entities are already spawned
+  built->health = BG_FindHealthForBuildable( buildable );
+  built->s.generic1 |= B_SPAWNED_TOGGLEBIT;
+
+  // drop towards normal surface
+  VectorScale( built->s.origin2, -4096.0f, dest );
+  VectorAdd( dest, built->s.origin, dest );
+
+  trap_Trace( &tr, built->s.origin, built->r.mins, built->r.maxs, dest, built->s.number, built->clipmask );
+  if( tr.startsolid )
+  {
+    G_Printf( S_COLOR_YELLOW "G_FinishSpawningBuildable: %s startsolid at %s\n",
+         built->classname, vtos( built->s.origin ) );
+    G_FreeEntity( built );
+    return NULL;
+  }
+
+  //point items in the correct direction
+  VectorCopy( tr.plane.normal, built->s.origin2 );
+
+  // allow to ride movers
+  built->s.groundEntityNum = tr.entityNum;
+
+  G_SetOrigin( built, tr.endpos );
+
+  trap_LinkEntity( built );
+
+  G_StructureBuilt( built );
+
+  return built;
+}
+
+/*
+============
+G_SpawnRevertedBuildable
+
+Given a buildhistory, try to replace the lost buildable
+============
+*/
+void G_SpawnRevertedBuildable( buildHistory_t *bh, qboolean mark )
+{
+  vec3_t mins, maxs;
+  int i, j, blockCount, blockers[ MAX_GENTITIES ];
+  gentity_t *targ, *built, *toRecontent[ MAX_GENTITIES ];
+
+  BG_FindBBoxForBuildable( bh->buildable, mins, maxs );
+  VectorAdd( bh->origin, mins, mins );
+  VectorAdd( bh->origin, maxs, maxs );
+  blockCount = trap_EntitiesInBox( mins, maxs, blockers, MAX_GENTITIES );
+  for( i = j = 0; i < blockCount && !level.oc; i++ )
+  {
+    targ = g_entities + blockers[ i ];
+    if( targ->s.eType == ET_BUILDABLE )
+      G_FreeEntity( targ );
+    else if( targ->s.eType == ET_PLAYER )
+    {
+      targ->r.contents = 0; // make it intangible
+      toRecontent[ j++ ] = targ; // and remember it
+    }
+  }
+  level.numBuildablesForRemoval = 0;
+  built = G_InstantBuild( bh->buildable, bh->origin, bh->angles, bh->origin2, bh->angles2 );
+  if( built )
+  {
+    built->r.contents = 0;
+    built->think = G_CommitRevertedBuildable;
+    built->nextthink = level.time;
+    built->deconstruct = mark;
+  }
+  for( i = 0; i < j; i++ )
+    toRecontent[ i ]->r.contents = CONTENTS_SOLID;
+}
+
+/*
+============
+G_CommitRevertedBuildable
+
+Check if there's anyone occupying me, and if not, become solid and operate as
+normal. Else, try to get rid of them.
+============
+*/
+void G_CommitRevertedBuildable( gentity_t *ent )
+{
+  gentity_t *targ;
+  int i, n, occupants[ MAX_GENTITIES ];
+  vec3_t mins, maxs;
+  VectorAdd( ent->s.origin, ent->r.mins, mins );
+  VectorAdd( ent->s.origin, ent->r.maxs, maxs );
+  trap_UnlinkEntity( ent );
+  n = trap_EntitiesInBox( mins, maxs, occupants, MAX_GENTITIES );
+  trap_LinkEntity( ent );
+  if( n == 0 || level.oc )
+  { // we're in the clear!
+    ent->r.contents = CONTENTS_SOLID;
+    trap_LinkEntity( ent ); // relink
+    // oh dear, manual think set
+    switch( ent->s.modelindex )
+    {
+      case BA_A_SPAWN:
+         ent->think = ASpawn_Think;
+         break;
+      case BA_A_BARRICADE:
+      case BA_A_BOOSTER:
+        ent->think = ABarricade_Think;
+        break;
+      case BA_A_ACIDTUBE:
+        ent->think = AAcidTube_Think;
+        break;
+      case BA_A_HIVE:
+        ent->think = AHive_Think;
+        break;
+      case BA_A_TRAPPER:
+        ent->think = ATrapper_Think;
+        break;
+      case BA_A_OVERMIND:
+        ent->think = AOvermind_Think;
+        break;
+      case BA_A_HOVEL:
+        ent->think = AHovel_Think;
+        break;
+      case BA_H_SPAWN:
+        ent->think = HSpawn_Think;
+        break;
+      case BA_H_MGTURRET:
+        ent->think = HMGTurret_Think;
+        break;
+      case BA_H_TESLAGEN:
+        ent->think = HTeslaGen_Think;
+        break;
+      case BA_H_ARMOURY:
+        ent->think = HArmoury_Think;
+        break;
+      case BA_H_DCC:
+        ent->think = HDCC_Think;
+        break;
+      case BA_H_MEDISTAT:
+        ent->think = HMedistat_Think;
+        break;
+      case BA_H_REACTOR:
+        ent->think = HReactor_Think;
+        break;
+      case BA_H_REPEATER:
+        ent->think = HRepeater_Think;
+        break;
+    }
+    ent->nextthink = level.time + BG_FindNextThinkForBuildable( ent->s.modelindex );
+    // oh if only everything was that simple
+    return;
+  }
+  for( i = 0; i < n; i++ )
+  {
+    vec3_t gtfo;
+    targ = g_entities + occupants[ i ];
+    if( targ->client )
+    {
+      VectorSet( gtfo, crandom() * 150, crandom() * 150, random() * 150 );
+      VectorAdd( targ->client->ps.velocity, gtfo, targ->client->ps.velocity );
+    }
+  }
+#define REVERT_THINK_INTERVAL 50
+  ent->nextthink = level.time + REVERT_THINK_INTERVAL;
+}
+
+/*
+============
+G_RevertCanFit
+
+take a bhist and make sure you're not overwriting anything by placing it
+============
+*/
+qboolean G_RevertCanFit( buildHistory_t *bh )
+{
+  int i, num, blockers[ MAX_GENTITIES ];
+  vec3_t mins, maxs;
+  gentity_t *targ;
+  vec3_t dist;
+
+  BG_FindBBoxForBuildable( bh->buildable, mins, maxs );
+  VectorAdd( bh->origin, mins, mins );
+  VectorAdd( bh->origin, maxs, maxs );
+  num = trap_EntitiesInBox( mins, maxs, blockers, MAX_GENTITIES );
+  for( i = 0; i < num; i++ )
+  {
+    targ = g_entities + blockers[ i ];
+    if( targ->s.eType == ET_BUILDABLE )
+    {
+      VectorSubtract( bh->origin, targ->s.pos.trBase, dist );
+      if( targ->s.modelindex == bh->buildable && VectorLength( dist ) < 10 && targ->health <= 0 )
+        continue; // it's the same buildable, hasn't blown up yet
+      else
+        return qfalse; // can't get rid of this one
+    }
+    else
+      continue;
+  }
+  return qtrue;
+}
+
+/*
+============
 G_LayoutLoad
 
 load the layout .dat file indicated by level.layout and spawn buildables
 as if a builder was creating them
 ============
 */
-void G_LayoutLoad( void )
+void G_LayoutLoad( char *layout )
 {
   fileHandle_t f;
   int len;
-  char *layout;
+  char *layoutPtr;
   char map[ MAX_QPATH ];
   int buildable = BA_NONE;
+  int groupID = 0, spawnGroup = 0;
+  float reserved2 = 0.0f;
   vec3_t origin = { 0.0f, 0.0f, 0.0f };
   vec3_t angles = { 0.0f, 0.0f, 0.0f };
   vec3_t origin2 = { 0.0f, 0.0f, 0.0f };
   vec3_t angles2 = { 0.0f, 0.0f, 0.0f };
   char line[ MAX_STRING_CHARS ];
-  int i = 0;
+  int i = 0, j = 0, k, k2;
+  int max_spawnGroup = 0;
+  int max_buildables = MAX_LAYOUT_BUILDABLES;
+  layout_table_t *l = layout_table;
 
   if( !level.layout[ 0 ] || !Q_stricmp( level.layout, "*BUILTIN*" ) )
     return;
 
-  trap_Cvar_VariableStringBuffer( "mapname", map, sizeof( map ) );
-  len = trap_FS_FOpenFile( va( "layouts/%s/%s.dat", map, level.layout ),
-    &f, FS_READ );
-  if( len < 0 )
+  if( layout_table )
+    G_Free( layout_table );
+  layout_table = NULL;
+
+  while(max_buildables >= MIN_LAYOUT_BUILDABLES && !(layout_table = G_Alloc( sizeof( layout_table_t ) * max_buildables ))) max_buildables /= 2;
+  if(!layout_table)
   {
-    G_Printf( "ERROR: layout %s could not be opened\n", level.layout );
+    G_ClientPrint(NULL, va("^1ERROR: ^7The server could not allocate enough memory (%d bytes) (%d buildables) for the layout table", sizeof( layout_table_t ) * max_buildables, max_buildables), 0);
+    G_ClientCP(NULL, va("^1ERROR: ^7The server could not allocate enough memory (%d bytes) (%d buildables) for the layout table", sizeof( layout_table_t ) * max_buildables, max_buildables), NULL, 0);
+    G_LogPrintf("^1ERROR: ^7The server could not allocate enough memory (%d bytes) (%d buildables) for the layout table\n", sizeof( layout_table_t ) * max_buildables, max_buildables);
     return;
   }
-  layout = G_Alloc( len + 1 );
-  trap_FS_Read( layout, len, f );
-  *( layout + len ) = '\0';
-  trap_FS_FCloseFile( f );
+
+  l = layout_table;
+
+  if( !layout )
+  {
+      trap_Cvar_VariableStringBuffer( "mapname", map, sizeof( map ) );
+      len = trap_FS_FOpenFile( va( "layouts/%s/%s.dat", map, level.layout ),
+        &f, FS_READ );
+      if( len < 0 )
+      {
+        G_Printf( "ERROR: layout %s could not be opened\n", level.layout );
+        return;
+      }
+      layout = G_Alloc( len + 1 );  // memory leak!!
+      trap_FS_Read( layout, len, f );
+      *( layout + len ) = '\0';
+      trap_FS_FCloseFile( f );
+  }
+  layoutPtr = layout;
+//test lower buildables size too, maybe it's a g_mem corruption
   while( *layout )
   {
     if( i >= sizeof( line ) - 1 )
@@ -3779,21 +6376,150 @@
     if( *layout == '\n' )
     {
       i = 0;
-      sscanf( line, "%d %f %f %f %f %f %f %f %f %f %f %f %f\n",
+      sscanf( line, "%d %f %f %f %f %f %f %f %f %f %f %f %f %d %d %f\n",
         &buildable,
         &origin[ 0 ], &origin[ 1 ], &origin[ 2 ],
         &angles[ 0 ], &angles[ 1 ], &angles[ 2 ],
         &origin2[ 0 ], &origin2[ 1 ], &origin2[ 2 ],
-        &angles2[ 0 ], &angles2[ 1 ], &angles2[ 2 ] );
+        &angles2[ 0 ], &angles2[ 1 ], &angles2[ 2 ],
+        &groupID, &spawnGroup, &reserved2 );
 
       if( buildable > BA_NONE && buildable < BA_NUM_BUILDABLES )
-        G_LayoutBuildItem( buildable, origin, angles, origin2, angles2 );
-      else
+      {
+        l->buildable = buildable;
+        VectorCopy(origin, l->origin);
+        VectorCopy(angles, l->angles);
+        VectorCopy(origin2, l->origin2);
+        VectorCopy(angles2, l->angles2);
+        l->groupID = groupID;
+        l->spawnGroup = spawnGroup;
+        l->reserved2 = reserved2;
+        l->active = 1;
+        l++;
+        if( ++j >= max_buildables )
+        {
+//            G_ClientPrint(NULL, va("^3Warning: ^7The layout table is full (%d); a buildable was skipped", max_buildables), 0);
+//            G_ClientCP(NULL, va("^3Warning: ^7The layout table is full (%d); a buildable was skipped", max_buildables), NULL, 0);
+//            G_LogPrintf("^3Warning: ^7The layout table is full (%d); a buildable was skipped\n", max_buildables);
+//            return;
+            // first find the highest spawngroup
+            for(k = 0, l = layout_table; k < max_buildables && l->active; k++, l++)
+            {
+                if(l->spawnGroup > max_spawnGroup)
+                {
+                    if(l->spawnGroup < MAX_SPAWNGROUP)
+                    {
+                        max_spawnGroup = l->spawnGroup;
+                    }
+                    else
+                    {
+                        G_ClientPrint(NULL, va("^3Warning: ^7A buildable has a spawngroup (%d) higher than the maximum allowed (%d)", l->spawnGroup, MAX_SPAWNGROUP), 0);
+                        G_ClientCP(NULL, va("^3Warning: ^7A buildable has a spawngroup (%d) higher than the maximum allowed (%d)", l->spawnGroup, MAX_SPAWNGROUP), NULL, 0);
+                        G_LogPrintf("^3Warning: ^7A buildable has a spawngroup (%d) higher than the maximum allowed (%d)\n", l->spawnGroup, MAX_SPAWNGROUP);
+                return;
+                    }
+                }
+            }
+            max_spawnGroup++;
+
+            // build each buildable in order
+            for(k = 0; k < max_spawnGroup; k++)
+            {
+                for(k2 = 0, l = layout_table; k2 < max_buildables && l->active; k2++, l++)
+                {
+                    if(i == l->spawnGroup)
+                    {
+                        G_LayoutBuildItem( l->buildable, l->origin, l->angles, l->origin2, l->angles2, l->groupID, l->spawnGroup, l->reserved2 );
+                    }
+                }
+            }
+
+            if(layout_table)
+                G_Free(layout_table);
+            layout_table = NULL;
+
+            G_LayoutLoad( layout );
+            return;
+        }
+      }
+      else if( !( buildable > BA_NONE && buildable < BA_NUM_BUILDABLES ) )
+      {
         G_Printf( S_COLOR_YELLOW "WARNING: bad buildable number (%d) in "
           " layout.  skipping\n", buildable );
+      }
     }
     layout++;
   }
+
+  // first find the highest spawngroup
+  for(i = 0, l = layout_table; i < max_buildables && l->active; i++, l++)
+  {
+    if(l->spawnGroup > max_spawnGroup)
+    {
+        if(l->spawnGroup < MAX_SPAWNGROUP)
+        {
+            max_spawnGroup = l->spawnGroup;
+        }
+        else
+        {
+            G_ClientPrint(NULL, va("^3Warning: ^7A buildable has a spawngroup (%d) higher than the maximum allowed (%d)", l->spawnGroup, MAX_SPAWNGROUP), 0);
+            G_ClientCP(NULL, va("^3Warning: ^7A buildable has a spawngroup (%d) higher than the maximum allowed (%d)", l->spawnGroup, MAX_SPAWNGROUP), NULL, 0);
+            G_LogPrintf("^3Warning: ^7A buildable has a spawngroup (%d) higher than the maximum allowed (%d)\n", l->spawnGroup, MAX_SPAWNGROUP);  // this line segfaults
+            return;
+        }
+    }
+  }
+  max_spawnGroup++;
+
+  // build each buildable in order
+  for(i = 0; i < max_spawnGroup; i++)
+  {
+    for(j = 0, l = layout_table; j < max_buildables && l->active; j++, l++)
+    {
+        if(i == l->spawnGroup)
+        {
+            G_LayoutBuildItem( l->buildable, l->origin, l->angles, l->origin2, l->angles2, l->groupID, l->spawnGroup, l->reserved2 );
+        }
+    }
+  }
+
+  if( level.oc )
+  {
+    for( i = 0; i < MAX_CLIENTS; i++ )
+    {
+        if(g_entities[i].client && level.clients[i].pers.connected != CON_CONNECTED)
+        {
+            if(level.clients[i].pers.medis)
+                G_Free( level.clients[i].pers.medis );
+            if(level.totalMedistations)
+                level.clients[i].pers.medis = G_Alloc( ( level.totalMedistations ) * sizeof( gentity_t * ) );
+            else
+                level.clients[i].pers.medis = NULL;
+            if(level.clients[i].pers.medisLastCheckpoint)
+                G_Free( level.clients[i].pers.medisLastCheckpoint );
+            if(level.totalMedistations)
+                level.clients[i].pers.medisLastCheckpoint = G_Alloc( ( level.totalMedistations ) * sizeof( gentity_t * ) );
+            else
+                level.clients[i].pers.medisLastCheckpoint = NULL;
+            if(level.clients[i].pers.arms)
+                G_Free( level.clients[i].pers.arms );
+            if(level.totalArmouries)
+                level.clients[i].pers.arms = G_Alloc( ( level.totalArmouries ) * sizeof( gentity_t * ) );
+            else
+                level.clients[i].pers.arms = NULL;
+            if(level.clients[i].pers.armsLastCheckpoint)
+                G_Free( level.clients[i].pers.armsLastCheckpoint );
+            if(level.totalArmouries)
+                level.clients[i].pers.armsLastCheckpoint = G_Alloc( ( level.totalArmouries ) * sizeof( gentity_t * ) );
+            else
+                level.clients[i].pers.armsLastCheckpoint = NULL;
+        }
+    }
+
+    G_CountSpawns( );
+    G_CalculateBuildPoints( );
+    G_CalculateStages( );
+  }
 }
 
 /*
@@ -3821,3 +6547,38 @@
   }
 }
 
+int G_LogBuild( buildHistory_t *new )
+{
+  new->next = level.buildHistory;
+  level.buildHistory = new;
+  return G_CountBuildLog();
+}
+
+int G_CountBuildLog( void )
+{
+  buildHistory_t *ptr, *mark;
+  int i = 0, overflow;
+  for( ptr = level.buildHistory; ptr; ptr = ptr->next, i++ );
+  if( i > g_buildLogMaxLength.integer )
+  {
+    for( overflow = i - g_buildLogMaxLength.integer; overflow > 0; overflow-- )
+    {
+      ptr = level.buildHistory;
+      while( ptr->next )
+      {
+    if( ptr->next->next )
+      ptr = ptr->next;
+    else
+    {
+      while( (mark = ptr->next) )
+      {
+        ptr->next = ptr->next->marked;
+            G_Free( mark );
+      }
+    }
+      }
+    }
+    return g_buildLogMaxLength.integer;
+  }
+  return i;
+}
Index: src/game/g_main.c
===================================================================
--- src/game/g_main.c	(revision 1055)
+++ src/game/g_main.c	(working copy)
@@ -41,11 +41,16 @@
 
 vmCvar_t  g_fraglimit;
 vmCvar_t  g_timelimit;
+vmCvar_t  g_voteExecuteTime;
 vmCvar_t  g_suddenDeathTime;
+vmCvar_t  g_suddenDeath;
+vmCvar_t  g_suddenDeathMode;
 vmCvar_t  g_capturelimit;
 vmCvar_t  g_friendlyFire;
 vmCvar_t  g_friendlyFireAliens;
 vmCvar_t  g_friendlyFireHumans;
+vmCvar_t  g_retribution;
+vmCvar_t  g_friendlyFireMovementAttacks;
 vmCvar_t  g_friendlyBuildableFire;
 vmCvar_t  g_password;
 vmCvar_t  g_needpass;
@@ -68,6 +73,7 @@
 vmCvar_t  g_warmup;
 vmCvar_t  g_doWarmup;
 vmCvar_t  g_restarted;
+vmCvar_t  g_lockTeamsAtStart;
 vmCvar_t  g_logFile;
 vmCvar_t  g_logFileSync;
 vmCvar_t  g_blood;
@@ -75,6 +81,14 @@
 vmCvar_t  g_podiumDrop;
 vmCvar_t  g_allowVote;
 vmCvar_t  g_voteLimit;
+vmCvar_t  g_suddenDeathVotePercent;
+vmCvar_t  g_startScrimVotePercent;
+vmCvar_t  g_endScrimVotePercent;
+vmCvar_t  g_mapVotesPercent;
+vmCvar_t  g_ocVotesPercent;
+vmCvar_t  g_ocTimeMapDropPercent;
+vmCvar_t  g_autoMajorityVotes;
+vmCvar_t  g_designateVotes;
 vmCvar_t  g_teamAutoJoin;
 vmCvar_t  g_teamForceBalance;
 vmCvar_t  g_banIPs;
@@ -87,6 +101,11 @@
 vmCvar_t  g_minCommandPeriod;
 vmCvar_t  g_minNameChangePeriod;
 vmCvar_t  g_maxNameChanges;
+vmCvar_t  g_newbieNumbering;
+vmCvar_t  g_newbieNamePrefix;
+vmCvar_t  g_maintenance;
+vmCvar_t  g_maintenanceMessage;
+vmCvar_t  g_connectMessage;
 
 vmCvar_t  g_humanBuildPoints;
 vmCvar_t  g_alienBuildPoints;
@@ -100,7 +119,10 @@
 vmCvar_t  g_alienMaxStage;
 vmCvar_t  g_alienStage2Threshold;
 vmCvar_t  g_alienStage3Threshold;
+vmCvar_t  g_teamImbalanceWarnings;
 
+vmCvar_t  g_allowAdminCheats;
+
 vmCvar_t  g_unlagged;
 
 vmCvar_t  g_disabledEquipment;
@@ -108,6 +130,7 @@
 vmCvar_t  g_disabledBuildables;
 
 vmCvar_t  g_markDeconstruct;
+vmCvar_t  g_deconDead;
 
 vmCvar_t  g_debugMapRotation;
 vmCvar_t  g_currentMapRotation;
@@ -118,6 +141,8 @@
 
 vmCvar_t  g_mapConfigs;
 vmCvar_t  g_chatTeamPrefix;
+vmCvar_t  g_floodMaxDemerits;
+vmCvar_t  g_floodMinTime;
 
 vmCvar_t  g_layouts;
 vmCvar_t  g_layoutAuto;
@@ -125,13 +150,49 @@
 vmCvar_t  g_admin;
 vmCvar_t  g_adminLog;
 vmCvar_t  g_adminParseSay;
+vmCvar_t  g_adminSayFilter;
 vmCvar_t  g_adminNameProtect;
 vmCvar_t  g_adminTempBan;
+vmCvar_t  g_adminTempSpec;
 
 vmCvar_t  g_privateMessages;
+vmCvar_t  g_publicSayadmins;
+vmCvar_t  g_antiSpawnBlock;
+vmCvar_t  g_floodProtection;
 
+vmCvar_t  g_buildLogMaxLength;
+
+vmCvar_t  g_devmapKillerHP;
+
 vmCvar_t  g_tag;
 
+vmCvar_t  g_allowShare;
+vmCvar_t  g_allowDonate;
+
+// the following group only affect / deal with oc's
+vmCvar_t  g_ocReview;
+vmCvar_t  g_ocAutoVotes;
+vmCvar_t  g_ocEditMode;
+vmCvar_t  g_allowHiding;
+vmCvar_t  g_hideTimeCallvoteMinutes;
+vmCvar_t  g_hideNotTimeCallvoteMinutes;
+vmCvar_t  g_statsEnabled;
+vmCvar_t  g_statsRecords;
+vmCvar_t  g_disableCPMixes;
+vmCvar_t  g_ocWarmup;
+vmCvar_t  g_ocScrimAfterTime;
+
+vmCvar_t  g_allowActions;
+vmCvar_t  g_actionPrefix;
+
+vmCvar_t  g_dretchPunt;
+
+vmCvar_t  g_devmapNoGod;
+vmCvar_t  g_devmapNoStructDmg;
+
+vmCvar_t  g_voteMinTime;
+vmCvar_t  g_mapvoteMaxTime;
+
 static cvarTable_t   gameCvarTable[ ] =
 {
   // don't override the cheat state set by the system
@@ -141,6 +202,7 @@
   { NULL, "gamename", GAME_VERSION , CVAR_SERVERINFO | CVAR_ROM, 0, qfalse  },
   { NULL, "gamedate", __DATE__ , CVAR_ROM, 0, qfalse  },
   { &g_restarted, "g_restarted", "0", CVAR_ROM, 0, qfalse  },
+  { &g_lockTeamsAtStart, "g_lockTeamsAtStart", "0", CVAR_ROM, 0, qfalse  },
   { NULL, "sv_mapname", "", CVAR_SERVERINFO | CVAR_ROM, 0, qfalse  },
   { NULL, "P", "", CVAR_SERVERINFO | CVAR_ROM, 0, qfalse  },
   { NULL, "ff", "0", CVAR_SERVERINFO | CVAR_ROM, 0, qfalse  },
@@ -150,23 +212,47 @@
   { &g_maxclients, "sv_maxclients", "8", CVAR_SERVERINFO | CVAR_LATCH | CVAR_ARCHIVE, 0, qfalse  },
 
   // change anytime vars
-  { &g_maxGameClients, "g_maxGameClients", "0", CVAR_SERVERINFO | CVAR_ARCHIVE, 0, qfalse  },
+  { &g_maxGameClients, "g_maxGameClients", "0", CVAR_SERVERINFO | CVAR_ARCHIVE | CVAR_NORESTART, 0, qtrue  },
 
+  { &g_voteExecuteTime, "g_voteExecuteTime", "3000", CVAR_ARCHIVE, 0, qtrue },
+
   { &g_timelimit, "timelimit", "0", CVAR_SERVERINFO | CVAR_ARCHIVE | CVAR_NORESTART, 0, qtrue },
   { &g_suddenDeathTime, "g_suddenDeathTime", "0", CVAR_SERVERINFO | CVAR_ARCHIVE | CVAR_NORESTART, 0, qtrue },
+  { &g_suddenDeathMode, "g_suddenDeathMode", "2", CVAR_SERVERINFO | CVAR_ARCHIVE | CVAR_NORESTART, 0, qtrue },
+  { &g_suddenDeath, "g_suddenDeath", "0", CVAR_SERVERINFO | CVAR_NORESTART, 0, qtrue },
 
   { &g_synchronousClients, "g_synchronousClients", "0", CVAR_SYSTEMINFO, 0, qfalse  },
 
-  { &g_friendlyFire, "g_friendlyFire", "0", CVAR_ARCHIVE, 0, qtrue  },
-  { &g_friendlyFireAliens, "g_friendlyFireAliens", "0", CVAR_ARCHIVE, 0, qtrue  },
-  { &g_friendlyFireHumans, "g_friendlyFireHumans", "0", CVAR_ARCHIVE, 0, qtrue  },
-  { &g_friendlyBuildableFire, "g_friendlyBuildableFire", "0", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_friendlyFire, "g_friendlyFire", "1", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_friendlyFireAliens, "g_friendlyFireAliens", "1", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_friendlyFireHumans, "g_friendlyFireHumans", "1", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_retribution, "g_retribution", "0", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_friendlyBuildableFire, "g_friendlyBuildableFire", "1", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_friendlyFireMovementAttacks, "g_friendlyFireMovementAttacks", "1", CVAR_ARCHIVE, 0, qtrue  },
 
+  { &g_ocReview, "g_ocReview", "1", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_ocAutoVotes, "g_ocAutoVotes", "1", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_ocEditMode, "g_ocEditMode", "0", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_allowHiding, "g_allowHiding", "1", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_hideTimeCallvoteMinutes, "g_hideTimeCallvoteMinutes", "5", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_hideNotTimeCallvoteMinutes, "g_hideNotTimeCallvoteMinutes", "5", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_statsEnabled, "g_statsEnabled", "0", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_statsRecords, "g_statsRecords", "10", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_disableCPMixes, "g_disableCPMixes", "1", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_ocWarmup, "g_ocWarmup", "20", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_ocScrimAfterTime, "g_ocScrimAfterTime", "20", CVAR_ARCHIVE, 0, qtrue  },
+
+  { &g_maintenance, "g_maintenance", "0", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_maintenanceMessage, "g_maintenanceMessage", "", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_connectMessage, "g_connectMessage", "", CVAR_ARCHIVE, 0, qfalse  },
+
+  { &g_allowAdminCheats, "g_allowAdminCheats", DEFAULT_ALLOW_ADMIN_CHEATS, CVAR_ARCHIVE, 0, qtrue  },
+
   { &g_teamAutoJoin, "g_teamAutoJoin", "0", CVAR_ARCHIVE  },
   { &g_teamForceBalance, "g_teamForceBalance", "0", CVAR_ARCHIVE  },
 
   { &g_warmup, "g_warmup", "20", CVAR_ARCHIVE, 0, qtrue  },
-  { &g_doWarmup, "g_doWarmup", "0", 0, 0, qtrue  },
+  { &g_doWarmup, "g_doWarmup", "1", CVAR_ARCHIVE, 0, qtrue  },
   { &g_logFile, "g_logFile", "games.log", CVAR_ARCHIVE, 0, qfalse  },
   { &g_logFileSync, "g_logFileSync", "0", CVAR_ARCHIVE, 0, qfalse  },
 
@@ -197,10 +283,23 @@
 
   { &g_allowVote, "g_allowVote", "1", CVAR_ARCHIVE, 0, qfalse },
   { &g_voteLimit, "g_voteLimit", "5", CVAR_ARCHIVE, 0, qfalse },
+  { &g_voteMinTime, "g_voteMinTime", "120", CVAR_ARCHIVE, 0, qfalse },
+  { &g_mapvoteMaxTime, "g_mapvoteMaxTime", "240", CVAR_ARCHIVE, 0, qfalse },
+  { &g_suddenDeathVotePercent, "g_suddenDeathVotePercent", "51", CVAR_ARCHIVE, 0, qfalse },
+  { &g_startScrimVotePercent, "g_startScrimVotePercent", "85", CVAR_ARCHIVE, 0, qfalse },
+  { &g_endScrimVotePercent, "g_endScrimVotePercent", "90", CVAR_ARCHIVE, 0, qfalse },
+  { &g_mapVotesPercent, "g_mapVotesPercent", "51", CVAR_ARCHIVE, 0, qfalse },
+  { &g_ocVotesPercent, "g_ocVotesPercent", "51", CVAR_ARCHIVE, 0, qfalse },
+  { &g_ocTimeMapDropPercent, "g_ocTimeMapDropPercent", "17.5", CVAR_ARCHIVE, 0, qfalse },
+  { &g_autoMajorityVotes, "g_autoMajorityVotes", "1", CVAR_ARCHIVE, 0, qfalse },
+  { &g_designateVotes, "g_designateVotes", "0", CVAR_ARCHIVE, 0, qfalse },
+
   { &g_listEntity, "g_listEntity", "0", 0, 0, qfalse },
   { &g_minCommandPeriod, "g_minCommandPeriod", "500", 0, 0, qfalse},
   { &g_minNameChangePeriod, "g_minNameChangePeriod", "5", 0, 0, qfalse},
   { &g_maxNameChanges, "g_maxNameChanges", "5", 0, 0, qfalse},
+  { &g_newbieNumbering, "g_newbieNumbering", "0", CVAR_ARCHIVE, 0, qfalse},
+  { &g_newbieNamePrefix, "g_newbieNamePrefix", "Newbie#", CVAR_ARCHIVE, 0, qfalse},
 
   { &g_smoothClients, "g_smoothClients", "1", 0, 0, qfalse},
   { &pmove_fixed, "pmove_fixed", "0", CVAR_SYSTEMINFO, 0, qfalse},
@@ -218,16 +317,21 @@
   { &g_alienMaxStage, "g_alienMaxStage", DEFAULT_ALIEN_MAX_STAGE, 0, 0, qfalse  },
   { &g_alienStage2Threshold, "g_alienStage2Threshold", DEFAULT_ALIEN_STAGE2_THRESH, 0, 0, qfalse  },
   { &g_alienStage3Threshold, "g_alienStage3Threshold", DEFAULT_ALIEN_STAGE3_THRESH, 0, 0, qfalse  },
-  
+
+  { &g_teamImbalanceWarnings, "g_teamImbalanceWarnings", "30", CVAR_ARCHIVE, 0, qfalse  },
+
   { &g_unlagged, "g_unlagged", "1", CVAR_SERVERINFO | CVAR_ARCHIVE, 0, qfalse  },
 
   { &g_disabledEquipment, "g_disabledEquipment", "", CVAR_ROM, 0, qfalse  },
   { &g_disabledClasses, "g_disabledClasses", "", CVAR_ROM, 0, qfalse  },
   { &g_disabledBuildables, "g_disabledBuildables", "", CVAR_ROM, 0, qfalse  },
 
-  { &g_chatTeamPrefix, "g_chatTeamPrefix", "0", CVAR_ARCHIVE  },
+  { &g_chatTeamPrefix, "g_chatTeamPrefix", "1", CVAR_ARCHIVE  },
+  { &g_floodMaxDemerits, "g_floodMaxDemerits", "5000", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_floodMinTime, "g_floodMinTime", "2000", CVAR_ARCHIVE, 0, qfalse  },
 
-  { &g_markDeconstruct, "g_markDeconstruct", "1", CVAR_SERVERINFO | CVAR_ARCHIVE, 0, qfalse  },
+  { &g_markDeconstruct, "g_markDeconstruct", "0", CVAR_SERVERINFO | CVAR_ARCHIVE, 0, qfalse  },
+  { &g_deconDead, "g_deconDead", "1", CVAR_ARCHIVE, 0, qtrue  },
 
   { &g_debugMapRotation, "g_debugMapRotation", "0", 0, 0, qfalse  },
   { &g_currentMapRotation, "g_currentMapRotation", "-1", 0, 0, qfalse  }, // -1 = NOT_ROTATING
@@ -243,14 +347,29 @@
   { &g_admin, "g_admin", "admin.dat", CVAR_ARCHIVE, 0, qfalse  },
   { &g_adminLog, "g_adminLog", "admin.log", CVAR_ARCHIVE, 0, qfalse  },
   { &g_adminParseSay, "g_adminParseSay", "1", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_adminSayFilter, "g_adminSayFilter", "0", CVAR_ARCHIVE, 0, qfalse  },
   { &g_adminNameProtect, "g_adminNameProtect", "1", CVAR_ARCHIVE, 0, qfalse  },
-  { &g_adminTempBan, "g_adminTempBan", "120", CVAR_ARCHIVE, 0, qfalse  },
-  
+  { &g_adminTempBan, "g_adminTempBan", "2m", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_adminTempSpec, "g_adminTempSpec", "120", CVAR_ARCHIVE, 0, qfalse  },
+
   { &g_privateMessages, "g_privateMessages", "1", CVAR_ARCHIVE, 0, qfalse  },
-  
+  { &g_devmapKillerHP, "g_devmapKillerHP", "0", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_publicSayadmins, "g_publicSayadmins", "1", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_antiSpawnBlock, "g_antiSpawnBlock", "150", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_floodProtection, "g_floodProtection", "200", CVAR_ARCHIVE, 0, qfalse  },
+
+  { &g_buildLogMaxLength, "g_buildLogMaxLength", "25", CVAR_ARCHIVE, 0, qfalse  },
+
   { &g_tag, "g_tag", "main", CVAR_INIT, 0, qfalse },
-  
-  { &g_rankings, "g_rankings", "0", 0, 0, qfalse}
+  { &g_dretchPunt, "g_dretchPunt", "1", CVAR_ARCHIVE, 0, qfalse  },
+
+  { &g_rankings, "g_rankings", "0", 0, 0, qfalse },
+
+  { &g_allowActions, "g_allowActions", "1", CVAR_ARCHIVE, 0, qfalse },
+  { &g_actionPrefix, "g_actionPrefix", "***", CVAR_ARCHIVE, 0, qfalse },
+
+  { &g_allowShare, "g_allowShare", "1", CVAR_ARCHIVE, 0, qfalse},
+  { &g_allowDonate, "g_allowDonate", "1", CVAR_ARCHIVE, 0, qfalse}
 };
 
 static int gameCvarTableSize = sizeof( gameCvarTable ) / sizeof( gameCvarTable[ 0 ] );
@@ -261,9 +380,6 @@
 void G_ShutdownGame( int restart );
 void CheckExitRules( void );
 
-void G_CountSpawns( void );
-void G_CalculateBuildPoints( void );
-
 /*
 ================
 vmMain
@@ -315,6 +431,9 @@
 
     case GAME_CONSOLE_COMMAND:
       return ConsoleCommand( );
+
+    case GAME_PING_OVERRIDE:
+      return ClientPingOverride( );
   }
 
   return -1;
@@ -442,9 +561,6 @@
 
   if( remapped )
     G_RemapTeamShaders( );
-
-  // check some things
-  level.warmupModificationCount = g_warmup.modificationCount;
 }
 
 /*
@@ -502,7 +618,7 @@
 
   trap_SendConsoleCommand( EXEC_APPEND,
     va( "exec \"%s/default.cfg\"\n", g_mapConfigs.string ) );
-  
+
   trap_SendConsoleCommand( EXEC_APPEND,
     va( "exec \"%s/%s.cfg\"\n", g_mapConfigs.string, mapname ) );
 
@@ -519,6 +635,8 @@
 {
   int i;
 
+  char *layout;
+
   srand( randomSeed );
 
   G_RegisterCvars( );
@@ -533,8 +651,10 @@
 
   // set some level globals
   memset( &level, 0, sizeof( level ) );
+  level.scrimTeam = G_Alloc(MAX_SCRIM_TEAMS * sizeof( oc_scrimTeam_t ) );
   level.time = levelTime;
   level.startTime = levelTime;
+  level.nextCPTime = levelTime + CP_FRAME_TIME * 2;
   level.alienStage2Time = level.alienStage3Time =
     level.humanStage2Time = level.humanStage3Time = level.startTime;
 
@@ -552,11 +672,20 @@
     else
     {
       char serverinfo[ MAX_INFO_STRING ];
+      qtime_t qt;
+      int t;
 
+
       trap_GetServerinfo( serverinfo, sizeof( serverinfo ) );
 
       G_LogPrintf( "------------------------------------------------------------\n" );
       G_LogPrintf( "InitGame: %s\n", serverinfo );
+
+      t = trap_RealTime( &qt );
+      G_LogPrintf("RealTime: %04i/%02i/%02i %02i:%02i:%02i\n",
+            qt.tm_year+1900, qt.tm_mon+1, qt.tm_mday,
+            qt.tm_hour, qt.tm_min, qt.tm_sec );
+
     }
   }
   else
@@ -607,8 +736,24 @@
   G_SpawnEntitiesFromString( );
 
   // load up a custom building layout if there is one
-  G_LayoutLoad( );
 
+  G_ToLowerCase(level.layout);
+  layout = level.layout;
+
+  if (*(layout) == 'o' && *((layout) + 1) == 'c')
+  {
+    trap_Cvar_Set( "g_humanBuildPoints", va( "%d", INFINITE ) );
+    trap_Cvar_Set( "g_alienBUildPoints", va( "%d", INFINITE ) );
+    level.oc = 1;
+    level.ocLoadTime = level.time + OC_PREP_TIME;
+  }
+
+  else
+  {
+    level.oc = 0;
+    G_LayoutLoad( NULL );
+  }
+
   // the map might disable some things
   BG_InitAllowedGameElements( );
 
@@ -630,7 +775,20 @@
   trap_Cvar_Set( "g_humanStage", va( "%d", S1 ) );
   trap_Cvar_Set( "g_alienKills", 0 );
   trap_Cvar_Set( "g_humanKills", 0 );
+  trap_Cvar_Set( "g_suddenDeath", 0 );
+  trap_Cvar_Set( "g_allowAdminCheats", 0 );
+  trap_Cvar_Set( "g_ocEditMode", 0 );
 
+  if (*(layout) == 'o' && *((layout) + 1) == 'c')
+  {
+    trap_Cvar_Set( "g_alienStage", va( "%d", S3 ) );
+    trap_Cvar_Set( "g_humanStage", va( "%d", S3 ) );
+    G_Checktrigger_stages( PTE_ALIENS, S2 );
+    G_Checktrigger_stages( PTE_HUMANS, S2 );
+    G_Checktrigger_stages( PTE_ALIENS, S3 );
+    G_Checktrigger_stages( PTE_HUMANS, S3 );
+  }
+
   G_Printf( "-----------------------------------\n" );
 
   G_RemapTeamShaders( );
@@ -639,6 +797,13 @@
   G_CountSpawns( );
 
   G_ResetPTRConnections( );
+
+  if(g_lockTeamsAtStart.integer)
+  {
+    level.alienTeamLocked=qtrue;
+    level.humanTeamLocked=qtrue;
+    trap_Cvar_Set( "g_lockTeamsAtStart", "0" );
+  }
 }
 
 /*
@@ -670,6 +835,8 @@
 
   G_Printf( "==== ShutdownGame ====\n" );
 
+  G_Free( level.scrimTeam );
+
   if( level.logFile )
   {
     G_LogPrintf( "ShutdownGame:\n" );
@@ -739,9 +906,9 @@
   cb = &level.clients[ *(int *)b ];
 
   // then sort by score
-  if( ca->ps.persistant[ PERS_SCORE ] > cb->ps.persistant[ PERS_SCORE ] )
+  if( ca->pers.score > cb->pers.score )
     return -1;
-  else if( ca->ps.persistant[ PERS_SCORE ] < cb->ps.persistant[ PERS_SCORE ] )
+  else if( ca->pers.score < cb->pers.score )
     return 1;
   else
     return 0;
@@ -823,17 +990,39 @@
 
 /*
 ============
+G_SearchSpawnQueue
+
+Look to see if clientNum is already in the spawnQueue
+============
+*/
+qboolean G_SearchSpawnQueue( spawnQueue_t *sq, int clientNum )
+{
+  int i;
+
+  for( i = 0; i < MAX_CLIENTS; i++ )
+    if( sq->clients[ i ] == clientNum )
+      return qtrue;
+  return qfalse;
+}
+
+/*
+============
 G_PushSpawnQueue
 
 Add an element to the back of the spawn queue
 ============
 */
-void G_PushSpawnQueue( spawnQueue_t *sq, int clientNum )
+qboolean G_PushSpawnQueue( spawnQueue_t *sq, int clientNum )
 {
+  // don't add the same client more than once
+  if( G_SearchSpawnQueue( sq, clientNum ) )
+    return qfalse;
+
   sq->back = QUEUE_PLUS1( sq->back );
   sq->clients[ sq->back ] = clientNum;
 
   g_entities[ clientNum ].client->ps.pm_flags |= PMF_QUEUED;
+  return qtrue;
 }
 
 /*
@@ -967,9 +1156,9 @@
     clientNum = G_PeekSpawnQueue( sq );
     ent = &g_entities[ clientNum ];
 
-    if( ( spawn = SelectTremulousSpawnPoint( team,
+    if( ( spawn = G_SelectTremulousSpawnPoint( team,
             ent->client->pers.lastDeathLocation,
-            spawn_origin, spawn_angles ) ) )
+            spawn_origin, spawn_angles, ent ) ) )
     {
       clientNum = G_PopSpawnQueue( sq );
 
@@ -978,6 +1167,8 @@
 
       ent = &g_entities[ clientNum ];
 
+      G_OCPlayerSpawn( ent );
+
       ent->client->sess.sessionTeam = TEAM_FREE;
       ClientUserinfoChanged( clientNum );
       ClientSpawn( ent, spawn, spawn_origin, spawn_angles );
@@ -1049,30 +1240,68 @@
   int         localHTP = g_humanBuildPoints.integer,
               localATP = g_alienBuildPoints.integer;
 
-  if( g_suddenDeathTime.integer && !level.warmupTime )
-  {
-    if( G_TimeTilSuddenDeath( ) <= 0 )
-    {
-      localHTP = 0;
-      localATP = 0;
+  //g_suddenDeath sets what state we want it to be.  level.suddenDeath says whether we've calculated BPs at the 'start' of SD or not
 
-      //warn about sudden death
-      if( level.suddenDeathWarning < TW_PASSED )
-      {
+  //reset if SD was on, but now it's off
+  if(!g_suddenDeath.integer && level.suddenDeath) {
+      level.suddenDeath=qfalse;
+      level.suddenDeathWarning=0;
+  }
+
+    if(!level.suddenDeath && !level.oc){
+        if(g_suddenDeath.integer || G_TimeTilSuddenDeath( ) <= 0 ) //Conditions to enter SD
+        {
+          //begin sudden death
+          if( level.suddenDeathWarning < TW_PASSED )
+          {
         trap_SendServerCommand( -1, "cp \"Sudden Death!\"" );
+        G_LogPrintf("Beginning Sudden Death (Mode %d)\n",g_suddenDeathMode.integer);
+        localHTP = 0;
+        localATP = 0;
+
+        if( g_suddenDeathMode.integer == SDMODE_SELECTIVE ) {
+          for( i = 1, ent = g_entities + i; i < level.num_entities; i++, ent++ )
+          {
+            if( ent->s.eType != ET_BUILDABLE )
+              continue;
+
+            if( BG_FindReplaceableTestForBuildable( ent->s.modelindex ) )
+            {
+              int t = BG_FindTeamForBuildable( ent->s.modelindex );
+
+              if( t == BIT_HUMANS )
+            localHTP += BG_FindBuildPointsForBuildable( ent->s.modelindex );
+              else if( t == BIT_ALIENS )
+            localATP += BG_FindBuildPointsForBuildable( ent->s.modelindex );
+            }
+          }
+        }
+        level.suddenDeathHBuildPoints = localHTP;
+        level.suddenDeathABuildPoints = localATP;
+        level.suddenDeath=qtrue;
+        //trap_Cvar_Set( "g_suddenDeath", "1" );
+        g_suddenDeath.integer=1;
+
         level.suddenDeathWarning = TW_PASSED;
-      }
-    }
-    else
-    {
-      //warn about sudden death
-      if( G_TimeTilSuddenDeath( ) <= 60000 &&
+          }
+        }  else {
+
+          //warn about sudden death
+          if( G_TimeTilSuddenDeath( ) <= 60000 &&
           level.suddenDeathWarning < TW_IMMINENT )
-      {
-        trap_SendServerCommand( -1, "cp \"Sudden Death in 1 minute!\"" );
-        level.suddenDeathWarning = TW_IMMINENT;
-      }
+          {
+            if( !level.oc )
+              trap_SendServerCommand( -1, "cp \"Sudden Death in 1 minute!\"" );
+            level.suddenDeathWarning = TW_IMMINENT;
+          }
+        }
     }
+
+  //set BP at each cycle
+  if( g_suddenDeath.integer )
+  {
+    localHTP = level.suddenDeathHBuildPoints;
+    localATP = level.suddenDeathABuildPoints;
   }
   else
   {
@@ -1104,17 +1333,19 @@
       if( buildable == BA_A_OVERMIND && ent->spawned && ent->health > 0 )
         level.overmindPresent = qtrue;
 
-      if( BG_FindTeamForBuildable( buildable ) == BIT_HUMANS )
+      if( !g_suddenDeath.integer || BG_FindReplaceableTestForBuildable( buildable ) )
       {
-        level.humanBuildPoints -= BG_FindBuildPointsForBuildable( buildable );
-
-        if( ent->powered )
-          level.humanBuildPointsPowered -= BG_FindBuildPointsForBuildable( buildable );
+        if( BG_FindTeamForBuildable( buildable ) == BIT_HUMANS )
+        {
+          level.humanBuildPoints -= BG_FindBuildPointsForBuildable( buildable );
+          if( ent->powered )
+            level.humanBuildPointsPowered -= BG_FindBuildPointsForBuildable( buildable );
+        }
+        else
+        {
+          level.alienBuildPoints -= BG_FindBuildPointsForBuildable( buildable );
+        }
       }
-      else
-      {
-        level.alienBuildPoints -= BG_FindBuildPointsForBuildable( buildable );
-      }
     }
   }
 
@@ -1192,6 +1423,7 @@
     G_Checktrigger_stages( PTE_ALIENS, S2 );
     trap_Cvar_Set( "g_alienStage", va( "%d", S2 ) );
     level.alienStage2Time = level.time;
+    G_LogPrintf("Stage: A 2: Aliens reached Stage 2\n");
   }
 
   if( g_alienKills.integer >=
@@ -1201,6 +1433,7 @@
     G_Checktrigger_stages( PTE_ALIENS, S3 );
     trap_Cvar_Set( "g_alienStage", va( "%d", S3 ) );
     level.alienStage3Time = level.time;
+    G_LogPrintf("Stage: A 3: Aliens reached Stage 3\n");
   }
 
   if( g_humanKills.integer >=
@@ -1210,6 +1443,7 @@
     G_Checktrigger_stages( PTE_HUMANS, S2 );
     trap_Cvar_Set( "g_humanStage", va( "%d", S2 ) );
     level.humanStage2Time = level.time;
+    G_LogPrintf("Stage: H 2: Humans reached Stage 2\n");
   }
 
   if( g_humanKills.integer >=
@@ -1219,6 +1453,7 @@
     G_Checktrigger_stages( PTE_HUMANS, S3 );
     trap_Cvar_Set( "g_humanStage", va( "%d", S3 ) );
     level.humanStage3Time = level.time;
+    G_LogPrintf("Stage: H 3: Humans reached Stage 3\n");
   }
 }
 
@@ -1272,10 +1507,6 @@
 void CalculateRanks( void )
 {
   int       i;
-  int       rank;
-  int       score;
-  int       newScore;
-  gclient_t *cl;
   char      P[ MAX_CLIENTS + 1 ] = {""};
   int       ff = 0;
 
@@ -1340,30 +1571,6 @@
   qsort( level.sortedClients, level.numConnectedClients,
     sizeof( level.sortedClients[ 0 ] ), SortRanks );
 
-  // set the rank value for all clients that are connected and not spectators
-  rank = -1;
-  score = 0;
-  for( i = 0;  i < level.numPlayingClients; i++ )
-  {
-    cl = &level.clients[ level.sortedClients[ i ] ];
-    newScore = cl->ps.persistant[ PERS_SCORE ];
-
-    if( i == 0 || newScore != score )
-    {
-      rank = i;
-      // assume we aren't tied until the next client is checked
-      level.clients[ level.sortedClients[ i ] ].ps.persistant[ PERS_RANK ] = rank;
-    }
-    else
-    {
-      // we are tied with the previous client
-      level.clients[ level.sortedClients[ i - 1 ] ].ps.persistant[ PERS_RANK ] = rank;
-      level.clients[ level.sortedClients[ i ] ].ps.persistant[ PERS_RANK ] = rank;
-    }
-
-    score = newScore;
-  }
-
   // see if it is time to end the level
   CheckExitRules( );
 
@@ -1449,7 +1656,7 @@
 
   if( !ent )
   { // the map creator forgot to put in an intermission point...
-    SelectSpawnPoint( vec3_origin, level.intermission_origin, level.intermission_angle );
+    G_SelectSpawnPoint( vec3_origin, level.intermission_origin, level.intermission_angle );
   }
   else
   {
@@ -1521,7 +1728,18 @@
 {
   int       i;
   gclient_t *cl;
+  buildHistory_t *tmp, *mark;
 
+  while( ( tmp = level.buildHistory ) )
+  {
+    level.buildHistory = level.buildHistory->next;
+    while( ( mark = tmp ) )
+    {
+      tmp = tmp->marked;
+      G_Free( mark );
+    }
+  }
+
   if( G_MapRotationActive( ) )
     G_AdvanceMapRotation( );
   else
@@ -1556,6 +1774,37 @@
 
 /*
 =================
+G_AdminsPrintf
+
+Print to all active admins, and the logfile with a time stamp if it is open, and to the console
+=================
+*/
+void QDECL G_AdminsPrintf( const char *fmt, ... )
+{
+  va_list argptr;
+  char    string[ 1024 ];
+  gentity_t   *tempent;
+  int j;
+
+  va_start( argptr, fmt );
+  vsprintf( string, fmt,argptr );
+  va_end( argptr );
+
+  for( j = 0; j < level.maxclients; j++ )
+  {
+    tempent = &g_entities[ j ];
+    if( G_admin_permission( tempent, ADMF_ADMINCHAT) )
+    {
+       trap_SendServerCommand(tempent-g_entities,va( "print \"^6[Admins]^7 %s\"", string) );
+    }
+  }
+
+  G_LogPrintf("%s",string);
+
+}
+
+/*
+=================
 G_LogPrintf
 
 Print to the logfile with a time stamp if it is open
@@ -1591,6 +1840,38 @@
 
 /*
 =================
+G_LogOnlyPrintf
+
+Print to the logfile only (not console) with a time stamp if it is open
+=================
+*/
+void QDECL G_LogOnlyPrintf( const char *fmt, ... )
+{
+  va_list argptr;
+  char    string[ 1024 ];
+  int     min, tens, sec;
+
+  sec = level.time / 1000;
+
+  min = sec / 60;
+  sec -= min * 60;
+  tens = sec / 10;
+  sec -= tens * 10;
+
+  Com_sprintf( string, sizeof( string ), "%3i:%i%i ", min, tens, sec );
+
+  va_start( argptr, fmt );
+  vsprintf( string +7 , fmt,argptr );
+  va_end( argptr );
+
+  if( !level.logFile )
+    return;
+
+  trap_FS_Write( string, strlen( string ), level.logFile );
+}
+
+/*
+=================
 G_SendGameStat
 =================
 */
@@ -1874,7 +2155,7 @@
     return;
   }
 
-  if( g_timelimit.integer && !level.warmupTime )
+  if( g_timelimit.integer && ( ( level.oc && !level.numConnectedClients ) || ( !level.oc ) ) )
   {
     if( level.time - level.startTime >= g_timelimit.integer * 60000 )
     {
@@ -1898,28 +2179,31 @@
     }
   }
 
-  if( level.uncondHumanWin ||
-      ( ( level.time > level.startTime + 1000 ) &&
-        ( level.numAlienSpawns == 0 ) &&
-        ( level.numLiveAlienClients == 0 ) ) )
+  if( !level.oc )
   {
-    //humans win
-    level.lastWin = PTE_HUMANS;
-    trap_SendServerCommand( -1, "print \"Humans win\n\"");
-    trap_SetConfigstring( CS_WINNER, "Humans Win" );
-    LogExit( "Humans win." );
+    if( level.uncondHumanWin ||
+        ( ( level.time > level.startTime + 1000 ) &&
+          ( level.numAlienSpawns == 0 ) &&
+          ( level.numLiveAlienClients == 0 ) ) )
+    {
+      //humans win
+      level.lastWin = PTE_HUMANS;
+      trap_SendServerCommand( -1, "print \"Humans win\n\"");
+      trap_SetConfigstring( CS_WINNER, "Humans Win" );
+      LogExit( "Humans win." );
+    }
+    else if( level.uncondAlienWin ||
+             ( ( level.time > level.startTime + 1000 ) &&
+               ( level.numHumanSpawns == 0 ) &&
+               ( level.numLiveHumanClients == 0 ) ) )
+    {
+      //aliens win
+      level.lastWin = PTE_ALIENS;
+      trap_SendServerCommand( -1, "print \"Aliens win\n\"");
+      trap_SetConfigstring( CS_WINNER, "Aliens Win" );
+      LogExit( "Aliens win." );
+    }
   }
-  else if( level.uncondAlienWin ||
-           ( ( level.time > level.startTime + 1000 ) &&
-             ( level.numHumanSpawns == 0 ) &&
-             ( level.numLiveHumanClients == 0 ) ) )
-  {
-    //aliens win
-    level.lastWin = PTE_ALIENS;
-    trap_SendServerCommand( -1, "print \"Aliens win\n\"");
-    trap_SetConfigstring( CS_WINNER, "Aliens Win" );
-    LogExit( "Aliens win." );
-  }
 }
 
 /*
@@ -2032,6 +2316,9 @@
 */
 void CheckVote( void )
 {
+  int votePercentToPass=level.votePercentToPass;
+  int voteYesPercent;
+
   if( level.voteExecuteTime && level.voteExecuteTime < level.time )
   {
     level.voteExecuteTime = 0;
@@ -2047,32 +2334,39 @@
   if( !level.voteTime )
     return;
 
-  if( level.time - level.voteTime >= VOTE_TIME )
-  {
-    if( level.voteYes > level.voteNo )
+   if( level.voteYes + level.voteNo > 0 )
+     voteYesPercent = (int)(100* (level.voteYes)/(level.voteYes + level.voteNo));
+   else
+     voteYesPercent = 0;
+
+    if( level.time - level.voteTime >= VOTE_TIME || ( level.voteYes + level.voteNo == level.numConnectedClients ) )
     {
-      // execute the command, then remove the vote
-      trap_SendServerCommand( -1, "print \"Vote passed\n\"" );
-      level.voteExecuteTime = level.time + 3000;
-    }
+      if( voteYesPercent >= votePercentToPass || level.voteNo == 0 )
+      {
+        // execute the command, then remove the vote
+        trap_SendServerCommand( -1, va( "print \"Vote passed ( %d - %d )\n\"", level.voteYes, level.voteNo ) );
+        G_LogPrintf("Vote passed\n");
+        level.voteExecuteTime = level.time + g_voteExecuteTime.integer;
+      }
     else
     {
       // same behavior as a timeout
-      trap_SendServerCommand( -1, "print \"Vote failed\n\"" );
+      trap_SendServerCommand( -1, va( "print \"Vote failed ( %d - %d )\n\"", level.voteYes, level.voteNo ) );
+      G_LogPrintf("Vote failed\n");
     }
   }
-  else
+  else if( g_autoMajorityVotes.integer )
   {
-    if( level.voteYes > level.numVotingClients / 2 )
+    if( level.voteYes > (int)((double)level.numConnectedClients * ((double)votePercentToPass/100.0)) )
     {
-      // execute the command, then remove the vote
-      trap_SendServerCommand( -1, "print \"Vote passed\n\"" );
-      level.voteExecuteTime = level.time + 3000;
+        // execute the command, then remove the vote
+        trap_SendServerCommand( -1, va( "print \"Vote passed ( majority ) ( %d - %d )\n\"", level.voteYes, level.voteNo ) );
+        level.voteExecuteTime = level.time + g_voteExecuteTime.integer;
     }
-    else if( level.voteNo >= ceil( (float)level.numVotingClients / 2 ) )
+    else if( level.voteNo > (int)((double)level.numConnectedClients * ((double)(100.0-votePercentToPass)/100.0)) )
     {
       // same behavior as a timeout
-      trap_SendServerCommand( -1, "print \"Vote failed\n\"" );
+        trap_SendServerCommand( -1, va( "print \"Vote failed ( majority ) ( %d - %d )\n\"", level.voteYes, level.voteNo ) );
     }
     else
     {
@@ -2117,7 +2411,7 @@
       G_TeamCommand( team, "print \"Team vote passed\n\"" );
       trap_SendConsoleCommand( EXEC_APPEND, va( "%s\n", level.teamVoteString[ cs_offset ] ) );
     }
-    else if( level.teamVoteNo[ cs_offset ] >= level.numteamVotingClients[ cs_offset ] / 2 )
+    else if( level.teamVoteNo[ cs_offset ] >= level.numteamVotingClients[ cs_offset ] / 2 && level.teamVoteYes[ cs_offset ] + level.teamVoteNo[ cs_offset ] > 0  )
     {
       // same behavior as a timeout
       G_TeamCommand( team, "print \"Team vote failed\n\"" );
@@ -2174,6 +2468,8 @@
       ent->deconstruct = qfalse;
     }
   }
+
+  level.frameMsec = trap_Milliseconds( );
 }
 
 /*
@@ -2233,7 +2529,7 @@
 void G_RunFrame( int levelTime )
 {
   int       i;
-  gentity_t *ent;
+  gentity_t *ent, *client;
   int       msec;
   int       start, end;
 
@@ -2241,6 +2537,88 @@
   if( level.restarted )
     return;
 
+  // occasionally ensure that level.layout is lowercase
+  if(level.time % 1000 == 0)
+    G_ToLowerCase(level.layout);
+
+  // TODO: this belongs in g_buildable.c
+  if( level.oc && level.ocScrimState == OC_STATE_WARM )
+  {
+    if( level.time % 500 == 0 )
+      G_ClientCP( NULL, va("OC scrim starts in %d.\n\nUse ^5teamchat^7 to plan your play with scrim teammates!", ((level.ocStartTime + g_ocWarmup.integer * 1000) - level.time) / 1000 ), "OC scrim starts in ", CLIENT_ONLYTEAM );
+    if( level.time > level.ocStartTime + g_ocWarmup.integer * 1000 )
+    {
+      for( i = 0; i < level.maxclients; i++ )
+      {
+        client = &g_entities[ i ];
+        if( client && client->client && client->client->pers.ocTeam )
+        {
+            G_RestartClient(client, 0, 0);
+        }
+      }
+      level.ocScrimState = OC_STATE_PLAY;
+    }
+  }
+
+  if( level.oc && level.ocScrimState == OC_STATE_PREP )
+  {
+    if(g_ocWarmup.integer > 0 && !G_OCSingleScrim())
+    {
+        level.ocScrimState = OC_STATE_WARM;
+    }
+    else
+    {
+      for( i = 0; i < level.maxclients; i++ )
+      {
+        client = &g_entities[ i ];
+        if( client && client->client && client->client->pers.ocTeam )
+        {
+            G_RestartClient(client, 0, 0);
+        }
+      }
+
+      level.ocScrimState = OC_STATE_PLAY;
+    }
+  }
+
+  if( level.paused )
+  {
+    level.pausedTime = levelTime - level.time;
+    if( ( level.pausedTime % 2000 ) == 0)
+      G_ClientCP( NULL, "The game has been paused.  Please wait.", NULL, 0 );
+
+   for(i=0;i<level.maxclients;i++)
+   {
+     level.clients[ i ].ps.commandTime = levelTime;
+   }
+
+   return;
+  }
+
+  if( level.oc )
+  {
+    if( level.ocLoadTime && level.time > level.ocLoadTime )
+    {
+        G_LayoutLoad( NULL );
+        level.ocLoadTime = 0;
+    }
+
+    if(level.ocEndsTime)
+    {
+        if(level.time > level.ocEndsTime)
+        {
+            G_OCScrimEnd();
+        }
+        else
+        {
+            if(G_OCScrimAllWon())
+                G_ClientCP(NULL, "^7", "crim ends in", 0);
+            else
+                G_ClientCP(NULL, va("OC Scrim ends in ^2%d^7!", (level.ocEndsTime - level.time) / 1000), "crim ends in", 0);
+        }
+    }
+  }
+
   level.framenum++;
   level.previousTime = level.time;
   level.time = levelTime;
@@ -2252,6 +2630,9 @@
   // get any cvar changes
   G_UpdateCvars( );
 
+  // update cp's
+  G_UpdateCP( );
+
   //
   // go through all allocated objects
   //
@@ -2347,22 +2728,25 @@
       ClientEndFrame( ent );
   }
 
-  // save position information for all active clients 
+  // save position information for all active clients
   G_UnlaggedStore( );
 
   end = trap_Milliseconds();
 
-  G_CountSpawns( );
-  G_CalculateBuildPoints( );
-  G_CalculateStages( );
+  if(!level.oc || level.time % 6000 == 0)  // save some processing power
+  {
+    G_CountSpawns( );
+    G_CalculateBuildPoints( );
+    G_CalculateStages( );
+
+    // see if it is time to end the level
+    CheckExitRules( );
+  }
   G_SpawnClients( PTE_ALIENS );
   G_SpawnClients( PTE_HUMANS );
   G_CalculateAvgPlayers( );
   G_UpdateZaps( msec );
 
-  // see if it is time to end the level
-  CheckExitRules( );
-
   // update to team status?
   CheckTeamStatus( );
 
@@ -2383,5 +2767,7 @@
 
     trap_Cvar_Set( "g_listEntity", "0" );
   }
+
+  level.pausedTime=0;
 }
 
Index: src/game/g_admin.c
===================================================================
--- src/game/g_admin.c	(revision 1055)
+++ src/game/g_admin.c	(working copy)
@@ -11,7 +11,7 @@
 
 The functionality of this code mimics the behaviour of the currently
 inactive project shrubet (http://www.etstats.com/shrubet/index.php?ver=2)
-by Ryan Mannion.   However, shrubet was a closed-source project and 
+by Ryan Mannion.   However, shrubet was a closed-source project and
 none of it's code has been copied, only it's functionality.
 
 Tremulous is free software; you can redistribute it
@@ -36,146 +36,372 @@
 static char g_bfb[ 32000 ];
 
 // note: list ordered alphabetically
-g_admin_cmd_t g_admin_cmds[ ] = 
+g_admin_cmd_t g_admin_cmds[ ] =
   {
-    {"admintest", G_admin_admintest, "a",
+    {"adjustban", G_admin_adjustban, "b",
+      "change the duration or reason of a ban.  time is specified as numbers "
+      "followed by units 'w' (weeks), 'd' (days), 'h' (hours) or 'm' (minutes),"
+      " or seconds if no units are specified",
+      "[^3ban#^7] (^5time^7) (^5reason^7)"
+    },
+
+    {"adjusthide", G_admin_adjusthide, "c",
+      "change the duration, hidden or reason of a hide.  time is specified as numbers "
+      "followed by units 'w' (weeks), 'd' (days), 'h' (hours) or 'm' (minutes),"
+      " or seconds if no units are specified - if hidden is only"
+      " arg, add c as first arg."
+      " For example, to enable isHidden for slot #4, use"
+      " !adjusthide 4 c 1.  The 0 does not represent anything",
+      "[^3ban#^7] (^5time^7) (^5chidden hidden^7) (^5reason^7)"
+    },
+
+    {"admintest", G_admin_admintest, "^h",
       "display your current admin level",
       ""
     },
 
-    {"allowbuild", G_admin_denybuild, "d",
+    {"adminsay", G_admin_adminsay, "^s",
+      "assert your authority using chat",
+      "[^5message^7]"
+    },
+
+    {"allowbuild", G_admin_denybuild, "^b",
       "restore a player's ability to build",
       "[^3name|slot#^7]"
     },
-    
-    {"allready", G_admin_allready, "y",
+
+    {"allready", G_admin_allready, "^r",
       "makes everyone ready in intermission",
       ""
     },
 
     {"ban", G_admin_ban, "b",
       "ban a player by IP and GUID with an optional expiration time and reason."
-      "  time is seconds or suffix with 'w' - weeks, 'd' - days, 'h' - hours, "
-      "or 'm' - minutes",
+      "  time is specified as numbers followed by units 'w' (weeks), 'd' "
+      "(days), 'h' (hours) or 'm' (minutes), or seconds if no units are "
+      "specified",
       "[^3name|slot#|IP^7] (^5time^7) (^5reason^7)"
     },
 
-    {"cancelvote", G_admin_cancelvote, "c",
+    {"bigsay", G_admin_bigsay, "^s",
+      "assert your authority using chat",
+      "[^5message^7]"
+    },
+
+    {"buildlog", G_admin_buildlog, "d",
+      "display a list of recent builds and deconstructs, optionally specifying"
+      " a team",
+      "(^5xnum^7) (^5#skip^7) (^5-name|num^7) (^5a|h^7)",
+    },
+
+    {"cancelvote", G_admin_cancelvote, "v",
       "cancel a vote taking place",
       ""
     },
 
-    {"denybuild", G_admin_denybuild, "d",
+    {"endscrim", G_admin_endscrim, "c",
+      "end an oc scrim",
+      ""
+    },
+
+    {"cheat-abp", G_admin_abp, "^c",
+      "set alien build points - requires cheats",
+      "[^5bp^7]"
+    },
+
+    {"cheat-as", G_admin_as, "^c",
+      "set alien stage - requires cheats",
+      "[^5stage^7]"
+    },
+
+    {"cheat-ao", G_admin_override, "^c",
+      "override checks for various things",
+      "(^5name|slot^7)"
+    },
+
+    {"cheat-do", G_admin_override, "^c",
+      "deny override",
+      "(^5name|slot^7)"
+    },
+
+    {"cheat-hbp", G_admin_hbp, "^c",
+      "set alien build points - requires cheats"
+      "[^5bp^7]"
+    },
+
+    {"cheat-hs", G_admin_hs, "^c",
+      "set human stage - requires cheats",
+      "[^5stage^7]"
+    },
+
+    {"cheat-give-all", G_admin_giveall, "^c",
+      "give all - requires cheats",
+      ""
+    },
+
+    {"cheat-giveall", G_admin_giveall, "^c",
+      "give all - requires cheats",
+      ""
+    },
+
+    {"cheat-god", G_admin_god, "^c",
+      "god - requires cheats",
+      ""
+    },
+
+    {"cheat-kill", G_admin_kill, "^c",
+      "kill - requires cheats",
+      ""
+    },
+
+    {"cheat-noclip", G_admin_noclip, "^c",
+      "noclip - requires cheats",
+      ""
+    },
+
+    {"cheat-set", G_admin_setCheat, "^^c",
+      "notarget - requires cheats",
+      "[^3name|slot#^7]"
+    },
+
+    {"cheat-notarget", G_admin_notarget, "^c",
+      "notarget - requires cheats",
+      ""
+    },
+
+    {"crash", G_admin_crash, "^^^a",
+      "crash a client",
+      "[^5stage^7]"
+    },
+
+    {"denybuild", G_admin_denybuild, "^b",
       "take away a player's ability to build",
       "[^3name|slot#^7]"
     },
 
+    {"designate", G_admin_designate, "^b",
+      "give the player designated builder privileges",
+      "[^3name|slot#^7]"
+    },
+
+    {"editoc", G_admin_editoc, ADMF_LAYOUTEDIT,
+      "Edit an obstacle course",
+      "[mode - 0/1/2/off/allwithcallerlevelplus/all]"
+    },
+
+    {"flag", G_admin_flag, "S",
+      "Handle a player's flags",
+      "[^3name|slot#^7|admin#^7] (^3flag^7)"
+    },
+
+    {"giveflag", G_admin_flag, "S",
+      "Give a player a flag",
+      "[^3name|slot#^7|admin#^7] (^3flag^7)"
+    },
+
     {"help", G_admin_help, "h",
       "display commands available to you or help on a specific command",
       "(^5command^7)"
     },
 
+    {"hide", G_admin_hide, "c",
+      "hide a player",
+      "[^3name|slot#^7] (^5time^7)"
+    },
+
+    {"info", G_admin_info, "^h",
+      "display the contents of server info files",
+      "(^5subject^7)"
+    },
+
     {"kick", G_admin_kick, "k",
       "kick a player with an optional reason",
       "(^5reason^7)"
     },
-    
-    {"listadmins", G_admin_listadmins, "D",
+
+    {"layoutsave", G_admin_layoutsave, "^^L",
+      "save a map layout",
+      "[^3mapname^7]"
+    },
+
+    {"layoutsavereview", G_admin_layoutsave, ADMF_LAYOUTEDIT,
+      "save a map layout without a queue limit",
+      "[^3mapname^7]"
+    },
+
+    {"layoutsave-review", G_admin_layoutsave, ADMF_LAYOUTEDIT,
+      "save a map layout without a queue limit",
+      "[^3mapname^7]"
+    },
+
+    {"layoutsave_review", G_admin_layoutsave, ADMF_LAYOUTEDIT,
+      "save a map layout without a queue limit",
+      "[^3mapname^7]"
+    },
+
+    {"listadmins", G_admin_listadmins, "^L",
       "display a list of all server admins and their levels",
       "(^5name|start admin#^7)"
     },
-    
+
     {"listlayouts", G_admin_listlayouts, "L",
       "display a list of all available layouts for a map",
       "(^5mapname^7)"
     },
 
-    {"listplayers", G_admin_listplayers, "i",
+    {"listplayers", G_admin_listplayers, "l",
       "display a list of players, their client numbers and their levels",
       ""
     },
-    
+
     {"lock", G_admin_lock, "K",
       "lock a team to prevent anyone from joining it",
       "[^3a|h^7]"
     },
-    
-    {"map", G_admin_map, "M",
+
+    {"map", G_admin_map, "m",
       "load a map (and optionally force layout)",
       "[^3mapname^7] (^5layout^7)"
     },
 
-    {"mute", G_admin_mute, "m",
+    {"devmap", G_admin_devmap, "m",
+      "load a map with cheats (and optionally force layout)",
+      "[^3mapname^7] (^5layout^7)"
+    },
+
+    {"mute", G_admin_mute, "M",
       "mute a player",
       "[^3name|slot#^7]"
     },
-    
-    {"namelog", G_admin_namelog, "e",
+
+    {"namelog", G_admin_namelog, "^^l",
       "display a list of names used by recently connected players",
       "(^5name^7)"
     },
 
-    {"nextmap", G_admin_nextmap, "n",
+    {"nextmap", G_admin_nextmap, "m",
       "go to the next map in the cycle",
       ""
     },
 
-    {"passvote", G_admin_passvote, "V",
+    {"passvote", G_admin_passvote, "v",
       "pass a vote currently taking place",
       ""
     },
 
-    {"putteam", G_admin_putteam, "p",
-      "move a player to a specified team",
-      "[^3name|slot#^7] [^3h|a|s^7]"
+    {"pause", G_admin_pause, "^p",
+      "Pause (or unpause) the game.",
+      ""
     },
 
-    {"readconfig", G_admin_readconfig, "G",
-      "reloads the admin config file and refreshes permission flags",
+    {"putteam", G_admin_putteam, "P",
+      "move a player to a specified team for an optional duration",
+      "[^3name|slot#^7] [^3h|a|s^7] (^3duration^7)"
+    },
+
+    {"putscrimteam", G_admin_putscrimteam, "o",
+      "move a player to a specified obstacle course team",
+      "[^3name|slot#^7] [^3teamname/0fornoteam^7]"
+    },
+
+    {"readconfig", G_admin_readconfig, "^r",
+      "reloads the admin config file and refreshes  flags",
       ""
     },
 
-    {"rename", G_admin_rename, "N",
+    {"register", G_admin_register, "r",
+      "Registers your name to protect it from being used by others or updates your admin name to your current name.",
+      ""
+    },
+
+    {"removeflag", G_admin_flag, "S",
+      "Remove a player a flag",
+      "[^3name|slot#^7|admin#^7] (^3flag^7)"
+    },
+
+    {"rename", G_admin_rename, "R",
       "rename a player",
       "[^3name|slot#^7] [^3new name^7]"
     },
 
-    {"restart", G_admin_restart, "r",
-      "restart the current map (optionally using named layout)",
-      "(^5layout^7)"
+    {"restart", G_admin_restart, "m",
+      "restart the current map (optionally using named layout or keeping/switching teams)",
+      "(^5layout^7) (^5keepteams|switchteams|keepteamslock|switchteamslock^7)"
     },
 
-    {"setlevel", G_admin_setlevel, "s",
+    {"revert", G_admin_revert, "d",
+      "revert one or more buildlog events, optionally of only one team",
+      "(^5xnum^7) (^5#ID^7) (^5-name|num^7) (^5a|h^7)"
+    },
+
+    {"say", G_admin_say, "s",
+      "assert your authority using chat",
+      "[^5message^7]"
+    },
+
+    {"setlevel", G_admin_setlevel, "S",
       "sets the admin level of a player",
       "[^3name|slot#|admin#^7] [^3level^7]"
     },
 
-    {"showbans", G_admin_showbans, "B",
+    {"showbans", G_admin_showbans, "b",
       "display a (partial) list of active bans",
       "(^5start at ban#^7)"
     },
 
-    {"spec999", G_admin_spec999, "P",
+    {"showhides", G_admin_showhides, "c",
+      "display a (partial) list of active hides",
+      "(^5start at ban#^7)"
+    },
+
+    {"spec999", G_admin_spec999, "i",
       "move 999 pingers to the spectator team",
       ""},
 
-    {"time", G_admin_time, "C",
+    {"specme", G_admin_putmespec, "^h",
+     "moves you to the spectators",
+     ""
+    },
+
+    {"startscrim", G_admin_startscrim, "o",
+     "starts a scrim all medis or armoury win",
+     "[m/a]"
+    },
+
+    {"time", G_admin_time, "^h",
       "show the current local server time",
-      ""},
+     ""
+    },
 
     {"unban", G_admin_unban, "b",
       "unbans a player specified by the slot as seen in showbans",
-      "[^3ban slot#^7]"
+      "[^3ban#^7]"
     },
-    
+
     {"unlock", G_admin_unlock, "K",
       "unlock a locked team",
       "[^3a|h^7]"
     },
 
-    {"unmute", G_admin_mute, "m",
+    {"unhide", G_admin_hide, "c",
+      "unhide a hidden player",
+      "[^3name|slot#^7]"
+    },
+
+    {"undesignate", G_admin_designate, "^b",
+      "revoke designated builder privileges",
+      "[^3name|slot#^7]"
+    },
+
+    {"unmute", G_admin_mute, "M",
       "unmute a muted player",
       "[^3name|slot#^7]"
+    },
+
+    {
+     "warn", G_admin_warn, "w",
+      "Warn a player to cease or face admin intervention",
+      "[^3name|slot#^7] [reason]"
     }
   };
 
@@ -185,14 +411,16 @@
 g_admin_level_t *g_admin_levels[ MAX_ADMIN_LEVELS ];
 g_admin_admin_t *g_admin_admins[ MAX_ADMIN_ADMINS ];
 g_admin_ban_t *g_admin_bans[ MAX_ADMIN_BANS ];
+g_admin_hide_t *g_admin_hides[ MAX_ADMIN_HIDES ];
 g_admin_command_t *g_admin_commands[ MAX_ADMIN_COMMANDS ];
 g_admin_namelog_t *g_admin_namelog[ MAX_ADMIN_NAMELOGS ];
 
-qboolean G_admin_permission( gentity_t *ent, char flag )
+qboolean G_admin_permission( gentity_t *ent, char *flag )
 {
   int i;
   int l = 0;
   char *flags;
+  char *flag1;
 
   // console always wins
   if( !ent )
@@ -205,36 +433,51 @@
       flags = g_admin_admins[ i ]->flags;
       while( *flags )
       {
-        if( *flags == flag )
-          return qtrue;
-        else if( *flags == '-' )
+        if( *flags == *flag )
         {
-          while( *flags++ )
+          if( *flag != '^' )
+            return qtrue;
+          flag1 = flag + 1;
+          flags++;
+          while ( *flags == *flag1 && *flags == '^' )
           {
-            if( *flags == flag )
-              return qfalse;
-            else if( *flags == '+' )
-              break;
+            flags++;
+            flag1++;
           }
+          if ( *flags++ == *flag1 )
+            return qtrue;
+          else
+            continue;
         }
+        else if( *flags == '-' )
+        {
+            flags++;
+            if( *flags == *flag )
+            {
+              if ( *flag != '^' )
+                return qfalse;
+              flag1 = flag + 1;
+              flags++;
+              while ( *flags == *flag1 && *flags == '^' )
+              {
+                flags++;
+                flag1++;
+              }
+              if ( *flags++ == *flag1 )
+                return qfalse;
+              else
+                continue;
+            }
+        }
         else if( *flags == '*' )
         {
-          while( *flags++ )
-          {
-            if( *flags == flag )
-              return qfalse;
-          }
           // flags with significance only for individuals (
-          // like ADMF_INCOGNITO and ADMF_IMMUTABLE are NOT covered 
+          // like ADMF_INCOGNITO and ADMF_IMMUTABLE are NOT covered
           // by the '*' wildcard.  They must be specified manually.
-          switch( flag )
-          {
-          case ADMF_INCOGNITO:
-          case ADMF_IMMUTABLE:
-            return qfalse; 
-          default:
+          if ( !Q_stricmp( flag, ADMF_INCOGNITO ) || !Q_stricmp( flag, ADMF_IMMUTABLE ) || !Q_stricmp( flag, ADMF_SEESFULLLISTPLAYERS ) || !Q_stricmp( flag, ADMF_DBUILDER ) || !Q_stricmp( flag, ADMF_ADMINCHAT ) || !Q_stricmp( flag, ADMF_MAINTAIN ) || !Q_stricmp( flag, ADMF_EXTENSIVEADMINCONTROL ) || !Q_stricmp( flag, ADMF_PINGOVERRIDE ) )
+            return qfalse;
+          else
             return qtrue;
-          } 
         }
         flags++;
       }
@@ -248,26 +491,31 @@
       flags = g_admin_levels[ i ]->flags;
       while( *flags )
       {
-        if( *flags == flag )
-          return qtrue;
-        if( *flags == '*' )
+        if( *flags == *flag )
         {
-          while( *flags++ )
+          if ( *flag != '^' )
+            return qtrue;
+           flag1 = flag + 1;
+           flags++;
+          while ( *flags == *flag1 && *flags == '^' )
           {
-            if( *flags == flag )
-              return qfalse;
+            flags++;
+            flag1++;
           }
+          if ( *flags == *flag1 )
+            return qtrue;
+          else
+            continue;
+        }
+        if( *flags == '*' )
+        {
           // flags with significance only for individuals (
-          // like ADMF_INCOGNITO and ADMF_IMMUTABLE are NOT covered 
+          // like ADMF_INCOGNITO and ADMF_IMMUTABLE are NOT covered
           // by the '*' wildcard.  They must be specified manually.
-          switch( flag )
-          {
-          case ADMF_INCOGNITO:
-          case ADMF_IMMUTABLE:
-            return qfalse; 
-          default:
+          if ( !Q_stricmp( flag, ADMF_INCOGNITO ) || !Q_stricmp( flag, ADMF_IMMUTABLE ) || !Q_stricmp( flag, ADMF_SEESFULLLISTPLAYERS ) || !Q_stricmp( flag, ADMF_DBUILDER ) || !Q_stricmp( flag, ADMF_ADMINCHAT ) || !Q_stricmp( flag, ADMF_MAINTAIN ) || !Q_stricmp( flag, ADMF_EXTENSIVEADMINCONTROL ) || !Q_stricmp( flag, ADMF_PINGOVERRIDE ) )
+            return qfalse;
+          else
             return qtrue;
-          } 
         }
         flags++;
       }
@@ -276,41 +524,125 @@
   return qfalse;
 }
 
-qboolean G_admin_name_check( gentity_t *ent, char *name, char *err, int len )
+qboolean G_admin_name_check( gentity_t *ent, char *name, char *err, int len, int testUnnamed )
 {
   int i;
   gclient_t *client;
   char testName[ MAX_NAME_LENGTH ] = {""};
   char name2[ MAX_NAME_LENGTH ] = {""};
+  char namePrefix[ MAX_NAME_LENGTH - 4 ];
+  char namePrefix2[ MAX_NAME_LENGTH - 4 ];
+  int alphaCount = 0;
+  qboolean unnamed = qtrue;
 
   G_SanitiseName( name, name2 );
 
-  if( !Q_stricmp( name2, "UnnamedPlayer" ) ) 
+  if( !Q_stricmp( name2, "UnnamedPlayer" ) && !testUnnamed )
     return qtrue;
 
-  for( i = 0; i < level.maxclients; i++ )
+  if( !Q_stricmp( name2, "console" ) )
   {
-    client = &level.clients[ i ];
-    if( client->pers.connected != CON_CONNECTING
-      && client->pers.connected != CON_CONNECTED ) 
+    Q_strncpyz( err, va( "The name '%s^7' is invalid here", name2 ),
+      len );
+    return qfalse;
+  }
+
+  if( !Q_stricmp( name2, "name" ) )  // name might conflict with stats
+  {
+    Q_strncpyz( err, va( "The name '%s^7' is invalid here", name2 ),
+      len );
+    return qfalse;
+  }
+
+  if( !Q_stricmp( name2, "noname" ) )  // noname might conflict with stats
+  {
+    Q_strncpyz( err, va( "The name '%s^7' is invalid here", name2 ),
+      len );
+    return qfalse;
+  }
+
+  if( !testUnnamed )
+  {
+      for( i = 0; i < level.maxclients; i++ )
+      {
+        client = &level.clients[ i ];
+        if( client->pers.connected != CON_CONNECTING
+          && client->pers.connected != CON_CONNECTED )
+        {
+          continue;
+        }
+
+        // can rename ones self to the same name using different colors
+        if( i == ( ent - g_entities ) )
+          continue;
+
+        G_SanitiseName( client->pers.netname, testName );
+        if( !Q_stricmp( name2, testName ) && !testUnnamed )
+        {
+          Q_strncpyz( err, va( "The name '%s^7' is already in use", name ),
+            len );
+          return qfalse;
+        }
+      }
+  }
+
+  if( '0' <= name2[ 0 ]  && name2[ 0 ] <= '9' )
+  {
+    Q_strncpyz( err, "Names cannot begin with a number. Please choose another.", len );
+    return qfalse;
+  }
+
+  for( i = 0; name2[ i ] !='\0'; i++)
+  {
+    if( Q_isalpha( name2[ i ] ) )
+     alphaCount++;
+    if( name2[ i ] == '/' )
     {
-      continue;
+      if( name2[ i + 1 ] == '/' || name2[ i + 1 ] == '*' )
+      {
+        Q_strncpyz( err, "Names cannot contain '//' or '/*'. Please choose another.", len );
+        return qfalse;
+      }
     }
+    if( name2[ i ] == ';' )
+    {
+      Q_strncpyz( err, "Names cannot contain 'SEMICOLON'. Please choose another.", len );
+      return qfalse;
+    }
+  }
 
-    // can rename ones self to the same name using different colors
-    if( i == ( ent - g_entities ) )
-      continue;
+  if( alphaCount == 0 )
+  {
+    Q_strncpyz( err, va( "The name '%s^7' does not include at least one letter. Please choose another.", name ), len );
+    return qfalse;
+  }
 
-    G_SanitiseName( client->pers.netname, testName );
-    if( !Q_stricmp( name2, testName ) )
+  if( g_newbieNamePrefix.string[ 0 ] )
+    Q_strncpyz( namePrefix, g_newbieNamePrefix.string , sizeof( namePrefix ) );
+  else
+    strcpy( namePrefix, "Newbie#" );
+
+  G_SanitiseName( namePrefix, namePrefix2 );
+
+  i = 0;
+
+  while( i < strlen( namePrefix2 ) && i < strlen( name2 ) )
+  {
+    if( namePrefix2[ i ] != name2[ i ] )
     {
-      Q_strncpyz( err, va( "The name '%s^7' is already in use", name ),
-        len );
-      return qfalse;
+      unnamed = qfalse;
+      break;
     }
+    i++;
   }
 
-  if( !g_adminNameProtect.string[ 0 ] )
+  if( testUnnamed && unnamed )
+  {
+    Q_strncpyz( err, va( "The name '%s^7' }.", name ), len );
+    return qfalse;
+  }
+
+  if( !g_adminNameProtect.string[ 0 ] || testUnnamed )
     return qtrue;
 
   for( i = 0; i < MAX_ADMIN_ADMINS && g_admin_admins[ i ]; i++ )
@@ -321,8 +653,8 @@
     if( !Q_stricmp( name2, testName ) &&
       Q_stricmp( ent->client->pers.guid, g_admin_admins[ i ]->guid ) )
     {
-      Q_strncpyz( err, va( "The name '%s^7' belongs to an admin, "
-        "please use another name", name ), len );
+      Q_strncpyz( err, va( "The name '%s^7' belongs to an admin. "
+        "Please choose another.", name ), len );
       return qfalse;
     }
   }
@@ -348,7 +680,7 @@
     {
       if( alevel < g_admin_admins[ i ]->level )
         return qfalse;
-      if( strstr( g_admin_admins[ i ]->flags, va( "%c", ADMF_IMMUTABLE ) ) )
+      if( strstr( g_admin_admins[ i ]->flags, va( "%s", ADMF_IMMUTABLE ) ) )
         return qfalse;
     }
   }
@@ -385,7 +717,7 @@
 
 static void admin_writeconfig_int( int v, fileHandle_t f )
 {
-  char buf[ 32 ];
+  char buf[ 64 ];
 
   Com_sprintf( buf, sizeof(buf), "%d", v );
   if( buf[ 0 ] )
@@ -397,7 +729,6 @@
 {
   fileHandle_t f;
   int len, i, j;
-  qtime_t qt;
   int t;
   char levels[ MAX_STRING_CHARS ] = {""};
 
@@ -407,7 +738,7 @@
       " configuration will not be saved to a file.\n" );
     return;
   }
-  t = trap_RealTime( &qt );
+  t = trap_RealTime( NULL );
   len = trap_FS_FOpenFile( g_admin.string, &f, FS_WRITE );
   if( len < 0 )
   {
@@ -429,7 +760,7 @@
   for( i = 0; i < MAX_ADMIN_ADMINS && g_admin_admins[ i ]; i++ )
   {
     // don't write level 0 users
-    if( g_admin_admins[ i ]->level < 1 )
+    if( g_admin_admins[ i ]->level == 0 )
       continue;
 
     trap_FS_Write( "[admin]\n", 8, f );
@@ -468,6 +799,33 @@
     admin_writeconfig_string( g_admin_bans[ i ]->banner, f );
     trap_FS_Write( "\n", 1, f );
   }
+  for( i = 0; i < MAX_ADMIN_HIDES && g_admin_hides[ i ]; i++ )
+  {
+    // don't write expired hides
+    // if expires is 0, then it's a perm hide
+    if( g_admin_hides[ i ]->expires != 0 &&
+         ( g_admin_hides[ i ]->expires - t ) < 1 )
+      continue;
+
+    trap_FS_Write( "[hide]\n", 7, f );
+    trap_FS_Write( "name    = ", 10, f );
+    admin_writeconfig_string( g_admin_hides[ i ]->name, f );
+    trap_FS_Write( "guid    = ", 10, f );
+    admin_writeconfig_string( g_admin_hides[ i ]->guid, f );
+    trap_FS_Write( "ip      = ", 10, f );
+    admin_writeconfig_string( g_admin_hides[ i ]->ip, f );
+    trap_FS_Write( "reason  = ", 10, f );
+    admin_writeconfig_string( g_admin_hides[ i ]->reason, f );
+    trap_FS_Write( "made    = ", 10, f );
+    admin_writeconfig_string( g_admin_hides[ i ]->made, f );
+    trap_FS_Write( "expires = ", 10, f );
+    admin_writeconfig_int( g_admin_hides[ i ]->expires, f );
+    trap_FS_Write( "hider   = ", 10, f );
+    admin_writeconfig_string( g_admin_hides[ i ]->hider, f );
+    trap_FS_Write( "hidden  = ", 10, f );
+    admin_writeconfig_int( g_admin_hides[ i ]->hidden, f );
+    trap_FS_Write( "\n", 1, f );
+  }
   for( i = 0; i < MAX_ADMIN_COMMANDS && g_admin_commands[ i ]; i++ )
   {
     levels[ 0 ] = '\0';
@@ -510,7 +868,7 @@
   s[ 0 ] = '\0';
   while( t[ 0 ] )
   {
-    if( ( s[ 0 ] == '\0' && strlen( t ) <= size ) 
+    if( ( s[ 0 ] == '\0' && strlen( t ) <= size )
       || ( strlen( t ) + strlen( s ) < size ) )
     {
 
@@ -739,6 +1097,20 @@
   }
   trap_FS_Write( string, strlen( string ), f );
   trap_FS_FCloseFile( f );
+  if ( !Q_stricmp( cmd, "attempted" ) )
+  {
+    Com_sprintf( string, sizeof( string ),
+                 "%s (%i) %s: %s",
+                 ( admin ) ? admin->client->pers.netname : "console",
+                 ( admin ) ? admin->s.clientNum : -1,
+                 cmd,
+                 G_SayConcatArgs( 1 + skiparg ) );
+    G_AdminsPrintf("%s\n",string);
+  }
+
+
+
+  G_LogPrintf("Admin Command: %s^7: %s %s\n",( admin ) ? admin->client->pers.netname : "console", cmd, G_SayConcatArgs( 1 + skiparg ));
 }
 
 static int admin_listadmins( gentity_t *ent, int start, char *search )
@@ -753,7 +1125,7 @@
   gentity_t *vic;
   int l = 0;
   qboolean dup = qfalse;
-  
+
   ADMBP_begin();
 
   // print out all connected players regardless of level if name searching
@@ -763,18 +1135,18 @@
 
     if( vic->client && vic->client->pers.connected != CON_CONNECTED )
       continue;
-    
+
     l = vic->client->pers.adminLevel;
 
     G_SanitiseName( vic->client->pers.netname, name );
     if( !strstr( name, search ) )
       continue;
 
-    for( j = 0; j <= 8; j++ )
+    for( j = 0; j < 8; j++ )
       guid_stub[ j ] = vic->client->pers.guid[ j + 24 ];
     guid_stub[ j ] = '\0';
-  
-    lname[ 0 ] = '\0'; 
+
+    lname[ 0 ] = '\0';
     Q_strncpyz( lname_fmt, "%s", sizeof( lname_fmt ) );
     for( j = 0; j < MAX_ADMIN_LEVELS && g_admin_levels[ j ]; j++ )
     {
@@ -806,7 +1178,7 @@
       G_SanitiseName( g_admin_admins[ i ]->name, name );
       if( !strstr( name, search ) )
         continue;
-      
+
       // verify we don't have the same guid/name pair in connected players
       // since we don't want to draw the same player twice
       dup = qfalse;
@@ -817,7 +1189,7 @@
           continue;
         G_SanitiseName( vic->client->pers.netname, name2 );
         if( !Q_stricmp( vic->client->pers.guid, g_admin_admins[ i ]->guid )
-          && strstr( name2, search ) ) 
+          && strstr( name2, search ) )
         {
           dup = qtrue;
           break;
@@ -826,11 +1198,11 @@
       if( dup )
         continue;
     }
-    for( j = 0; j <= 8; j++ )
+    for( j = 0; j < 8; j++ )
       guid_stub[ j ] = g_admin_admins[ i ]->guid[ j + 24 ];
     guid_stub[ j ] = '\0';
-   
-    lname[ 0 ] = '\0'; 
+
+    lname[ 0 ] = '\0';
     Q_strncpyz( lname_fmt, "%s", sizeof( lname_fmt ) );
     for( j = 0; j < MAX_ADMIN_LEVELS && g_admin_levels[ j ]; j++ )
     {
@@ -885,11 +1257,10 @@
 {
   char *guid, *ip;
   int i;
-  qtime_t qt;
   int t;
- 
-  *reason = '\0'; 
-  t  = trap_RealTime( &qt ); 
+
+  *reason = '\0';
+  t = trap_RealTime( NULL );
   if( !*userinfo )
     return qfalse;
   ip = Info_ValueForKey( userinfo, "ip" );
@@ -910,12 +1281,24 @@
       Com_sprintf(
         reason,
         rlen,
+        "Banned player %s (%s) tried to connnect (ban #%i by %s^7  expires %s reason: %s^7 )",
+        Info_ValueForKey( userinfo, "name" ),
+    g_admin_bans[ i ]->name,
+        i,
+        g_admin_bans[ i ]->banner,
+        duration,
+        g_admin_bans[ i ]->reason
+      );
+      G_AdminsPrintf("%s\n",reason);
+      Com_sprintf(
+        reason,
+        rlen,
         "You have been banned by %s^7 reason: %s^7 expires: %s",
         g_admin_bans[ i ]->banner,
         g_admin_bans[ i ]->reason,
         duration
       );
-      G_Printf("Banned player tried to connect from IP %s\n", ip);
+      G_LogPrintf("Banned player tried to connect from IP %s\n", ip);
       return qtrue;
     }
     if( *guid && !Q_stricmp( g_admin_bans[ i ]->guid, guid ) )
@@ -938,6 +1321,67 @@
   return qfalse;
 }
 
+qboolean G_admin_hide_check( char *userinfo, char *reason, int rlen, int *hidden, int *hiddenTime, int *id )
+{
+  char *guid, *ip;
+  int i;
+  int t;
+
+  if(reason)
+    *reason = '\0';
+  if(hidden)
+    *hidden = 0;
+  if(hiddenTime)
+    *hiddenTime = 0;
+  if(id)
+    *id = 0;
+  t = trap_RealTime( NULL );
+  if( !*userinfo )
+    return qfalse;
+  ip = Info_ValueForKey( userinfo, "ip" );
+  if( !*ip )
+    return qfalse;
+  guid = Info_ValueForKey( userinfo, "cl_guid" );
+  for( i = 0; i < MAX_ADMIN_HIDES && g_admin_hides[ i ]; i++ )
+  {
+    // 0 is for perm hide
+    if( g_admin_hides[ i ]->expires != 0 &&
+         ( g_admin_hides[ i ]->expires - t ) < 1 )
+      continue;
+    if(reason)
+        Com_sprintf(reason, rlen, "%s", g_admin_hides[ i ]->reason);
+    if(hidden)
+        *hidden = g_admin_hides[ i ]->hidden;
+    if(hiddenTime)
+    {
+        if(!g_admin_hides[ i ]->expires)
+        {
+            *hiddenTime = level.time + INFINITE;
+            while(*hiddenTime < level.time - 10)
+                (*hiddenTime)--;
+        }
+        else
+        {
+            *hiddenTime = level.time + ( g_admin_hides[ i ]->expires - t ) * 1000;
+            while(*hiddenTime < level.time - 10)
+                (*hiddenTime)--;
+        }
+    }
+    if(id)
+        *id = i;
+    
+    if( strstr( ip, g_admin_hides[ i ]->ip ) )
+    {
+      return qtrue;
+    }
+    if( *guid && !Q_stricmp( g_admin_hides[ i ]->guid, guid ) )
+    {
+      return qtrue;
+    }
+  }
+  return qfalse;
+}
+
 qboolean G_admin_cmd_check( gentity_t *ent, qboolean say )
 {
   int i;
@@ -966,6 +1410,14 @@
     return qfalse;
   }
 
+       // Flood limit.  If they're talking too fast, determine that and return.
+  if( g_floodMinTime.integer )
+   if ( G_Flood_Limited( ent ) )
+   {
+    trap_SendServerCommand( ent-g_entities, "print \"Your chat is flood-limited; wait before chatting again\n\"" );
+    return qtrue;
+   }
+
   for( i = 0; i < MAX_ADMIN_COMMANDS && g_admin_commands[ i ]; i++ )
   {
     if( Q_stricmp( cmd, g_admin_commands[ i ]->command ) )
@@ -989,7 +1441,7 @@
     if( Q_stricmp( cmd, g_admin_cmds[ i ].keyword ) )
       continue;
 
-    if( G_admin_permission( ent, g_admin_cmds[ i ].flag[ 0 ] ) )
+    if( G_admin_permission( ent, g_admin_cmds[ i ].flag ) )
     {
       g_admin_cmds[ i ].handler( ent, skip );
       admin_log( ent, cmd, skip );
@@ -1042,7 +1494,7 @@
         && g_admin_namelog[ i ]->name[ j ][ 0 ]; j++ )
       {
         G_SanitiseName( g_admin_namelog[ i ]->name[ j ], n2 );
-        if( !Q_stricmp( n1, n2 ) ) 
+        if( !Q_stricmp( n1, n2 ) )
           break;
       }
       if( j == MAX_ADMIN_NAMELOG_NAMES )
@@ -1080,13 +1532,14 @@
   g_admin_level_t * l = NULL;
   g_admin_admin_t *a = NULL;
   g_admin_ban_t *b = NULL;
+  g_admin_hide_t *h = NULL;
   g_admin_command_t *c = NULL;
-  int lc = 0, ac = 0, bc = 0, cc = 0;
+  int lc = 0, ac = 0, bc = 0, hc = 0, cc = 0;
   fileHandle_t f;
   int len;
   char *cnf, *cnf2;
   char *t;
-  qboolean level_open, admin_open, ban_open, command_open;
+  qboolean level_open, admin_open, ban_open, hide_open, command_open;
   char levels[ MAX_STRING_CHARS ] = {""};
 
   G_admin_cleanup();
@@ -1114,12 +1567,13 @@
   trap_FS_FCloseFile( f );
 
   t = COM_Parse( &cnf );
-  level_open = admin_open = ban_open = command_open = qfalse;
+  level_open = admin_open = ban_open = hide_open = command_open = qfalse;
   while( *t )
   {
     if( !Q_stricmp( t, "[level]" ) ||
          !Q_stricmp( t, "[admin]" ) ||
          !Q_stricmp( t, "[ban]" ) ||
+         !Q_stricmp( t, "[hide]" ) ||
          !Q_stricmp( t, "[command]" ) )
     {
 
@@ -1129,10 +1583,12 @@
         g_admin_admins[ ac++ ] = a;
       else if( ban_open )
         g_admin_bans[ bc++ ] = b;
+      else if( hide_open )
+        g_admin_hides[ hc++ ] = h;
       else if( command_open )
         g_admin_commands[ cc++ ] = c;
       level_open = admin_open =
-                     ban_open = command_open = qfalse;
+                     ban_open = hide_open = command_open = qfalse;
     }
 
     if( level_open )
@@ -1212,9 +1668,44 @@
       {
         admin_readconfig_string( &cnf, b->banner, sizeof( b->banner ) );
       }
+    }
+    else if( hide_open )
+    {
+      if( !Q_stricmp( t, "name" ) )
+      {
+        admin_readconfig_string( &cnf, h->name, sizeof( h->name ) );
+      }
+      else if( !Q_stricmp( t, "guid" ) )
+      {
+        admin_readconfig_string( &cnf, h->guid, sizeof( h->guid ) );
+      }
+      else if( !Q_stricmp( t, "ip" ) )
+      {
+        admin_readconfig_string( &cnf, h->ip, sizeof( h->ip ) );
+      }
+      else if( !Q_stricmp( t, "reason" ) )
+      {
+        admin_readconfig_string( &cnf, h->reason, sizeof( h->reason ) );
+      }
+      else if( !Q_stricmp( t, "made" ) )
+      {
+        admin_readconfig_string( &cnf, h->made, sizeof( h->made ) );
+      }
+      else if( !Q_stricmp( t, "expires" ) )
+      {
+        admin_readconfig_int( &cnf, &h->expires );
+      }
+      else if( !Q_stricmp( t, "hider" ) )
+      {
+        admin_readconfig_string( &cnf, h->hider, sizeof( h->hider ) );
+      }
+      else if( !Q_stricmp( t, "hidden" ) )
+      {
+        admin_readconfig_int( &cnf, &h->hidden );
+      }
       else
       {
-        ADMP( va( "^3!readconfig: ^7[ban] parse error near %s on line %d\n",
+        ADMP( va( "^3!readconfig: ^7[hide] parse error near %s on line %d\n",
                 t,
                 COM_GetCurrentParseLine() ) );
       }
@@ -1297,8 +1788,24 @@
       *b->made = '\0';
       b->expires = 0;
       *b->reason = '\0';
+      *b->banner = '\0';
       ban_open = qtrue;
     }
+    else if( !Q_stricmp( t, "[hide]" ) )
+    {
+      if( hc >= MAX_ADMIN_HIDES )
+        return qfalse;
+      h = G_Alloc( sizeof( g_admin_hide_t ) );
+      *h->name = '\0';
+      *h->guid = '\0';
+      *h->ip = '\0';
+      *h->made = '\0';
+      h->expires = 0;
+      *h->reason = '\0';
+      *h->hider = '\0';
+      h->hidden = 0;
+      hide_open = qtrue;
+    }
     else if( !Q_stricmp( t, "[command]" ) )
     {
       if( cc >= MAX_ADMIN_COMMANDS )
@@ -1321,19 +1828,21 @@
     g_admin_admins[ ac++ ] = a;
   if( ban_open )
     g_admin_bans[ bc++ ] = b;
+  if( hide_open )
+    g_admin_hides[ hc++ ] = h;
   if( command_open )
     g_admin_commands[ cc++ ] = c;
   G_Free( cnf2 );
-  ADMP( va( "^3!readconfig: ^7loaded %d levels, %d admins, %d bans, %d commands\n",
-          lc, ac, bc, cc ) );
+  ADMP( va( "^3!readconfig: ^7loaded %d levels, %d admins, %d bans, %d hides, %d commands\n",
+          lc, ac, bc, hc, cc ) );
   if( lc == 0 )
     admin_default_levels();
   else
   {
     char n[ MAX_NAME_LENGTH ] = {""};
     int i = 0;
- 
-    // max printable name length for formatting 
+
+    // max printable name length for formatting
     for( i = 0; i < MAX_ADMIN_LEVELS && g_admin_levels[ i ]; i++ )
     {
       G_DecolorString( l->name, n );
@@ -1355,6 +1864,336 @@
   return qtrue;
 }
 
+static int G_admin_find_slot( gentity_t *ent, char *cmd, char *name, char *nick, int nick_len )
+{
+char guid[ 33 ];
+char *p;
+int id;
+int i;
+qboolean numeric = qtrue;
+gentity_t *vic;
+
+if ( nick )
+nick[ 0 ] = '\0';
+
+p = name;
+while ( *p )
+{
+if( *p < '0' || *p > '9' )
+{
+numeric = qfalse;
+break;
+}
+p++;
+}
+if( !numeric || name[ 0 ] == '\0' )
+{
+ADMP( va( "^3!%s:^7 invalid slot number\n.", cmd ) );
+return -1;
+}
+
+guid[ 0 ] = '\0';
+id = atoi( name );
+if( id >= 0 && id < level.maxclients )
+{
+vic = &g_entities[ id ];
+if( !vic || !(vic->client) || vic->client->pers.connected != CON_CONNECTED )
+{
+ADMP( va( "^3!%s:^7 no one connected by that slot number\n", cmd ) );
+return qfalse;
+}
+Q_strncpyz( guid, vic->client->pers.guid, sizeof( guid ) );
+if( *guid == 'X' )
+{
+ADMP( va( "^3!%s:^7 player in slot %d has no GUID.\n", cmd, id ) );
+return qfalse;
+}
+for( i = 0; i < MAX_ADMIN_ADMINS && g_admin_admins[ i ]; i++ )
+{
+if( !Q_stricmp( guid, g_admin_admins[ i ]->guid ) )
+{
+id = i + MAX_CLIENTS;
+if( nick )
+Q_strncpyz( nick, vic->client->pers.netname, nick_len );
+break;
+}
+}
+}
+if( id < MAX_CLIENTS || id >= MAX_CLIENTS + MAX_ADMIN_ADMINS
+|| g_admin_admins[ id - MAX_CLIENTS ] == NULL )
+{
+if( *guid )
+ADMP( va( "^3!%s:^7 player is not !registered\n", cmd ) );
+else
+ADMP( va( "^3!%s:^7 no match. use !listplayers or !listadmins to "
+"find an appropriate slot # to use.\n", cmd ) );
+return -1;
+}
+id -= MAX_CLIENTS;
+
+
+if ( nick && !nick[ 0 ] )
+{
+Q_strncpyz( nick, g_admin_admins[ id ]->name, nick_len );
+}
+
+return id;
+}
+
+static int G_admin_user_flag_flagEqual( const char *flags, const char *flag )
+{
+    while( *flags == '-' || *flags == '+' ) flags++;
+    while( *flag == '-' || *flag == '+' ) flag++;
+    while( *flags && *flag )
+    {
+        if( *flags != '^' || *flag != '^' )
+            return *flags == *flag;
+        flags++;
+        flag++;
+    }
+    return 1;
+}
+
+static const char *G_admin_user_flag( int id, char *flag, qboolean add, qboolean clear )
+{
+  char add_flags[ MAX_ADMIN_FLAGS ];
+  char sub_flags[ MAX_ADMIN_FLAGS ];
+  char flagbuf[ MAX_NAME_LENGTH ];
+  char *flags;
+  int add_pos = 0;
+  int sub_pos = 0;
+  int i;
+  int wildcard = 0;
+
+  if( id < 0 || id >= MAX_ADMIN_ADMINS
+    || g_admin_admins[ id ] == NULL )
+  {
+    return "admin id out of range";
+  }
+
+  if( *flag == '-' || *flag == '+' || *flag == '*')
+  {
+    return "invalid admin flag";
+  }
+
+  flags = g_admin_admins[ id ]->flags;
+  while( *flags )
+  {
+    if( *flags == '+' )
+        flags++;
+    if( !G_admin_user_flag_flagEqual( flags, flag ) )
+    {
+      if( *flags != '-' )
+      {
+        if( add_pos < MAX_ADMIN_FLAGS - 1 )
+        {
+            flagbuf[0] = 0;
+            Q_strncpyz( flagbuf, flags, sizeof( flagbuf ) );
+            for( i = 0; i < sizeof( flagbuf ) - 1; i++ )
+            {
+                if( flagbuf[ i ] != '^' )
+                {
+                    flagbuf[ i + 1 ] = 0;
+                    break;
+                }
+            }
+            Q_strcat( add_flags, MAX_ADMIN_FLAGS, va( "%s", flagbuf ) );
+            add_pos += strlen( flagbuf );
+        }
+      }
+      else
+      {
+        if( sub_pos < MAX_ADMIN_FLAGS - 1 )
+        {
+            flags++;
+            flagbuf[0] = 0;
+            Q_strncpyz( flagbuf, flags, sizeof( flagbuf ) );
+            for( i = 0; i < sizeof( flagbuf ) - 1; i++ )
+            {
+                if( flagbuf[ i ] != '^' )
+                {
+                    flagbuf[ i + 1 ] = 0;
+                    break;
+                }
+            }
+            Q_strcat( sub_flags, MAX_ADMIN_FLAGS, va( "-%s", flagbuf ) );
+            sub_pos += strlen( va( "-%s", flagbuf ) );
+        }
+      }
+    }
+
+    while(*flags++ == '^');
+  }
+
+  if( !clear )
+  {
+    if( add )
+    {
+      if( *flag == '*' )
+      {
+        wildcard = qtrue;
+      }
+      else if( add_pos < MAX_ADMIN_FLAGS - 1 )
+      {
+        flagbuf[0] = 0;
+        Q_strncpyz( flagbuf, flag, sizeof( flagbuf ) );
+        for( i = 0; i < sizeof( flagbuf ) - 1; i++ )
+        {
+            if( flagbuf[ i ] != '^' )
+            {
+                flagbuf[ i + 1 ] = 0;
+                break;
+            }
+        }
+        Q_strcat( add_flags, MAX_ADMIN_FLAGS, va( "%s", flagbuf ) );
+        add_pos += strlen( flagbuf );
+      }
+    }
+    else
+    {
+      if( *flag == '*' )
+      {
+        wildcard = qfalse;
+      }
+      else if( sub_pos < MAX_ADMIN_FLAGS - 1 )
+      {
+        flagbuf[0] = 0;
+        Q_strncpyz( flagbuf, flag, sizeof( flagbuf ) );
+        for( i = 0; i < sizeof( flagbuf ) - 1; i++ )
+        {
+            if( flagbuf[ i ] != '^' )
+            {
+                flagbuf[ i + 1 ] = 0;
+                break;
+            }
+        }
+        Q_strcat( sub_flags, MAX_ADMIN_FLAGS, va( "-%s", flagbuf ) );
+        sub_pos += strlen( va( "-%s", flagbuf ) );
+G_Printf( "Debug: sub_pos: %d\nsub_flags: %s\nclear: %d\nadd: %d\nflag: %s\nflags: %s\nflagbuf: %s\n", sub_pos, sub_flags, clear, add, flag, flags, flagbuf );
+      }
+    }
+  }
+
+  if( add_pos + sub_pos + ( (wildcard || sub_pos) ? 1 : 0 ) + 1 >= MAX_ADMIN_FLAGS )
+  {
+    return "maximum admin flags exceeded";
+  }
+
+  add_flags[ add_pos ] = sub_flags[ sub_pos ] = 0;
+
+  Com_sprintf( g_admin_admins[ id ]->flags, MAX_ADMIN_FLAGS,
+    "%s%s%s",
+     add_flags,
+     ( wildcard ) ? "*" : "",
+//     ( sub_count && !wildcard ) ? "-" : "",
+     sub_flags );
+
+  return NULL;
+}
+
+qboolean G_admin_flag( gentity_t *ent, int skiparg )
+{
+  char output[ MAX_STRING_CHARS ];
+  char command[ MAX_ADMIN_CMD_LEN ], *cmd;
+  char name[ MAX_NAME_LENGTH ];
+  char flagbuf[ MAX_ADMIN_FLAGS + 9 ], *flag;
+  int id;
+  char adminname[ MAX_NAME_LENGTH ] = {""};
+  const char *result;
+  qboolean add = qtrue;
+  qboolean clear = qfalse;
+
+  G_SayArgv( skiparg, command, sizeof( command ) );
+  cmd = command;
+  if( *cmd == '!' )
+    cmd++;
+
+  if( G_SayArgc() < 2 + skiparg )
+  {
+    ADMP( va( "^3!%s: ^7usage: !%s slot# flag\n", cmd, cmd ) );
+    return qfalse;
+  }
+
+  G_SayArgv( 1 + skiparg, name, sizeof( name ) );
+  id = G_admin_find_slot( ent, cmd, name, adminname, sizeof( adminname ) );
+  if( id < 0 )
+    return qfalse;
+
+  if( ent && !admin_higher_guid( ent->client->pers.guid, g_admin_admins[ id ]->guid ) )
+  {
+    ADMP( va( "^3%s:^7 your intended victim has a higher admin level then you\n", cmd ) );
+    return qfalse;
+  }
+  if( G_SayArgc() < 3 + skiparg )
+  {
+    Q_strncpyz( output, g_admin_admins[ id ]->flags, sizeof( output ) );
+    EXCOLOR( output );
+    ADMP( va( "^3%s:^7 flags for %s^7 are '^3%s^7'\n",
+      cmd, adminname, output ) );
+    return qtrue;
+  }
+
+  G_SayArgv( 2 + skiparg, flagbuf, sizeof( flagbuf ) );
+  flag = flagbuf;
+  if( flag[ 0 ] == '-' && flag[ 1 ] != '\0' )
+  {
+    add = qfalse;
+    flag++;
+  }
+//  if( ent && !Q_stricmp( ent->client->pers.guid, g_admin_admins[ id ]->guid ) )
+//  {
+//    ADMP( va( "^3%s:^7 you may not change your own flags (use rcon)\n", cmd ) );
+//    return qfalse;
+//  }
+  if( !G_admin_permission( ent, flag ) && !G_admin_permission( ent, ADMF_EXTENSIVEADMINCONTROL ) )
+  {
+    ADMP( va( "^3%s:^7 you can only change flags that you also have\n", cmd ) );
+    return qfalse;
+  }
+
+  if( !Q_stricmp( cmd, "removeflag" ) )
+  {
+    clear = qtrue;
+  }
+
+  result = G_admin_user_flag( id, flag, add, clear );
+  if( result )
+  {
+    ADMP( va( "^3!%s: ^7an error occured setting flag '^3%c^7', %s\n",
+      cmd, flag[ 0 ], result ) );
+    return qfalse;
+  }
+
+  if( !Q_stricmp( cmd, "removeflag" ) )
+  {
+    Q_strncpyz( output, flag, sizeof( output ) );
+    EXCOLOR( output );
+    AP( va(
+      "print \"^3!%s: ^7admin flag '%s' for %s^7 cleared by %s\n\"",
+      cmd, output, adminname,
+      ( ent ) ? ent->client->pers.netname : "console" ) );
+  }
+  else
+  {
+    Q_strncpyz( output, flag, sizeof( output ) );
+    EXCOLOR( output );
+    AP( va(
+      "print \"^3!%s: ^7%s^7 was %s admin flag '%s' by %s\n\"",
+      cmd, adminname,
+      ( add ) ? "given" : "denied",
+      output,
+      ( ent ) ? ent->client->pers.netname : "console" ) );
+  }
+
+  if( !g_admin.string[ 0 ] )
+    ADMP( va( "^3!%s: ^7WARNING g_admin not set, not saving admin record "
+      "to a file\n", cmd ) );
+  else
+    admin_writeconfig();
+
+  return qtrue;
+}
+
 qboolean G_admin_setlevel( gentity_t *ent, int skiparg )
 {
   char name[ MAX_NAME_LENGTH ] = {""};
@@ -1422,7 +2261,7 @@
   if( numeric  && id >= 0 && id < level.maxclients )
     vic = &g_entities[ id ];
 
-  if( vic && vic->client && vic->client->pers.connected == CON_CONNECTED ) 
+  if( vic && vic->client && vic->client->pers.connected == CON_CONNECTED )
   {
     vic = &g_entities[ id ];
     Q_strncpyz( adminname, vic->client->pers.netname, sizeof( adminname ) );
@@ -1468,7 +2307,7 @@
             continue;
           G_SanitiseName(  vic->client->pers.netname, testname2 );
           if( !Q_stricmp( vic->client->pers.guid, g_admin_admins[ i ]->guid )
-            && strstr( testname2, name ) ) 
+            && strstr( testname2, name ) )
           {
             dup = qtrue;
             break;
@@ -1534,12 +2373,12 @@
     g_admin_admins[ i ] = a;
   }
 
-  AP( va( 
+  AP( va(
     "print \"^3!setlevel: ^7%s^7 was given level %d admin rights by %s\n\"",
     adminname, l, ( ent ) ? ent->client->pers.netname : "console" ) );
   if( vic )
     vic->client->pers.adminLevel = l;
-  
+
   if( !g_admin.string[ 0 ] )
     ADMP( "^3!setlevel: ^7WARNING g_admin not set, not saving admin record "
       "to a file\n" );
@@ -1553,12 +2392,14 @@
   char *guid,
   char *ip,
   int seconds,
-  char *reason ) 
+  char *reason )
 {
   g_admin_ban_t *b = NULL;
   qtime_t qt;
   int t;
   int i;
+  int j;
+  qboolean foundAdminTrueName=qfalse;
 
   t = trap_RealTime( &qt );
   b = G_Alloc( sizeof( g_admin_ban_t ) );
@@ -1576,8 +2417,19 @@
     qt.tm_hour, qt.tm_min, qt.tm_sec ),
     sizeof( b->made ) );
 
-  if( ent )
-    Q_strncpyz( b->banner, ent->client->pers.netname, sizeof( b->banner ) );
+  if( ent ) {
+    //Get admin true name
+    for(j = 0; j < MAX_ADMIN_ADMINS && g_admin_admins[ j ]; j++ )
+    {
+      if( !Q_stricmp( g_admin_admins[ j ]->guid, ent->client->pers.guid ) )
+      {
+          Q_strncpyz( b->banner, g_admin_admins[ j ]->name, sizeof( b->banner  ) );
+      foundAdminTrueName=qtrue;
+        break;
+      }
+    }
+    if(foundAdminTrueName==qfalse) Q_strncpyz( b->banner, ent->client->pers.netname, sizeof( b->banner ) );
+  }
   else
     Q_strncpyz( b->banner, "console", sizeof( b->banner ) );
   if( !seconds )
@@ -1600,7 +2452,109 @@
   return qtrue;
 }
 
+static qboolean admin_create_hide( gentity_t *ent,
+  char *netname,
+  char *guid,
+  char *ip,
+  int seconds,
+  char *reason,
+  int hidden )
+{
+  g_admin_hide_t *h = NULL;
+  qtime_t qt;
+  int t;
+  int i;
+  int j;
+  qboolean foundAdminTrueName=qfalse;
 
+  t = trap_RealTime( &qt );
+  h = G_Alloc( sizeof( g_admin_hide_t ) );
+
+  if( !h )
+    return qfalse;
+
+  Q_strncpyz( h->name, netname, sizeof( h->name ) );
+  Q_strncpyz( h->guid, guid, sizeof( h->guid ) );
+  Q_strncpyz( h->ip, ip, sizeof( h->ip ) );
+
+  //strftime( h->made, sizeof( b->made ), "%m/%d/%y %H:%M:%S", lt );
+  Q_strncpyz( h->made, va( "%02i/%02i/%02i %02i:%02i:%02i",
+    (qt.tm_mon + 1), qt.tm_mday, (qt.tm_year - 100),
+    qt.tm_hour, qt.tm_min, qt.tm_sec ),
+    sizeof( h->made ) );
+
+  if( ent ) {
+    //Get admin true name
+    for(j = 0; j < MAX_ADMIN_ADMINS && g_admin_admins[ j ]; j++ )
+    {
+      if( !Q_stricmp( g_admin_admins[ j ]->guid, ent->client->pers.guid ) )
+      {
+          Q_strncpyz( h->hider, g_admin_admins[ j ]->name, sizeof( h->hider  ) );
+      foundAdminTrueName=qtrue;
+        break;
+      }
+    }
+    if(foundAdminTrueName==qfalse) Q_strncpyz( h->hider, ent->client->pers.netname, sizeof( h->hider ) );
+  }
+  else
+    Q_strncpyz( h->hider, "console", sizeof( h->hider ) );
+  if( !seconds )
+    h->expires = 0;
+  else
+    h->expires = t + seconds;
+  if( !*reason )
+    Q_strncpyz( h->reason, "hidden by admin", sizeof( h->reason ) );
+  else
+    Q_strncpyz( h->reason, reason, sizeof( h->reason ) );
+  if( !hidden )
+    h->hidden = 0;
+  else
+    h->hidden = hidden;
+  for( i = 0; i < MAX_ADMIN_HIDES && g_admin_hides[ i ]; i++ )
+    ;
+  if( i == MAX_ADMIN_HIDES )
+  {
+    ADMP( "^3!hides: ^7too many hides\n" );
+    G_Free( h );
+    return qfalse;
+  }
+  g_admin_hides[ i ] = h;
+  return qtrue;
+}
+
+int G_admin_parse_time( const char *time )
+{
+  int seconds = 0, num = 0;
+  int i;
+  for( i = 0; time[ i ]; i++ )
+  {
+    if( isdigit( time[ i ] ) )
+    {
+      num = num * 10 + time[ i ] - '0';
+      continue;
+    }
+    if( i == 0 || !isdigit( time[ i - 1 ] ) )
+      return -1;
+    switch( time[ i ] )
+    {
+      case 'w': num *= 7;
+      case 'd': num *= 24;
+      case 'h': num *= 60;
+      case 'm': num *= 60;
+      case 's': break;
+      default:  return -1;
+    }
+    seconds += num;
+    num = 0;
+  }
+  if( num )
+    seconds += num;
+  // overflow
+  if( seconds < 0 )
+    seconds = 0;
+  return seconds;
+}
+
 qboolean G_admin_kick( gentity_t *ent, int skiparg )
 {
   int pids[ MAX_CLIENTS ], found;
@@ -1631,25 +2585,15 @@
         " level than you\n" );
     return qfalse;
   }
-  vic = &g_entities[ pids[ 0 ] ];
-  if( g_adminTempBan.integer > 0 )
-  {
-    admin_create_ban( ent,
-      vic->client->pers.netname,
-      vic->client->pers.guid,
-      vic->client->pers.ip, g_adminTempBan.integer,
-      "automatic temp ban created by kick" );
-    if( g_admin.string[ 0 ] )
-      admin_writeconfig();
-  }
-  
-  trap_SendServerCommand( pids[ 0 ],
-    va( "disconnect \"You have been kicked.\n%s^7\nreason:\n%s\"",
-      ( ent ) ? va( "admin:\n%s", ent->client->pers.netname ) : "",
-      ( *reason ) ? reason : "kicked by admin" ) );
+  vic = &g_entities[ pids[ 0 ] ];+   admin_create_ban( ent,
+     vic->client->pers.netname,
+     vic->client->pers.guid,
+     vic->client->pers.ip, G_admin_parse_time( g_adminTempBan.string ),
+     ( *reason ) ? reason : "kicked by admin" );
+   if( g_admin.string[ 0 ] )
+     admin_writeconfig();
 
-  trap_DropClient( pids[ 0 ], va( "has been kicked%s^7. reason: %s",
-    ( ent ) ? va( " by %s", ent->client->pers.netname ) : "",
+   trap_DropClient( pids[ 0 ], va( "kicked^7, reason: %s",
     ( *reason ) ? reason : "kicked by admin" ) );
 
   return qtrue;
@@ -1663,7 +2607,6 @@
   char *reason;
   int minargc;
   char duration[ 32 ];
-  int modifier = 1;
   int logmatch = -1, logmatches = 0;
   int i, j;
   qboolean exactmatch = qfalse;
@@ -1687,32 +2630,14 @@
   }
   if( G_SayArgc() < minargc )
   {
-    ADMP( "^3!ban: ^7usage: !ban [name|slot|ip] [seconds] [reason]\n" );
+    ADMP( "^3!ban: ^7usage: !ban [name|slot|ip] [time] [reason]\n" );
     return qfalse;
   }
   G_SayArgv( 1 + skiparg, search, sizeof( search ) );
   G_SanitiseName( search, s2 );
   G_SayArgv( 2 + skiparg, secs, sizeof( secs ) );
 
-  // support "w" (weeks), "d" (days), "h" (hours), and "m" (minutes) modifiers
-  if( secs[ 0 ] )
-  {
-    int lastchar = strlen( secs ) - 1;
-    if( secs[ lastchar ] == 'w' )
-      modifier = 60 * 60 * 24 * 7;
-    else if( secs[ lastchar ] == 'd' )
-      modifier = 60 * 60 * 24;
-    else if( secs[ lastchar ] == 'h' )
-      modifier = 60 * 60;
-    else if( secs[ lastchar ] == 'm' )
-      modifier = 60;
-    else if( secs[ lastchar ] < '0' || secs[ lastchar ] > '9' )
-      secs[ lastchar ] = '\0';
-  }
-  seconds = atoi( secs );
-  if( seconds > 0 )
-    seconds *= modifier;
-
+  seconds = G_admin_parse_time( secs );
   if( seconds <= 0 )
   {
     if( G_admin_permission( ent, ADMF_CAN_PERM_BAN ) )
@@ -1748,7 +2673,7 @@
       exactmatch = qtrue;
       break;
     }
-  } 
+  }
 
   for( i = 0;
        !exactmatch && i < MAX_ADMIN_NAMELOGS && g_admin_namelog[ i ];
@@ -1773,23 +2698,23 @@
       {
         if( logmatch != i )
           logmatches++;
-        logmatch = i; 
+        logmatch = i;
       }
     }
   }
-  
-  if( !logmatches ) 
+
+  if( !logmatches )
   {
     ADMP( "^3!ban: ^7no player found by that name, IP, or slot number\n" );
     return qfalse;
-  } 
+  }
   else if( logmatches > 1 )
   {
     ADMBP_begin();
     ADMBP( "^3!ban: ^7multiple recent clients match name, use IP or slot#:\n" );
     for( i = 0; i < MAX_ADMIN_NAMELOGS && g_admin_namelog[ i ]; i++ )
     {
-      for( j = 0; j <= 8; j++ )
+      for( j = 0; j < 8; j++ )
         guid_stub[ j ] = g_admin_namelog[ i ]->guid[ j + 24 ];
       guid_stub[ j ] = '\0';
       for( j = 0; j < MAX_ADMIN_NAMELOG_NAMES
@@ -1812,7 +2737,7 @@
     ADMBP_end();
     return qfalse;
   }
-  
+
   G_admin_duration( ( seconds ) ? seconds : -1,
     duration, sizeof( duration ) );
 
@@ -1829,7 +2754,7 @@
     g_admin_namelog[ logmatch ]->name[ 0 ],
     g_admin_namelog[ logmatch ]->guid,
     g_admin_namelog[ logmatch ]->ip,
-    seconds, reason ); 
+    seconds, reason );
 
   g_admin_namelog[ logmatch ]->banned = qtrue;
 
@@ -1838,7 +2763,7 @@
   else
     admin_writeconfig();
 
-  if(g_admin_namelog[ logmatch ]->slot == -1 ) 
+  if( g_admin_namelog[ logmatch ]->slot == -1 )
   {
     // client is already disconnected so stop here
     AP( va( "print \"^3!ban:^7 %s^7 has been banned by %s^7 "
@@ -1850,46 +2775,180 @@
     return qtrue;
   }
 
-  trap_SendServerCommand( g_admin_namelog[ logmatch ]->slot,
-    va( "disconnect \"You have been banned.\n"
-      "admin:\n%s^7\nduration:\n%s\nreason:\n%s\"",
-      ( ent ) ? ent->client->pers.netname : "console",
-      duration,
-      ( *reason ) ? reason : "kicked by admin" ) );
-
   trap_DropClient(  g_admin_namelog[ logmatch ]->slot,
-    va( "has been banned by %s^7 duration: %s, reason: %s",
+    va( "banned by %s^7, duration: %s, reason: %s",
       ( ent ) ? ent->client->pers.netname : "console",
       duration,
       ( *reason ) ? reason : "banned by admin" ) );
   return qtrue;
 }
 
+qboolean G_admin_adjustban( gentity_t *ent, int skiparg )
+{
+  int bnum;
+  int length;
+  int expires;
+  char duration[ 32 ] = {""};
+  char *reason;
+  char bs[ 5 ];
+  char secs[ 7 ];
+
+  if( G_SayArgc() < 3 + skiparg )
+  {
+    ADMP( "^3!adjustban: ^7usage: !adjustban [ban#] [time] [reason]\n" );
+    return qfalse;
+  }
+  G_SayArgv( 1 + skiparg, bs, sizeof( bs ) );
+  bnum = atoi( bs );
+  if( bnum < 1 || bnum > MAX_ADMIN_BANS || !g_admin_bans[ bnum - 1] )
+  {
+    ADMP( "^3!adjustban: ^7invalid ban#\n" );
+    return qfalse;
+  }
+
+  G_SayArgv( 2 + skiparg, secs, sizeof( secs ) );
+  length = G_admin_parse_time( secs );
+  if( length < 0 )
+    reason = G_SayConcatArgs( 2 + skiparg );
+  else
+  {
+    if( length != 0 )
+      expires = trap_RealTime( NULL ) + length;
+    else if( G_admin_permission( ent, ADMF_CAN_PERM_BAN ) )
+      expires = 0;
+    else
+    {
+      ADMP( "^3!ban: ^7ban time must be positive\n" );
+      return qfalse;
+    }
+
+    g_admin_bans[ bnum - 1 ]->expires = expires;
+    G_admin_duration( ( length ) ? length : -1, duration, sizeof( duration ) );
+    reason = G_SayConcatArgs( 3 + skiparg );
+  }
+  if( *reason )
+    Q_strncpyz( g_admin_bans[ bnum - 1 ]->reason, reason,
+      sizeof( g_admin_bans[ bnum - 1 ]->reason ) );
+  AP( va( "print \"^3!adjustban: ^7ban #%d for %s^7 has been updated by %s^7 "
+    "%s%s%s%s%s\n\"",
+    bnum,
+    g_admin_bans[ bnum - 1 ]->name,
+    ( ent ) ? ent->client->pers.netname : "console",
+    ( length >= 0 ) ? "duration: " : "",
+    duration,
+    ( length >= 0 && *reason ) ? ", " : "",
+    ( *reason ) ? "reason: " : "",
+    reason ) );
+  if( ent )
+    Q_strncpyz( g_admin_bans[ bnum - 1 ]->banner, ent->client->pers.netname,
+      sizeof( g_admin_bans[ bnum - 1 ]->banner ) );
+  if( g_admin.string[ 0 ] )
+    admin_writeconfig();
+  return qtrue;
+}
+
+qboolean G_admin_adjusthide( gentity_t *ent, int skiparg )
+{
+  int hnum;
+  int length;
+  int hidden = 1;
+  int expires;
+  char duration[ 32 ] = {""};
+  char *reason = NULL;
+  char hs[ 5 ];
+  char secs[ 7 ];
+  char hiddenC[ 7 ];
+
+  if( G_SayArgc() < 3 + skiparg )
+  {
+    ADMP( "^3!adjusthide: ^7usage: !adjusthide [hide#] [time] [(c) hidden] [reason]\n" );
+    return qfalse;
+  }
+  G_SayArgv( 1 + skiparg, hs, sizeof( hs ) );
+  hnum = atoi( hs );
+  if( hnum < 1 || hnum > MAX_ADMIN_HIDES || !g_admin_hides[ hnum - 1] )
+  {
+    ADMP( "^3!adjusthide: ^7invalid hide#\n" );
+    return qfalse;
+  }
+
+  G_SayArgv( 2 + skiparg, secs, sizeof( secs ) );
+  G_SayArgv( 3 + skiparg, hiddenC, sizeof( hiddenC ) );
+  length = G_admin_parse_time( secs );
+  if( length < 0 && ((secs[0] == 'c' || secs[0] == 'C' || secs[0] == 'h' || secs[0] == 'H') && ((secs[1] == ' ' || secs[1] == '\t' || secs[1] == '-') || (secs[1] >= '0' && secs[1] <= '9') || (hiddenC[0] && hiddenC[0] >= '0' && hiddenC[0] <= '9'))) && G_SayArgc() > 3 + skiparg )
+  {
+    G_SayArgv(3 + skiparg, secs, sizeof( secs ) );
+    if(secs[1] == ' ')
+    {
+        char *p = &secs[1];
+        while(*p == ' ' || *p == '\t' || *p == '-') p++;
+        hidden = atoi(p);
+    }
+    else
+    {
+        hidden = atoi(hiddenC);
+    }
+    g_admin_hides[ hnum - 1 ]->hidden = hidden;
+  }
+  else if( length < 0 )
+    reason = G_SayConcatArgs( 2 + skiparg );
+  else
+  {
+    if( length != 0 )
+      expires = trap_RealTime( NULL ) + length;
+    else if( length >= 0 )
+      expires = 0;
+    else
+    {
+      ADMP( "^3!adjusthide: ^7hide time must be positive\n" );
+      return qfalse;
+    }
+
+    g_admin_hides[ hnum - 1 ]->expires = expires;
+    G_admin_duration( ( length ) ? length : -1, duration, sizeof( duration ) );
+    reason = G_SayConcatArgs( 3 + skiparg );
+  }
+  if( reason && *reason )
+    Q_strncpyz( g_admin_hides[ hnum - 1 ]->reason, reason,
+      sizeof( g_admin_hides[ hnum - 1 ]->reason ) );
+  AP( va( "print \"^3!adjusthide: ^7hide #%d for %s^7 has been updated by %s^7 "
+    "%s%s%s%s%s%s\n\"",
+    hnum,
+    g_admin_hides[ hnum - 1 ]->name,
+    ( ent ) ? ent->client->pers.netname : "console",
+    ( length < 0 && ((secs[0] == 'c' || secs[0] == 'C' || secs[0] == 'h' || secs[0] == 'H') && ((secs[1] == ' ' || secs[1] == '\t' || secs[1] == '-') || (secs[1] >= '0' && secs[1] <= '9') || (hiddenC[0] && hiddenC[0] >= '0' && hiddenC[0] <= '9'))) && G_SayArgc() > 3 + skiparg ) ? (hidden ? "hidden: hidden" : "hidden: unhidden") : "",
+    ( length >= 0 ) ? "duration: " : "",
+    duration,
+    ( length >= 0 && reason && *reason ) ? ", " : "",
+    ( reason && *reason ) ? "reason: " : "",
+    reason ? reason : "" ) );
+  if( ent )
+    Q_strncpyz( g_admin_hides[ hnum - 1 ]->hider, ent->client->pers.netname,
+      sizeof( g_admin_hides[ hnum - 1 ]->hider ) );
+  if( g_admin.string[ 0 ] )
+    admin_writeconfig();
+  return qtrue;
+}
+
 qboolean G_admin_unban( gentity_t *ent, int skiparg )
 {
   int bnum;
-  char bs[ 4 ];
-  qtime_t qt;
+  char bs[ 5 ];
   int t;
 
-  t = trap_RealTime( &qt );
+  t = trap_RealTime( NULL );
   if( G_SayArgc() < 2 + skiparg )
   {
-    ADMP( "^3!unban: ^7usage: !unban [ban #]\n" );
+    ADMP( "^3!unban: ^7usage: !unban [ban#]\n" );
     return qfalse;
   }
   G_SayArgv( 1 + skiparg, bs, sizeof( bs ) );
   bnum = atoi( bs );
-  if( bnum < 1 )
+  if( bnum < 1 || bnum > MAX_ADMIN_BANS || !g_admin_bans[ bnum - 1 ] )
   {
-    ADMP( "^3!unban: ^7invalid ban #\n" );
+    ADMP( "^3!unban: ^7invalid ban#\n" );
     return qfalse;
   }
-  if( !g_admin_bans[ bnum - 1 ] )
-  {
-    ADMP( "^3!unban: ^7invalid ban #\n" );
-    return qfalse;
-  }
   g_admin_bans[ bnum -1 ]->expires = t;
   AP( va( "print \"^3!unban: ^7ban #%d for %s^7 has been removed by %s\n\"",
           bnum,
@@ -1900,10 +2959,78 @@
   return qtrue;
 }
 
+qboolean G_admin_putscrimteam( gentity_t *ent, int skiparg )
+{
+  int pids[ MAX_CLIENTS ], found;
+  char name[ MAX_NAME_LENGTH ], weaponName[ MAX_STRING_CHARS ], *teamName, err[ MAX_STRING_CHARS ];
+  weapon_t weapon;
+  gentity_t *vic;
+  oc_scrimTeam_t *t;
+
+  G_SayArgv( 1 + skiparg, name, sizeof( name ) );
+  G_SayArgv( 2 + skiparg, weaponName, sizeof( weaponName ) );
+  teamName = G_SayConcatArgs( 3 + skiparg );
+  if( G_SayArgc() < 4 + skiparg )
+  {
+    ADMP( "^3!putscrimteam: ^7usage: !putscrimteam [name] [weapon] [teamname/0fornoteam]\n" );
+    return qfalse;
+  }
+  if( ( found = G_ClientNumbersFromString( name, pids, MAX_CLIENTS ) ) != 1 )
+  {
+    G_MatchOnePlayer( pids, found, err, sizeof( err ) );
+    ADMP( va( "^3!putscrimteam: ^7%s\n", err ) );
+    return qfalse;
+  }
+  if( !admin_higher( ent, &g_entities[ pids[ 0 ] ] ) )
+  {
+    ADMP( "^3!putscrimteam: ^7sorry, but your intended victim has a higher "
+        " admin level than you\n" );
+    return qfalse;
+  }
+  vic = &g_entities[ pids[ 0 ] ];
+
+  if(!strcmp(teamName, "0"))
+  {
+    // remove player from team
+    G_OCScrimTeamRemovePlayer(vic);
+    return qtrue;
+  }
+  else if(G_OCScrimTeam(teamName))
+  {
+    // existing team
+    if(vic->client->pers.ocTeam)
+        G_OCScrimTeamRemovePlayer(vic);
+    vic->client->pers.ocTeam = G_OCScrimTeam(teamName) - level.scrimTeam;
+    G_ClientPrint(NULL, va("%s^7 was put on to scrim team %s^7 (%ss^7) by %s", vic->client->pers.netname, level.scrimTeam[vic->client->pers.ocTeam].name, BG_FindHumanNameForWeapon(level.scrimTeam[vic->client->pers.ocTeam].weapon), ( ent ) ? ent->client->pers.netname : "console"), 0);
+    return qtrue;
+  }
+  else
+  {
+    // new team
+    weapon = BG_FindWeaponNumForName( weaponName );
+    if(G_WeaponIsReserved(weapon))
+    {
+        ADMP( va( "^3!putscrimteam: ^7the %s^7 is already in use by another team\n", BG_FindHumanNameForWeapon(weapon) ) );
+        return qfalse;
+    }
+    if(!(t = G_OCNewScrimTeam(teamName, weapon, err, sizeof(err))))
+    {
+        ADMP( va( "^3!putscrimteam: ^7couldn't creat scrim team: %s\n", err ) );
+        return qfalse;
+    }
+    if(vic->client->pers.ocTeam)
+        G_OCScrimTeamRemovePlayer(vic);
+    vic->client->pers.ocTeam = t - level.scrimTeam;
+    AP(va("print \"^3!putscrimteam: ^7%s^7 created and put %s^7 on to the new OC scrim team %s (%ss^7)\n\"", ( ent ) ? ent->client->pers.netname : "console", vic->client->pers.netname, t->name, BG_FindHumanNameForWeapon(weapon)));
+    return qtrue;
+  }
+}
+
 qboolean G_admin_putteam( gentity_t *ent, int skiparg )
 {
   int pids[ MAX_CLIENTS ], found;
-  char name[ MAX_NAME_LENGTH ], team[ 7 ], err[ MAX_STRING_CHARS ];
+  char name[ MAX_NAME_LENGTH ], team[ 7 ], err[ MAX_STRING_CHARS ], secs[ 7 ];
+  int seconds = 0;
   gentity_t *vic;
   pTeam_t teamnum = PTE_NONE;
   char teamdesc[ 32 ] = {"spectators"};
@@ -1912,7 +3039,7 @@
   G_SayArgv( 2 + skiparg, team, sizeof( team ) );
   if( G_SayArgc() < 3 + skiparg )
   {
-    ADMP( "^3!putteam: ^7usage: !putteam [name] [h|a|s]\n" );
+    ADMP( "^3!putteam: ^7usage: !putteam [name] [h|a|s] (duration)\n" );
     return qfalse;
   }
 
@@ -1946,13 +3073,52 @@
     ADMP( va( "^3!putteam: ^7unknown team %c\n", team[ 0 ] ) );
     return qfalse;
   }
-  if( vic->client->pers.teamSelection == teamnum )
+  // duration
+  if( G_SayArgc() > 3 + skiparg )
+  {
+    int modifier = 1;
+    // only allow locking into spec
+    if ( teamnum != PTE_NONE )
+    {
+      ADMP( "^3!putteam: ^7You are can only lock a player into the spectators team\n" );
+      return qfalse;
+    }
+    // only allow setting a time if have permission
+    if ( !G_admin_permission( ent, ADMF_PUTTEAMEXT ) )
+    {
+      ADMP( "^3!putteam: ^7You are not allowed to lock a player into the spectators team\n" );
+      return qfalse;
+    }
+    G_SayArgv( 3 + skiparg, secs, sizeof( secs ) );
+    // support "h" (hours), and "m" (minutes) modifiers
+    if( secs[ 0 ] )
+    {
+      int lastchar = strlen( secs ) - 1;
+      if( secs[ lastchar ] == 'h' )
+        modifier = 60 * 60;
+      else if( secs[ lastchar ] == 'm' )
+        modifier = 60;
+      else if( secs[ lastchar ] < '0' || secs[ lastchar ] > '9' )
+        secs[ lastchar ] = '\0';
+    }
+    seconds = atoi( secs );
+    if( seconds > 0 )
+      seconds *= modifier;
+    else
+      seconds = 0;
+  }
+  if( vic->client->pers.teamSelection == teamnum && teamnum != PTE_NONE )
+  {
+    ADMP( va( "^3!putteam: ^7%s ^7is already on the %s team\n", vic->client->pers.netname, teamdesc ) );
     return qfalse;
+  }
+  vic->client->pers.specExpires = level.time + seconds * 1000;
   G_ChangeTeam( vic, teamnum );
 
-  AP( va( "print \"^3!putteam: ^7%s^7 put %s^7 on to the %s team\n\"",
+  AP( va( "print \"^3!putteam: ^7%s^7 put %s^7 on to the %s team%s\n\"",
           ( ent ) ? ent->client->pers.netname : "console",
-          vic->client->pers.netname, teamdesc ) );
+          vic->client->pers.netname, teamdesc,
+          ( seconds ) ? va( " for %i seconds", seconds ) : "" ) );
   return qtrue;
 }
 
@@ -1960,7 +3126,7 @@
 {
   char map[ MAX_QPATH ];
   char layout[ MAX_QPATH ] = { "" };
-  
+
   if( G_SayArgc( ) < 2 + skiparg )
   {
     ADMP( "^3!map: ^7usage: !map [map] (layout)\n" );
@@ -1993,12 +3159,571 @@
 
   trap_SendConsoleCommand( EXEC_APPEND, va( "map %s", map ) );
   level.restarted = qtrue;
-  AP( va( "print \"^3!map: ^7map '%s' started by %s %s\n\"", map,
+  AP( va( "print \"^3!map: ^7map '%s' started by %s^7 %s\n\"", map,
           ( ent ) ? ent->client->pers.netname : "console",
           ( layout[ 0 ] ) ? va( "(forcing layout '%s')", layout ) : "" ) );
   return qtrue;
 }
 
+qboolean G_admin_devmap( gentity_t *ent, int skiparg )
+{
+  char map[ MAX_QPATH ];
+  char layout[ MAX_QPATH ] = { "" };
+
+  if( G_SayArgc( ) < 2 + skiparg )
+  {
+    ADMP( "^3!devmap: ^7usage: !devmap [map] (layout)\n" );
+    return qfalse;
+  }
+
+  G_SayArgv( skiparg + 1, map, sizeof( map ) );
+
+  if( !trap_FS_FOpenFile( va( "maps/%s.bsp", map ), NULL, FS_READ ) )
+  {
+    ADMP( va( "^3!devmap: ^7invalid map name '%s'\n", map ) );
+    return qfalse;
+  }
+
+  if( G_SayArgc( ) > 2 + skiparg )
+  {
+    G_SayArgv( skiparg + 2, layout, sizeof( layout ) );
+    if( !Q_stricmp( layout, "*BUILTIN*" ) ||
+      trap_FS_FOpenFile( va( "layouts/%s/%s.dat", map, layout ),
+        NULL, FS_READ ) > 0 )
+    {
+      trap_Cvar_Set( "g_layouts", layout );
+    }
+    else
+    {
+      ADMP( va( "^3!devmap: ^7invalid layout name '%s'\n", layout ) );
+      return qfalse;
+    }
+  }
+
+  trap_SendConsoleCommand( EXEC_APPEND, va( "devmap %s", map ) );
+  level.restarted = qtrue;
+  AP( va( "print \"^3!devmap: ^7map '%s' started by %s^7 with cheats %s\n\"", map,
+          ( ent ) ? ent->client->pers.netname : "console",
+          ( layout[ 0 ] ) ? va( "(forcing layout '%s')", layout ) : "" ) );
+  return qtrue;
+}
+
+qboolean G_admin_layoutsave( gentity_t *ent, int skiparg )
+{
+  char layout[ MAX_QPATH ];
+  char command[ MAX_ADMIN_CMD_LEN ], *cmd;
+  char output[ MAX_STRING_CHARS ];
+
+  G_SayArgv( skiparg, command, sizeof( command ) );
+  cmd = command;
+  if( cmd && *cmd == '!' )
+    cmd++;
+
+  if( G_SayArgc( ) < 2 + skiparg )
+  {
+    ADMP( "^3!layoutsave: ^7usage: !layoutsave [layout]\n" );
+    return qfalse;
+  }
+
+  G_SayArgv( skiparg + 1, layout, sizeof( layout ) );
+
+  if( !( *layout == 'o' && *(layout + 1) == 'c' ) || ( g_ocReview.integer && !Q_stricmp( cmd, "layoutsave" ) ) )
+  {
+    trap_SendConsoleCommand( EXEC_APPEND, va( "layoutsave %s", layout ) );
+    Q_strncpyz( output, va( "layout saved as '%s'", layout ), sizeof( output ));
+    EXCOLOR( output );
+    AP( va( "print \"^3!layoutsave: ^7%s^7 by ^7%s^7\n\"", output,
+            ( ent ) ? ent->client->pers.netname : "console" ) );
+  }
+  else
+  {
+    trap_SendConsoleCommand( EXEC_APPEND, va( "layoutsave %s_review", layout ) );
+    Q_strncpyz( output, va( "layout saved for review as '%s_review'", layout ), sizeof( output ));
+    EXCOLOR( output );
+    AP( va( "print \"^3!layoutsave: ^7%s^7 by ^7%s^7\n\"", output,
+            ( ent ) ? ent->client->pers.netname : "console" ) );
+  }
+  return qtrue;
+}
+
+qboolean G_admin_hbp( gentity_t *ent, int skiparg )
+{
+  int bnum;
+  char bs[ 99 ];
+  qtime_t qt;
+  int t;
+
+  t = trap_RealTime( &qt );
+
+  if( G_SayArgc() < 2 + skiparg )
+  {
+    ADMP( "^3!cheat-hbp: ^7usage: !cheat-hbp [bp]\n" );
+    return qfalse;
+  }
+
+  G_SayArgv( 1 + skiparg, bs, sizeof( bs ) );
+  bnum = atoi( bs );
+  if( bnum < 0 )
+  {
+    ADMP( va("^6Humans Build Points ^4%d\n", trap_Cvar_VariableIntegerValue("g_humanBuildPoints")) );
+    ADMP( "^3!cheat-hbp: ^7invalid bp #\n" );
+    return qfalse;
+  }
+
+  if ( ent && !g_cheats.integer && !g_allowAdminCheats.integer )
+  {
+    ADMP( "^3!cheat-hbp: ^7Cheats are not enabled on this server\n" );
+    return qfalse;
+  }
+
+  trap_SendConsoleCommand( EXEC_APPEND, va( "g_humanBuildPoints %d", bnum ) );
+
+
+  AP( va( "print \"^3!cheat-hbp: ^7Humans' build points changed to '%d' by %s\n\"", bnum,
+          ( ent ) ? ent->client->pers.netname : "console" ) );
+  return qtrue;
+}
+
+qboolean G_admin_abp( gentity_t *ent, int skiparg )
+{
+  int bnum;
+  char bs[ 99 ];
+  qtime_t qt;
+  int t;
+
+  t = trap_RealTime( &qt );
+
+  if( G_SayArgc() < 2 + skiparg )
+  {
+    ADMP( va("^6Aliens Build Points ^4%d\n", trap_Cvar_VariableIntegerValue("g_alienBuildPoints")) );
+    ADMP( "^3!cheat-abp: ^7usage: !cheat-abp [bp]\n" );
+    return qfalse;
+  }
+
+  G_SayArgv( 1 + skiparg, bs, sizeof( bs ) );
+  bnum = atoi( bs );
+  if( bnum < 0 )
+  {
+    ADMP( "^3!cheat-abp: ^7invalid bp #\n" );
+    return qfalse;
+  }
+
+  if ( ent && !g_cheats.integer && !g_allowAdminCheats.integer )
+  {
+    ADMP( "^3!cheat-abp: ^7Cheats are not enabled on this server\n" );
+    return qfalse;
+  }
+
+  trap_SendConsoleCommand( EXEC_APPEND, va( "g_alienBuildPoints %d", bnum ) );
+
+
+  AP( va( "print \"^3!cheat-abp: ^7Aliens' build points changed to '%d' by %s\n\"", bnum,
+          ( ent ) ? ent->client->pers.netname : "console" ) );
+  return qtrue;
+}
+
+void G_ADMIN_CuStOm_ammo( gentity_t *ent)
+{
+
+    int maxAmmo, maxClips;
+    gclient_t *client = ent->client;
+
+    if( client->ps.weapon != WP_ALEVEL3_UPG &&
+        BG_FindInfinteAmmoForWeapon( client->ps.weapon ) )
+      return;
+
+    BG_FindAmmoForWeapon( client->ps.weapon, &maxAmmo, &maxClips );
+
+    if( BG_FindUsesEnergyForWeapon( client->ps.weapon ) &&
+        BG_InventoryContainsUpgrade( UP_BATTPACK, client->ps.stats ) )
+      maxAmmo = (int)( (float)maxAmmo * BATTPACK_MODIFIER );
+
+    BG_PackAmmoArray( client->ps.weapon, client->ps.ammo, client->ps.misc, maxAmmo, maxClips );
+}
+
+qboolean G_admin_giveall( gentity_t *ent, int skiparg )
+{
+
+
+  if (!ent || ent->client->pers.teamSelection == PTE_NONE || ent->client->sess.sessionTeam == TEAM_SPECTATOR || ent->client->ps.stats[ STAT_HEALTH ] <= 0)
+  {
+    ADMP( "Join a team first / Must be living to use this command / Cannot be run as console\n" );
+    return qfalse;
+  }
+
+  if ( !g_cheats.integer && !g_allowAdminCheats.integer )
+  {
+    ADMP( "^3!cheat-give-all: ^7Cheats are not enabled on this server\n" );
+    return qfalse;
+  }
+
+  ent->client->pers.hasCheated = 1;
+  ent->client->pers.cheated = 1;
+
+  ent->health = ent->client->ps.stats[ STAT_MAX_HEALTH ];
+  BG_AddUpgradeToInventory( UP_MEDKIT, ent->client->ps.stats );
+
+  G_AddCreditToClient( ent->client, HUMAN_MAX_CREDITS, qtrue );
+
+  ent->client->ps.stats[ STAT_STAMINA ] = MAX_STAMINA;
+
+  ent->client->ps.stats[ STAT_STATE ] |= SS_BOOSTED;
+  ent->client->lastBoostedTime = level.time;
+
+  G_ADMIN_CuStOm_ammo( ent );
+
+/*  int maxAmmoXXX, maxClipsXXX;
+  gclient_t *client = ent->client;
+
+  if( client->ps.weapon != WP_ALEVEL3_UPG &&
+    BG_FindInfinteAmmoForWeapon( client->ps.weapon ) )
+    return qtrue;
+
+  BG_FindAmmoForWeapon( client->ps.weapon, &maxAmmoXXX, &maxClipsXXX );
+
+  if( BG_FindUsesEnergyForWeapon( client->ps.weapon ) &&
+      BG_InventoryContainsUpgrade( UP_BATTPACK, client->ps.stats ) )
+      maxAmmoXXX = (int)( (float)maxAmmoXXX * BATTPACK_MODIFIER );
+
+    BG_PackAmmoArray( client->ps.weapon, client->ps.ammo, client->ps.misc, maxAmmoXXX, maxClipsXXX );*/
+
+
+    AP( va(
+      "print \"^3!cheat-give-all: ^7%s^7 cheats.\n\"",
+      ( ent ) ? ent->client->pers.netname : "console" ) );
+
+  return qtrue;
+}
+
+qboolean G_admin_god( gentity_t *ent, int skiparg )
+{
+  if (!ent || ent->client->pers.teamSelection == PTE_NONE || ent->client->sess.sessionTeam == TEAM_SPECTATOR || ent->client->ps.stats[ STAT_HEALTH ] <= 0)
+  {
+    ADMP( "Join a team first / Must be living to use this command / Cannot be run as console\n" );
+    return qfalse;
+  }
+
+  if ( !g_cheats.integer && !g_allowAdminCheats.integer )
+  {
+    ADMP( "^3!cheat-god: ^7Cheats are not enabled on this server\n" );
+    return qfalse;
+  }
+
+  ent->client->pers.hasCheated = 1;
+  ent->client->pers.cheated = ( ( ent->flags & FL_GODMODE ) ? ( 0 ) : ( 1 ) );
+  ent->flags ^= FL_GODMODE;
+
+  trap_SendServerCommand( ent - g_entities, va( "print \"%s\"", ( ent->flags & FL_GODMODE ) ? ("godmode ON\n") : ("godmode OFF\n") ));
+
+    AP( va(
+      "print \"^3!cheat-god: ^7%s^7 cheats.\n\"",
+      ( ent ) ? ent->client->pers.netname : "console" ) );
+
+  return qtrue;
+}
+
+qboolean G_admin_kill( gentity_t *ent, int skiparg )
+{
+  if (!ent || ent->client->pers.teamSelection == PTE_NONE || ent->client->sess.sessionTeam == TEAM_SPECTATOR || ent->client->ps.stats[ STAT_HEALTH ] <= 0)
+  {
+    ADMP( "Join a team first / Must be living to use this command / Cannot be run as console\n" );
+    return qfalse;
+  }
+
+  if ( !g_cheats.integer && !g_allowAdminCheats.integer )
+  {
+    ADMP( "^3!cheat-kill: ^7Cheats are not enabled on this server\n" );
+    return qfalse;
+  }
+
+  ent->client->pers.hasCheated = 1;
+  ent->client->pers.cheated = 0;
+  ent->flags &= ~FL_GODMODE;
+  ent->client->ps.stats[ STAT_HEALTH ] = ent->health = 0;
+  player_die( ent, ent, ent, 100000, MOD_SUICIDE );
+
+
+    AP( va(
+      "print \"^3!cheat-kill: ^7%s^7 cheats.\n\"",
+      ( ent ) ? ent->client->pers.netname : "console" ) );
+
+    return qtrue;
+}
+
+qboolean G_admin_noclip( gentity_t *ent, int skiparg )
+{
+  if (!ent || ent->client->pers.teamSelection == PTE_NONE || ent->client->sess.sessionTeam == TEAM_SPECTATOR || ent->client->ps.stats[ STAT_HEALTH ] <= 0)
+  {
+    ADMP( "Join a team first / Must be living to use this command / Cannot be run as console\n" );
+    return qfalse;
+  }
+
+  if ( !g_cheats.integer && !g_allowAdminCheats.integer )
+  {
+    ADMP( "^3!cheat-noclip: ^7Cheats are not enabled on this server\n" );
+    return qfalse;
+  }
+
+  ent->client->pers.hasCheated = 1;
+  ent->client->pers.cheated = ent->client->noclip = !ent->client->noclip;
+
+  trap_SendServerCommand( ent - g_entities, va( "print \"%s\"", (ent->client->noclip) ? ("noclip ON\n") : ("noclip OFF\n") ) );
+
+
+    AP( va(
+      "print \"^3!cheat-noclip: ^7%s^7 cheats.\n\"",
+      ( ent ) ? ent->client->pers.netname : "console" ) );
+
+  return qtrue;
+}
+
+qboolean G_admin_setCheat( gentity_t *ent, int skiparg )
+{
+  int pids[ MAX_CLIENTS ], found;
+  char name[ MAX_NAME_LENGTH ], err[ MAX_STRING_CHARS ];
+  char command[ MAX_ADMIN_CMD_LEN ], *cmd;
+  gentity_t *vic;
+
+  G_SayArgv( skiparg, command, sizeof( command ) );
+  cmd = command;
+  if( cmd && *cmd == '!' )
+    cmd++;
+  if( G_SayArgc() < 2 + skiparg )
+  {
+    ADMP( va( "^3!%s: ^7usage: !%s [name|slot#]\n", cmd, cmd ) );
+    return qfalse;
+  }
+  G_SayArgv( 1 + skiparg, name, sizeof( name ) );
+  if( ( found = G_ClientNumbersFromString( name, pids, MAX_CLIENTS ) ) != 1 )
+  {
+    G_MatchOnePlayer( pids, found, err, sizeof( err ) );
+    ADMP( va( "^3!%s: ^7%s\n", cmd, err ) );
+    return qfalse;
+  }
+  if( !admin_higher( ent, &g_entities[ pids[ 0 ] ] ) )
+  {
+    ADMP( va( "^3!%s: ^7sorry, but your intended victim has a higher admin"
+        " level than you\n", cmd ) );
+    return qfalse;
+  }
+  vic = &g_entities[ pids[ 0 ] ];
+  if( vic->client->pers.muted == qtrue )
+  {
+    if( !Q_stricmp( cmd, "setCheat" ) )
+    {
+      ADMP( va( "^3!%s: ^7player has already cheated\n", cmd ) );
+      return qtrue;
+    }
+    vic->client->pers.hasCheated = 0;
+    CPx( pids[ 0 ], "cp \"^2You haven't cheated\"" );
+    AP( va( "print \"^3!unsetCheat: ^7%s^7 forced the game forget that ^7%s^7 had cheated\n\"",
+            ( ent ) ? ent->client->pers.netname : "console",
+            vic->client->pers.netname ) );
+  }
+  else
+  {
+    if( !Q_stricmp( cmd, "unsetCheat" ) )
+    {
+      ADMP( "^3!unmute: ^7player is not currently muted\n" );
+      return qtrue;
+    }
+    vic->client->pers.hasCheated = 1;
+    CPx( pids[ 0 ], "cp \"^1You have cheated\"" );
+    AP( va( "print \"^3!setCheat: ^7%s^7 reminded the game that ^7%s^7 had cheated\n\"",
+            ( ent ) ? ent->client->pers.netname : "console",
+            vic->client->pers.netname ) );
+  }
+  ClientUserinfoChanged( pids[ 0 ] );
+  return qtrue;
+}
+
+qboolean G_admin_notarget( gentity_t *ent, int skiparg )
+{
+  if (!ent || ent->client->pers.teamSelection == PTE_NONE || ent->client->sess.sessionTeam == TEAM_SPECTATOR || ent->client->ps.stats[ STAT_HEALTH ] <= 0)
+  {
+    ADMP( "Join a team first / Must be living to use this command / Cannot be run as console\n" );
+    return qfalse;
+  }
+
+  if ( !g_cheats.integer && !g_allowAdminCheats.integer )
+  {
+    ADMP( "^3!cheat-notarget: ^7Cheats are not enabled on this server\n" );
+    return qfalse;
+  }
+
+
+  ent->client->pers.hasCheated = 1;
+  ent->client->pers.cheated = ( ( ent->flags & FL_NOTARGET ) ? ( 0 ) : ( 1 ) );
+  ent->flags ^= FL_NOTARGET;
+
+
+  trap_SendServerCommand( ent - g_entities, va( "print \"%s\"", ( ent->flags & FL_NOTARGET ) ? ("notarget ON\n") : ("notarget OFF\n") ) );
+
+
+    AP( va(
+      "print \"^3!cheat-notarget: ^7%s^7 cheats.\n\"",
+      ( ent ) ? ent->client->pers.netname : "console" ) );
+
+  return qtrue;
+}
+
+qboolean G_admin_friendlyfire( gentity_t *ent, int skiparg )
+{
+  int bnum;
+  char bs[ 99 ];
+
+  if( G_SayArgc() < 2 + skiparg )
+  {
+    ADMP( va("^6Friendly Fire ^4%d\n", trap_Cvar_VariableIntegerValue("g_friendlyFire")) );
+    ADMP( "^3!friendlyfire: ^7usage: !friendlyfire [1/0]\n" );
+    return qfalse;
+  }
+
+  G_SayArgv( 1 + skiparg, bs, sizeof( bs ) );
+  bnum = atoi( bs );
+  if( bnum < 0 )
+  {
+    ADMP( "^3!friendlyfire: ^7invalid value\n" );
+    return qfalse;
+  }
+  if( bnum > 1 )
+  {
+    ADMP( "^3!friendlyfire: ^7invalid value\n" );
+    return qfalse;
+  }
+  if (bnum == 1)
+  {
+    trap_SendConsoleCommand( EXEC_APPEND, va( "g_friendlyFire 1\n" ) );
+    trap_SendConsoleCommand( EXEC_APPEND, va( "g_friendlyBuildableFire 1\n" ) );
+    trap_SendConsoleCommand( EXEC_APPEND, va( "g_friendlyFireHumans 1\n" ) );
+    trap_SendConsoleCommand( EXEC_APPEND, va( "g_friendlyFireAliens 1\n" ) );
+
+  AP( va( "print \"^3!friendlyfire: ^7%s^7 ^5ENABLED^7 friendly fire\n\"",
+          ( ent ) ? ent->client->pers.netname : "console" ) );
+    return qtrue;
+  }
+  if (bnum == 0)
+  {
+    trap_SendConsoleCommand( EXEC_APPEND, va( "g_friendlyFire 0\n" ) );
+    trap_SendConsoleCommand( EXEC_APPEND, va( "g_friendlyBuildableFire 0\n" ) );
+    trap_SendConsoleCommand( EXEC_APPEND, va( "g_friendlyFireHumans 0\n" ) );
+    trap_SendConsoleCommand( EXEC_APPEND, va( "g_friendlyFireAliens 0\n" ) );
+
+  AP( va( "print \"^3!friendlyfire: ^7%s^7 ^5DISABLED^7 friendly fire\n\"",
+          ( ent ) ? ent->client->pers.netname : "console" ) );
+  return qtrue;
+  }
+  return qfalse;
+}
+
+qboolean G_admin_hs( gentity_t *ent, int skiparg )
+{
+  int bnum;
+  char bs[ 99 ];
+  qtime_t qt;
+  int t;
+
+  t = trap_RealTime( &qt );
+
+  if( G_SayArgc() < 2 + skiparg )
+  {
+    ADMP( va("^6Humans Stage ^4%d\n", trap_Cvar_VariableIntegerValue("g_humanStage")) );
+    ADMP( "^3!cheat-hs: ^7usage: !cheat-hs [stage]\n" );
+    return qfalse;
+  }
+
+  G_SayArgv( 1 + skiparg, bs, sizeof( bs ) );
+  bnum = atoi( bs ) - 1;
+  if( bnum < 0 )
+  {
+    ADMP( "^3!cheat-hs: ^7invalid stage #\n" );
+    return qfalse;
+  }
+
+  if ( ent && !g_cheats.integer && !g_allowAdminCheats.integer )
+  {
+    ADMP( "^3!cheat-hs: ^7Cheats are not enabled on this server\n" );
+    return qfalse;
+  }
+
+  trap_SendConsoleCommand( EXEC_APPEND, va( "g_humanStage %d", bnum ) );
+
+
+  AP( va( "print \"^3!cheat-hs: ^7Humans' stage changed to '%d' by %s\n\"", bnum + 1,
+          ( ent ) ? ent->client->pers.netname : "console" ) );
+  return qtrue;
+}
+
+qboolean G_admin_as( gentity_t *ent, int skiparg )
+{
+  int bnum;
+  char bs[ 99 ];
+  qtime_t qt;
+  int t;
+
+  t = trap_RealTime( &qt );
+
+  if( G_SayArgc() < 2 + skiparg )
+  {
+    ADMP( va("^6Aliens Stage ^4%d\n", trap_Cvar_VariableIntegerValue("g_alienStage")) );
+    ADMP( "^3!cheat-as: ^7usage: !cheat-as [stage]\n" );
+    return qfalse;
+  }
+
+  G_SayArgv( 1 + skiparg, bs, sizeof( bs ) );
+  bnum = atoi( bs ) - 1;
+  if( bnum < 0 )
+  {
+    ADMP( "^3!cheat-as: ^7invalid stage #\n" );
+    return qfalse;
+  }
+
+  if ( ent && !g_cheats.integer && !g_allowAdminCheats.integer )
+  {
+    ADMP( "^3!cheat-as: ^7Cheats are not enabled on this server\n" );
+    return qfalse;
+  }
+
+  trap_SendConsoleCommand( EXEC_APPEND, va( "g_alienStage %d", bnum ) );
+
+
+  AP( va( "print \"^3!cheat-as: ^7Aliens' stage changed to '%d' by %s\n\"", bnum + 1,
+          ( ent ) ? ent->client->pers.netname : "console" ) );
+  return qtrue;
+}
+
+qboolean G_admin_customgravity( gentity_t *ent, int skiparg )
+{
+  int bnum;
+  char bs[ 99 ];
+  qtime_t qt;
+  int t;
+
+  t = trap_RealTime( &qt );
+
+  if( G_SayArgc() < 2 + skiparg )
+  {
+    ADMP( va("^6Gravity ^4%d\n", trap_Cvar_VariableIntegerValue("g_gravity")) );
+    ADMP( "^3!customgravity: ^7usage: !customgravity [gravity]\n" );
+    return qfalse;
+  }
+
+  G_SayArgv( 1 + skiparg, bs, sizeof( bs ) );
+  bnum = atoi( bs );
+  if( bnum < 0 )
+  {
+    ADMP( "^3!customgravity: ^7invalid gravity #\n" );
+    return qfalse;
+  }
+
+  trap_SendConsoleCommand( EXEC_APPEND, va( "g_gravity %d", bnum ) );
+
+
+  AP( va( "print \"^3!customgravity: ^7Gravity changed to '%d' by %s\n\"", bnum,
+          ( ent ) ? ent->client->pers.netname : "console" ) );
+  return qtrue;
+}
+
 qboolean G_admin_mute( gentity_t *ent, int skiparg )
 {
   int pids[ MAX_CLIENTS ], found;
@@ -2059,6 +3784,208 @@
   return qtrue;
 }
 
+qboolean G_admin_hide( gentity_t *ent, int skiparg )
+{
+  int seconds;
+  char secs[ 7 ];
+  char duration[ 32 ];
+  int pids[ MAX_CLIENTS ], found;
+  char name[ MAX_NAME_LENGTH ], *reason, err[ MAX_STRING_CHARS ];
+  char command[ MAX_ADMIN_CMD_LEN ], *cmd;
+  gentity_t *vic;
+
+  if( !level.oc )
+  {
+    ADMP( "^3!hide: ^7can only be used during an obstacle course\n" );
+    return qfalse;
+  }
+//  // admins can still hide?
+//  if( !g_allowHiding.integer )
+//  {
+//    ADMP( "^3!hide: ^7hiding has been disabled\n" );
+//    return qfalse;
+//  }
+
+  if( G_SayArgc() < 2 + skiparg )
+  {
+    ADMP( "^3!hide: ^7usage: !hide [name|slot#] (reason)\n" );
+    return qfalse;
+  }
+  G_SayArgv( skiparg, command, sizeof( command ) );
+  cmd = command;
+  if( cmd && *cmd == '!' )
+    cmd++;
+  G_SayArgv( 1 + skiparg, name, sizeof( name ) );
+  reason = G_SayConcatArgs( 2 + skiparg );
+  if( ( found = G_ClientNumbersFromString( name, pids, MAX_CLIENTS ) ) != 1 )
+  {
+    G_MatchOnePlayer( pids, found, err, sizeof( err ) );
+    ADMP( va( "^3!hide: ^7%s\n", err ) );
+    return qfalse;
+  }
+  if( !admin_higher( ent, &g_entities[ pids[ 0 ] ] ) )
+  {
+    ADMP( "^3!hide: ^7sorry, but your intended victim has a higher admin"
+        " level than you\n" );
+    return qfalse;
+  }
+  vic = &g_entities[ pids[ 0 ] ];
+  if( Q_stricmp( cmd, "hide" ) )
+  {
+    int id, t;
+    char userinfo[ MAX_INFO_STRING ];
+    // remove hide
+    trap_GetUserinfo( vic - g_entities, userinfo, sizeof( userinfo ) );
+    if(G_admin_hide_check( userinfo, NULL, 0, NULL, NULL, &id ) )
+    {
+        t = trap_RealTime( NULL );
+        g_admin_hides[ id ]->expires = t;
+        if( g_admin.string[ 0 ] )
+            admin_writeconfig();
+    }
+    vic->r.svFlags &= ~SVF_SINGLECLIENT;
+    vic->client->pers.hidden = qfalse;
+    if( G_SayArgc() == 2 + skiparg )
+    {
+        AP( va( "print \"^3!unhide: ^7%s^7 has been unhidden by ^7%s\n\"",
+                vic->client->pers.netname,
+                ( ent ) ? ent->client->pers.netname : "console" ) );
+    }
+    else
+    {
+        G_SayArgv( 2 + skiparg, secs, sizeof( secs ) );
+        seconds = G_admin_parse_time( secs );
+        G_admin_duration( seconds, duration, sizeof( duration ) );
+        admin_create_hide( ent, vic->client->pers.netname, vic->client->pers.guid, vic->client->pers.ip, seconds, ( *reason ) ? reason : "unhidden by admin", 0 );
+        admin_writeconfig();
+
+        vic->client->pers.hiddenTime = level.time + seconds * 1000;
+        AP( va( "print \"^3!unhide: ^7%s^7 has been unhidden by ^7%s; force duration: ^7%s^7\n\"",
+                vic->client->pers.netname,
+                ( ent ) ? ent->client->pers.netname : "console", duration ) );
+    }
+  }
+  else
+  {
+    int id, t;
+    char userinfo[ MAX_INFO_STRING ];
+    // remove hide
+    trap_GetUserinfo( vic - g_entities, userinfo, sizeof( userinfo ) );
+    if(G_admin_hide_check( userinfo, NULL, 0, NULL, NULL, &id ) )
+    {
+        t = trap_RealTime( NULL );
+        g_admin_hides[ id ]->expires = t;
+        if( g_admin.string[ 0 ] )
+            admin_writeconfig();
+    }
+    vic->client->pers.hidden = qtrue;
+    G_StopFromFollowing( vic );
+    vic->r.svFlags |= SVF_SINGLECLIENT;
+    vic->r.singleClient = vic-g_entities;
+    CPx( pids[ 0 ], "cp \"^1You've been hidden\"" );
+    if( G_SayArgc() == 2 + skiparg )
+    {
+        AP( va( "print \"^3!hide: ^7%s^7 has been hidden by ^7%s\n\"",
+                vic->client->pers.netname,
+                ( ent ) ? ent->client->pers.netname : "console" ) );
+    }
+    else
+    {
+        G_SayArgv( 2 + skiparg, secs, sizeof( secs ) );
+        seconds = G_admin_parse_time( secs );
+        G_admin_duration( seconds, duration, sizeof( duration ) );
+        admin_create_hide( ent, vic->client->pers.netname, vic->client->pers.guid, vic->client->pers.ip, seconds, ( *reason ) ? reason : "hidden by admin", 1 );
+        admin_writeconfig();
+
+        vic->client->pers.hiddenTime = level.time + seconds * 1000;
+        AP( va( "print \"^3!hide: ^7%s^7 has been hidden by ^7%s; force duration: ^7%s^7\n\"",
+                vic->client->pers.netname,
+                ( ent ) ? ent->client->pers.netname : "console", duration ) );
+    }
+  }
+
+  ClientUserinfoChanged( pids[ 0 ] );
+  return qtrue;
+}
+
+qboolean G_admin_canEditOC( gentity_t *ent )
+{
+    // Run a series of checks for each edit mode.  If the user passes all, return true
+
+    if ( !ent )  // A client is needed to build
+      return qfalse;
+
+    if (!level.oc)  // Make sure there's playing an obstacle course
+      return qfalse;
+
+    if (g_ocEditMode.integer == 0)  // See if the builder has permissions with the current edit mode
+        return qfalse;
+
+    if (g_ocEditMode.integer == 1 && !G_admin_permission( ent, ADMF_LAYOUTEDIT ))  // ...
+        return qfalse;
+
+    return qtrue;
+}
+
+qboolean G_admin_editoc( gentity_t *ent, int skiparg )
+{
+  gentity_t *client;
+  char command[ MAX_ADMIN_CMD_LEN ];
+  int i;
+  G_SayArgv( skiparg+1, command, sizeof( command ) );
+  if( level.oc )
+  {
+    if( !Q_stricmp( command, "0" ) || !Q_stricmp( command, "off" ) )
+    {
+      AP( va( "print \"^3!editoc: ^7Admin cheating and oc editing ^5DISABLED^7 to ^2off^7 by ^7%s^7\n\"",
+              ( ent ) ? ent->client->pers.netname : "console" ) );
+      trap_Cvar_Set( "g_ocEditMode", "0" );
+      trap_Cvar_Set( "g_allowadmincheats", "0" );
+      for( i = 0; i < level.maxclients; i++ )
+      {
+        client = &g_entities[ i ];
+        if( client->client )
+          client->client->pers.noAuO = 0;
+      }
+    }
+    else if( !Q_stricmp( command, "1" ) || !Q_stricmp( command, "allwithflag" ) )
+    {
+      AP( va( "print \"^3!editoc: ^7Admin cheating and oc editing ^5ENABLED^7 to ^2allwithflag^7 by ^7%s^7\n\"",
+              ( ent ) ? ent->client->pers.netname : "console" ) );
+      trap_Cvar_Set( "g_ocEditMode", "1" );
+      trap_Cvar_Set( "g_allowadmincheats", "1" );
+      for( i = 0; i < level.maxclients; i++ )
+      {
+        client = &g_entities[ i ];
+        if( client->client )
+          client->client->pers.noAuO = 0;
+      }
+    }
+    else if( !Q_stricmp( command, "2" ) || !Q_stricmp( command, "all" ) )
+    {
+      AP( va( "print \"^3!editoc: ^7Admin cheating and oc editing ^5ENABLED^7 to ^1all^7 by ^7%s^7\n\"",
+              ( ent ) ? ent->client->pers.netname : "console" ) );
+      trap_Cvar_Set( "g_ocEditMode", "2" );
+      trap_Cvar_Set( "g_allowadmincheats", "1" );
+      for( i = 0; i < level.maxclients; i++ )
+      {
+        client = &g_entities[ i ];
+        if( client->client )
+          client->client->pers.noAuO = 0;
+      }
+    }
+    else
+    {
+      return qfalse;
+    }
+  }
+  else
+  {
+    return qfalse;
+  }
+  return qtrue;
+}
+
 qboolean G_admin_denybuild( gentity_t *ent, int skiparg )
 {
   int pids[ MAX_CLIENTS ], found;
@@ -2112,6 +4039,10 @@
     }
     vic->client->pers.denyBuild = qtrue;
     vic->client->ps.stats[ STAT_BUILDABLE ] = BA_NONE;
+    if( vic->client->ps.stats[ STAT_PCLASS ]== PCL_ALIEN_BUILDER0 || vic->client->ps.stats[ STAT_PCLASS ] == PCL_ALIEN_BUILDER0_UPG )
+    {
+      vic->suicideTime = level.time + 1000;
+    }
     CPx( pids[ 0 ], "cp \"^1You've lost your building rights\"" );
     AP( va(
       "print \"^3!denybuild: ^7building rights for ^7%s^7 revoked by ^7%s\n\"",
@@ -2125,16 +4056,12 @@
 qboolean G_admin_listadmins( gentity_t *ent, int skiparg )
 {
   int i, found = 0;
-  qtime_t qt;
-  int t;
   char search[ MAX_NAME_LENGTH ] = {""};
   char s[ MAX_NAME_LENGTH ] = {""};
   int start = 0;
   qboolean numeric = qtrue;
   int drawn = 0;
 
-  t = trap_RealTime( &qt );
-
   for( i = 0; i < MAX_ADMIN_ADMINS && g_admin_admins[ i ]; i++ )
   {
     if( g_admin_admins[ i ]->level == 0 )
@@ -2154,9 +4081,9 @@
     {
       if( s[ i ] >= '0' && s[ i ] <= '9' )
         continue;
-      numeric = qfalse; 
+      numeric = qfalse;
     }
-    if( numeric ) 
+    if( numeric )
     {
       start = atoi( s );
       if( start > 0 )
@@ -2211,12 +4138,12 @@
   char *s;
   char layout[ MAX_QPATH ] = { "" };
   int i = 0;
-  
-  if( G_SayArgc( ) == 2 + skiparg ) 
+
+  if( G_SayArgc( ) == 2 + skiparg )
     G_SayArgv( 1 +skiparg, map, sizeof( map ) );
   else
     trap_Cvar_VariableStringBuffer( "mapname", map, sizeof( map ) );
-  
+
   count = G_LayoutList( map, list, sizeof( list ) );
   ADMBP_begin( );
   ADMBP( va( "^3!listlayouts:^7 %d layouts found for '%s':\n", count, map ) );
@@ -2225,6 +4152,7 @@
   {
     if( *s == ' ' )
     {
+      EXCOLOR( layout );
       ADMBP( va ( " %s\n", layout ) );
       layout[ 0 ] = '\0';
       i = 0;
@@ -2237,7 +4165,10 @@
     s++;
   }
   if( layout[ 0 ] )
+  {
+    EXCOLOR( layout );
     ADMBP( va ( " %s\n", layout ) );
+  }
   ADMBP_end( );
   return qtrue;
 }
@@ -2253,7 +4184,7 @@
   char lname[ MAX_NAME_LENGTH ];
   char lname2[ MAX_NAME_LENGTH ];
   char guid_stub[ 9 ];
-  char muted[ 2 ], denied[ 2 ];
+  char muted[ 2 ], denied[ 2 ], dbuilder[ 2 ];
   int l;
   char lname_fmt[ 5 ];
 
@@ -2286,7 +4217,7 @@
       continue;
     }
 
-    for( j = 0; j <= 8; j++ )
+    for( j = 0; j < 8; j++ )
       guid_stub[ j ] = p->pers.guid[ j + 24 ];
     guid_stub[ j ] = '\0';
 
@@ -2301,6 +4232,20 @@
       Q_strncpyz( denied, "B", sizeof( denied ) );
     }
 
+    dbuilder[ 0 ] = '\0';
+    if( p->pers.designatedBuilder )
+    {
+      if( !G_admin_permission( &g_entities[ i ], ADMF_INCOGNITO ) &&
+          G_admin_permission( &g_entities[ i ], ADMF_DBUILDER ) )
+      {
+        Q_strncpyz( dbuilder, "P", sizeof( dbuilder ) );
+      }
+      else
+      {
+        Q_strncpyz( dbuilder, "D", sizeof( dbuilder ) );
+      }
+    }
+
     l = 0;
     G_SanitiseName( p->pers.netname, n2 );
     n[ 0 ] = '\0';
@@ -2310,7 +4255,7 @@
       {
 
         // don't gather aka or level info if the admin is incognito
-        if( G_admin_permission( &g_entities[ i ], ADMF_INCOGNITO ) )
+        if( ent && G_admin_permission( &g_entities[ i ], ADMF_INCOGNITO ) )
         {
           break;
         }
@@ -2341,16 +4286,17 @@
       }
 
     }
-    
+
     if( G_admin_permission(ent, ADMF_SEESFULLLISTPLAYERS ) )
     {
-      ADMBP( va( "%2i %s%s^7 %-2i %s^7 (*%s) ^1%1s%1s^7 %s^7 %s%s^7%s\n",
+      ADMBP( va( "%2i %s%s^7 %-2i %s^7 (*%s) ^1%1s%1s%1s^7 %s^7 %s%s^7%s\n",
                 i,
                 c,
                 t,
                 l,
-                ( *lname ) ? lname2 : "", 
+                ( *lname ) ? lname2 : "",
                 guid_stub,
+                dbuilder,
                 muted,
                 denied,
                 p->pers.netname,
@@ -2376,7 +4322,6 @@
 qboolean G_admin_showbans( gentity_t *ent, int skiparg )
 {
   int i, found = 0;
-  qtime_t qt;
   int t;
   char duration[ 32 ];
   char name_fmt[ 32 ] = { "%s" };
@@ -2391,7 +4336,7 @@
   char n1[ MAX_NAME_LENGTH ] = {""};
   char n2[ MAX_NAME_LENGTH ] = {""};
 
-  t = trap_RealTime( &qt );
+  t = trap_RealTime( NULL );
 
   for( i = 0; i < MAX_ADMIN_BANS && g_admin_bans[ i ]; i++ )
   {
@@ -2417,7 +4362,7 @@
   if( start >= MAX_ADMIN_BANS || start < 0 )
     start = 0;
 
-  for( i = start; i < MAX_ADMIN_BANS && g_admin_bans[ i ] 
+  for( i = start; i < MAX_ADMIN_BANS && g_admin_bans[ i ]
     && ( i - start ) < MAX_ADMIN_SHOWBANS; i++ )
   {
     G_DecolorString( g_admin_bans[ i ]->name, n1 );
@@ -2463,12 +4408,12 @@
     G_DecolorString( g_admin_bans[ i ]->name, n1 );
     Com_sprintf( name_fmt, sizeof( name_fmt ), "%%%is",
       ( max_name + strlen( g_admin_bans[ i ]->name ) - strlen( n1 ) ) );
-    Com_sprintf( n1, sizeof( n1 ), name_fmt, g_admin_bans[ i ]->name ); 
+    Com_sprintf( n1, sizeof( n1 ), name_fmt, g_admin_bans[ i ]->name );
 
     G_DecolorString( g_admin_bans[ i ]->banner, n2 );
     Com_sprintf( banner_fmt, sizeof( banner_fmt ), "%%%is",
       ( max_banner + strlen( g_admin_bans[ i ]->banner ) - strlen( n2 ) ) );
-    Com_sprintf( n2, sizeof( n2 ), banner_fmt, g_admin_bans[ i ]->banner ); 
+    Com_sprintf( n2, sizeof( n2 ), banner_fmt, g_admin_bans[ i ]->banner );
 
     ADMBP( va( "%4i %s^7 %-15s %-8s %s^7 %-10s\n     \\__ %s\n",
              ( i + 1 ),
@@ -2495,6 +4440,128 @@
   return qtrue;
 }
 
+qboolean G_admin_showhides( gentity_t *ent, int skiparg )
+{
+  int i, found = 0;
+  int t;
+  char duration[ 32 ];
+  char name_fmt[ 32 ] = { "%s" };
+  char hider_fmt[ 32 ] = { "%s" };
+  int max_name = 1, max_hider = 1;
+  int secs;
+  int start = 0;
+  char skip[ 11 ];
+  char date[ 11 ];
+  char *made;
+  int j;
+  char n1[ MAX_NAME_LENGTH ] = {""};
+  char n2[ MAX_NAME_LENGTH ] = {""};
+
+  t = trap_RealTime( NULL );
+
+  for( i = 0; i < MAX_ADMIN_HIDES && g_admin_hides[ i ]; i++ )
+  {
+    if( g_admin_hides[ i ]->expires != 0
+      && ( g_admin_hides[ i ]->expires - t ) < 1 )
+    {
+      continue;
+    }
+    found++;
+  }
+
+  if( G_SayArgc() < 3 + skiparg )
+  {
+    G_SayArgv( 1 + skiparg, skip, sizeof( skip ) );
+    start = atoi( skip );
+    // showhides 1 means start with hide 0
+    if( start > 0 )
+      start -= 1;
+    else if( start < 0 )
+      start = found + start;
+  }
+
+  if( start >= MAX_ADMIN_HIDES || start < 0 )
+    start = 0;
+
+  for( i = start; i < MAX_ADMIN_HIDES && g_admin_hides[ i ]
+    && ( i - start ) < MAX_ADMIN_SHOWHIDES; i++ )
+  {
+    G_DecolorString( g_admin_hides[ i ]->name, n1 );
+    G_DecolorString( g_admin_hides[ i ]->hider, n2 );
+    if( strlen( n1 ) > max_name )
+    {
+      max_name = strlen( n1 );
+    }
+    if( strlen( n2 ) > max_hider )
+      max_hider = strlen( n2 );
+  }
+
+  if( start >= found )
+  {
+    ADMP( va( "^3!showhides: ^7there are %d active hides\n", found ) );
+    return qfalse;
+  }
+  ADMBP_begin();
+  for( i = start; i < MAX_ADMIN_HIDES && g_admin_hides[ i ]
+    && ( i - start ) < MAX_ADMIN_SHOWHIDES; i++ )
+  {
+    if( g_admin_hides[ i ]->expires != 0
+      && ( g_admin_hides[ i ]->expires - t ) < 1 )
+      continue;
+
+    // only print out the the date part of made
+    date[ 0 ] = '\0';
+    made = g_admin_hides[ i ]->made;
+    for( j = 0; made && *made; j++ )
+    {
+      if( ( j + 1 ) >= sizeof( date ) )
+        break;
+      if( *made == ' ' )
+        break;
+      date[ j ] = *made;
+      date[ j + 1 ] = '\0';
+      made++;
+    }
+
+    secs = ( g_admin_hides[ i ]->expires - t );
+    G_admin_duration( secs, duration, sizeof( duration ) );
+
+    G_DecolorString( g_admin_hides[ i ]->name, n1 );
+    Com_sprintf( name_fmt, sizeof( name_fmt ), "%%%is",
+      ( max_name + strlen( g_admin_hides[ i ]->name ) - strlen( n1 ) ) );
+    Com_sprintf( n1, sizeof( n1 ), name_fmt, g_admin_hides[ i ]->name );
+
+    G_DecolorString( g_admin_hides[ i ]->hider, n2 );
+    Com_sprintf( hider_fmt, sizeof( hider_fmt ), "%%%is",
+      ( max_hider + strlen( g_admin_hides[ i ]->hider ) - strlen( n2 ) ) );
+    Com_sprintf( n2, sizeof( n2 ), hider_fmt, g_admin_hides[ i ]->hider );
+
+    ADMBP( va( "%4i %s^7 %-15s %-8s %s^7 %-10s %s\n     \\__ %s\n",
+             ( i + 1 ),
+             n1,
+             g_admin_hides[ i ]->ip,
+             date,
+             n2,
+             duration,
+             g_admin_hides[ i ]->reason,
+             g_admin_hides[ i ]->hidden ? "  hidden" : "unhidden" ) );
+  }
+
+  ADMBP( va( "^3!showhides:^7 showing hides %d - %d of %d.  ",
+           ( found ) ? ( start + 1 ) : 0,
+           ( ( start + MAX_ADMIN_SHOWHIDES ) > found ) ?
+           found : ( start + MAX_ADMIN_SHOWHIDES ),
+           found ) );
+  if( ( start + MAX_ADMIN_SHOWHIDES ) < found )
+  {
+    ADMBP( va( "run !showhides %d to see more",
+             ( start + MAX_ADMIN_SHOWHIDES + 1 ) ) );
+  }
+  ADMBP( "\n" );
+  ADMBP_end();
+  return qtrue;
+}
+
 qboolean G_admin_help( gentity_t *ent, int skiparg )
 {
   int i;
@@ -2507,7 +4574,7 @@
     ADMBP_begin();
     for( i = 0; i < adminNumCmds; i++ )
     {
-      if( G_admin_permission( ent, g_admin_cmds[ i ].flag[ 0 ] ) )
+      if( G_admin_permission( ent, g_admin_cmds[ i ].flag ) )
       {
         ADMBP( va( "^3!%-12s", g_admin_cmds[ i ].keyword ) );
         j++;
@@ -2516,7 +4583,7 @@
       // show 6 commands per line
       if( j == 6 )
       {
-	ADMBP( "\n" );
+    ADMBP( "\n" );
         j = 0;
       }
     }
@@ -2530,12 +4597,12 @@
       // show 6 commands per line
       if( j == 6 )
       {
-	ADMBP( "\n" );
+    ADMBP( "\n" );
         j = 0;
       }
     }
     if( count )
-	ADMBP( "\n" );
+    ADMBP( "\n" );
     ADMBP( va( "^3!help: ^7%i available commands\n", count ) );
     ADMBP( "run !help [^3command^7] for help with a specific command.\n" );
     ADMBP_end();
@@ -2545,8 +4612,10 @@
   else
   {
     //!help param
+    char flagbuf[ MAX_ADMIN_FLAGS ];
     char param[ MAX_ADMIN_CMD_LEN ];
     char *cmd;
+    int j;
 
     G_SayArgv( 1 + skiparg, param, sizeof( param ) );
     cmd = ( param[0] == '!' ) ? &param[1] : &param[0];
@@ -2555,7 +4624,7 @@
     {
       if( !Q_stricmp( cmd, g_admin_cmds[ i ].keyword ) )
       {
-        if( !G_admin_permission( ent, g_admin_cmds[ i ].flag[ 0 ] ) )
+        if( !G_admin_permission( ent, g_admin_cmds[ i ].flag ) )
         {
           ADMBP( va( "^3!help: ^7you have no permission to use '%s'\n",
                    g_admin_cmds[ i ].keyword ) );
@@ -2567,7 +4636,17 @@
         ADMBP( va( " ^3Function: ^7%s\n", g_admin_cmds[ i ].function ) );
         ADMBP( va( " ^3Syntax: ^7!%s %s\n", g_admin_cmds[ i ].keyword,
                  g_admin_cmds[ i ].syntax ) );
-        ADMBP( va( " ^3Flag: ^7'%c'\n", g_admin_cmds[ i ].flag[ 0 ] ) );
+        Q_strncpyz( flagbuf, g_admin_cmds[ i ].flag, sizeof( flagbuf ) );
+        for( j = 0; j < sizeof( flagbuf ); j++ )
+        {
+            if( flagbuf[ j ] == '^' && j + 3 < sizeof( flagbuf ) )
+            {
+                memmove( &flagbuf[ j ] + 2, &flagbuf[ j ], strlen( flagbuf ) + 1 );
+                flagbuf[ ++j ] = '^';
+                flagbuf[ ++j ] = '7';
+            }
+        }
+        ADMBP( va( " ^3Flag: ^7'%s'\n", flagbuf ) );
         ADMBP_end();
         return qtrue;
       }
@@ -2597,6 +4676,85 @@
   }
 }
 
+qboolean G_admin_crash( gentity_t *ent, int skiparg )
+{
+  int pids[ MAX_CLIENTS ], found;
+  char name[ MAX_NAME_LENGTH ], err[ MAX_STRING_CHARS ];
+  char command[ MAX_ADMIN_CMD_LEN ], *cmd;
+  gentity_t *vic;
+
+  if( G_SayArgc() < 2 + skiparg )
+  {
+    ADMP( "^3!crash: ^7usage: !crash [name|slot#]\n" );
+    return qfalse;
+  }
+  G_SayArgv( skiparg, command, sizeof( command ) );
+  cmd = command;
+  if( cmd && *cmd == '!' )
+    cmd++;
+  G_SayArgv( 1 + skiparg, name, sizeof( name ) );
+  if( ( found = G_ClientNumbersFromString( name, pids, MAX_CLIENTS ) ) != 1 )
+  {
+    G_MatchOnePlayer( pids, found, err, sizeof( err ) );
+    ADMP( va( "^3!crash: ^7%s\n", err ) );
+    return qfalse;
+  }
+  if( !admin_higher( ent, &g_entities[ pids[ 0 ] ] ) )
+  {
+    ADMP( "^3!crash: ^7sorry, but your intended victim has a higher admin"
+        " level than you\n" );
+    return qfalse;
+  }
+  vic = &g_entities[ pids[ 0 ] ];
+  vic->client->pers.crashTime = level.time + 3000;
+  AP( va( "print \"^3!crash: ^7%s^7 crashed %s^7\n\"", ( ent ) ? ent->client->pers.netname : "console", vic->client->pers.netname ) );
+  return qtrue;
+}
+
+qboolean G_admin_warn( gentity_t *ent, int skiparg )
+{//mostly copy and paste with the proper lines altered from !mute and !kick
+
+
+  int pids[ MAX_CLIENTS ];
+  char name[ MAX_NAME_LENGTH ], *reason, err[ MAX_STRING_CHARS ];
+  int minargc;
+  int foundvalasdf;
+  gentity_t *vic;
+
+  minargc = 3 + skiparg;
+  if( G_admin_permission( ent, ADMF_UNACCOUNTABLE ) )
+    minargc = 2 + skiparg;
+
+  if( G_SayArgc() < minargc )
+  {
+    ADMP( "^3!warn: ^7usage: warn [name] [reason]\n" );
+    return qfalse;
+  }
+  G_SayArgv( 1 + skiparg, name, sizeof( name ) );
+  reason = G_SayConcatArgs( 2 + skiparg );
+  if( (foundvalasdf = G_ClientNumbersFromString( name, pids, MAX_CLIENTS )) != 1 )
+  {
+    G_MatchOnePlayer( pids, foundvalasdf, err, sizeof( err ) );
+    ADMP( va( "^3!warn: ^7%s\n", err ) );
+    return qfalse;
+  }
+  if( !admin_higher( ent, &g_entities[ pids[ 0 ] ] ) )
+  {
+    ADMP( "^3!warn: ^7sorry, but your intended victim has a higher admin"
+        " level than you.\n" );
+    return qfalse;
+  }
+
+  vic = &g_entities[ pids[ 0 ] ];
+  //next line is the onscreen warning
+  CPx( pids[ 0 ],va("cp \"^1You have been warned by an administrator.\n ^3Cease immediately or face admin action!\n^1 %s%s\"",(*reason)? "REASON: " : "" ,(*reason)? reason : "") );
+  AP( va( "print \"^3!warn: ^7%s^7 has been warned to cease and desist %s by %s \n\"",
+            vic->client->pers.netname, (*reason) ? reason : "his current activity",
+            ( ent ) ? ent->client->pers.netname : "console" ) );//console announcement
+  ClientUserinfoChanged( pids[ 0 ] );
+  return qtrue;
+}
+
 qboolean G_admin_admintest( gentity_t *ent, int skiparg )
 {
   int i, l = 0;
@@ -2663,18 +4821,25 @@
     cl->readyToExit = 1;
   }
   AP( va( "print \"^3!allready:^7 %s^7 says everyone is READY now\n\"",
-     ( ent ) ? ent->client->pers.netname : "console" ) ); 
+     ( ent ) ? ent->client->pers.netname : "console" ) );
   return qtrue;
 }
 
 qboolean G_admin_cancelvote( gentity_t *ent, int skiparg )
 {
 
-  if(!level.voteTime && !level.teamVoteTime[ 0 ] && !level.teamVoteTime[ 1 ] )
+  if( !level.voteExecuteTime && !level.voteTime && !level.teamVoteTime[ 0 ] && !level.teamVoteTime[ 1 ] )
   {
     ADMP( "^3!cancelvote^7: no vote in progress\n" );
     return qfalse;
   }
+  if( level.voteExecuteTime )
+  {
+    level.voteExecuteTime = level.voteTime = 0;
+    AP( va( "print \"^3!cancelvote: ^7%s^7 canceled the pending vote\n\"",
+            ( ent ) ? ent->client->pers.netname : "console" ) );
+    return qtrue;
+  }
   level.voteNo = level.numConnectedClients;
   level.voteYes = 0;
   CheckVote( );
@@ -2710,6 +4875,24 @@
   return qtrue;
 }
 
+qboolean G_admin_pause( gentity_t *ent, int skiparg )
+{
+    if(!level.paused)
+    {
+        AP( va( "print \"^3!pause: ^7%s^7 paused the game.\n\"", ( ent ) ? ent->client->pers.netname : "console" ) );
+        level.paused = qtrue;
+        trap_SendServerCommand( -1, "cp \"The game has been paused. Please wait.\"" );
+    }
+    else {
+        AP( va( "print \"^3!pause: ^7%s^7 unpaused the game (Paused for %d msec) \n\"", ( ent ) ? ent->client->pers.netname : "console",level.pausedTime ) );
+        trap_SendServerCommand( -1, "cp \"The game has been unpaused!\"" );
+        level.paused = qfalse;
+
+
+        }
+    return qtrue;
+}
+
 qboolean G_admin_spec999( gentity_t *ent, int skiparg )
 {
   int i;
@@ -2728,13 +4911,51 @@
     {
       G_ChangeTeam( vic, PTE_NONE );
       AP( va( "print \"^3!spec999: ^7%s^7 moved ^7%s^7 to spectators\n\"",
-        ( ent ) ? ent->client->pers.netname : "console", 
+        ( ent ) ? ent->client->pers.netname : "console",
         vic->client->pers.netname ) );
     }
   }
   return qtrue;
 }
 
+qboolean G_admin_register(gentity_t *ent, int skiparg )
+{
+  int level = 0;
+  char nothing[ MAX_STRING_CHARS ];
+  char err[ MAX_STRING_CHARS ];
+
+  if( !ent )
+  {
+    ADMP( va( "^3!register: ^7Cannot be run as console\n" ) );
+    return qfalse;
+  }
+
+  level = G_admin_level(ent);
+
+  if( level == 0 )
+   level = 1;
+
+  if( !Q_stricmp( ent->client->pers.guid, "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" ) )
+  {
+    ADMP( va( "^3!register: ^7 You cannot register for name protection until you update your client. Please replace your client executable with the one at http://trem.tjw.org/backport/ and reconnect. Updating your client will also allow you to have faster map downloads.\n" ) );
+    return qfalse;
+  }
+
+  if( !G_admin_name_check( ent, ent->client->pers.netname, err, sizeof( nothing ), 1 ) )
+  {
+    ADMP( va( "^3!register: ^7%s\n", err ) );
+    ADMP( va( "^3!register: ^7Error saving admin\n" ) );
+    return qfalse;
+  }
+
+  trap_SendConsoleCommand( EXEC_APPEND,va( "!setlevel %d %d;",ent - g_entities, level) );
+  ClientUserinfoChanged( ent - g_entities );
+
+  AP( va( "print \"^3!register: ^7%s^7 is now a protected nickname.\n\"", ent->client->pers.netname) );
+
+  return qtrue;
+}
+
 qboolean G_admin_rename( gentity_t *ent, int skiparg )
 {
   int pids[ MAX_CLIENTS ], found;
@@ -2767,7 +4988,7 @@
         " level than you\n" );
     return qfalse;
   }
-  if( !G_admin_name_check( victim, newname, err, sizeof( err ) ) )
+  if( !G_admin_name_check( victim, newname, err, sizeof( err ), 0 ) )
   {
     ADMP( va( "^3!rename: ^7%s\n", err ) );
     return qfalse;
@@ -2780,16 +5001,20 @@
   Info_SetValueForKey( userinfo, "name", newname );
   trap_SetUserinfo( pids[ 0 ], userinfo );
   ClientUserinfoChanged( pids[ 0 ] );
-  AP( va( "print \"^3!rename: ^7%s^7 has been renamed to %s^7 by %s\n\"",
-          oldname,
-          newname,
-          ( ent ) ? ent->client->pers.netname : "console" ) );
+  if( strcmp( oldname, level.clients[ pids[ 0 ] ].pers.netname ) )
+    AP( va( "print \"^3!rename: ^7%s^7 has been renamed to %s^7 by %s\n\"",
+        oldname,
+        level.clients[ pids[ 0 ] ].pers.netname,
+        ( ent ) ? ent->client->pers.netname : "console" ) );
   return qtrue;
 }
 
 qboolean G_admin_restart( gentity_t *ent, int skiparg )
 {
   char layout[ MAX_CVAR_VALUE_STRING ] = { "" };
+  char teampref[ MAX_CVAR_VALUE_STRING ] = { "" };
+  int i;
+  gclient_t *cl;
 
   if( G_SayArgc( ) > 1 + skiparg )
   {
@@ -2798,23 +5023,80 @@
     trap_Cvar_VariableStringBuffer( "mapname", map, sizeof( map ) );
     G_SayArgv( skiparg + 1, layout, sizeof( layout ) );
 
-    if( !Q_stricmp( layout, "*BUILTIN*" ) ||
-      trap_FS_FOpenFile( va( "layouts/%s/%s.dat", map, layout ),
-        NULL, FS_READ ) > 0 )
+  if( Q_stricmp( layout, "keepteams" ) && Q_stricmp( layout, "keepteamslock" ) && Q_stricmp( layout, "switchteams" ) && Q_stricmp( layout, "switchteamslock" ) )
     {
-      trap_Cvar_Set( "g_layouts", layout );
+        if( !Q_stricmp( layout, "*BUILTIN*" ) ||
+          trap_FS_FOpenFile( va( "layouts/%s/%s.dat", map, layout ),
+            NULL, FS_READ ) > 0 )
+        {
+          trap_Cvar_Set( "g_layouts", layout );
+        }
+        else
+        {
+          ADMP( va( "^3!restart: ^7layout '%s' does not exist\n", layout ) );
+          return qfalse;
+        }
     }
     else
     {
-      ADMP( va( "^3!restart: ^7layout '%s' does not exist\n", layout ) );
-      return qfalse;
+ strcpy(layout,"");
+   G_SayArgv( skiparg + 1, teampref, sizeof( teampref ) );
     }
   }
 
+
+
+   if( G_SayArgc( ) > 2 + skiparg )
+   {
+     G_SayArgv( skiparg + 2, teampref, sizeof( teampref ) );
+   }
+
+
+   if( !Q_stricmp( teampref, "keepteams" ) || !Q_stricmp( teampref, "keepteamslock" ) )
+   {
+     for( i = 0; i < g_maxclients.integer; i++ )
+     {
+       cl = level.clients + i;
+       if( cl->pers.connected != CON_CONNECTED )
+         continue;
+
+       if( cl->pers.teamSelection == PTE_NONE )
+         continue;
+
+       cl->sess.restartTeam = cl->pers.teamSelection;
+     }
+   }
+   else if(!Q_stricmp( teampref, "switchteams" ) ||  !Q_stricmp( teampref, "switchteamslock" ))
+   {
+     for( i = 0; i < g_maxclients.integer; i++ )
+     {
+       cl = level.clients + i;
+       if( cl->pers.connected != CON_CONNECTED )
+         continue;
+
+       if( cl->pers.teamSelection == PTE_NONE )
+         continue;
+
+       if( cl->pers.teamSelection == PTE_ALIENS )
+         cl->sess.restartTeam = PTE_HUMANS;
+       else if(cl->pers.teamSelection == PTE_HUMANS )
+    cl->sess.restartTeam = PTE_ALIENS;
+     }
+   }
+
+   if( !Q_stricmp( teampref, "switchteamslock" ) || !Q_stricmp( teampref, "keepteamslock" ) )
+   {
+     trap_Cvar_Set( "g_lockTeamsAtStart", "1" );
+   }
+
   trap_SendConsoleCommand( EXEC_APPEND, "map_restart" );
-  AP( va( "print \"^3!restart: ^7map restarted by %s %s\n\"",
-          ( ent ) ? ent->client->pers.netname : "console",
-          ( layout[ 0 ] ) ? va( "(forcing layout '%s')", layout ) : "" ) );
+   if(teampref[ 0 ])
+     strcpy(teampref,va( "^7(with teams option: '%s^7')", teampref ));
+
+   AP( va( "print \"^3!restart: ^7map restarted by %s %s %s\n\"",
+            ( ent ) ? ent->client->pers.netname : "console",
+           ( layout[ 0 ] ) ? va( "^7(forcing layout '%s^7')", layout ) : "",
+           teampref ) );
   return qtrue;
 }
 
@@ -2850,7 +5132,7 @@
     if( search[0] )
     {
       found = qfalse;
-      for( j = 0; j < MAX_ADMIN_NAMELOG_NAMES && 
+      for( j = 0; j < MAX_ADMIN_NAMELOG_NAMES &&
         g_admin_namelog[ i ]->name[ j ][ 0 ]; j++ )
       {
         G_SanitiseName( g_admin_namelog[ i ]->name[ j ], n2 );
@@ -2864,22 +5146,22 @@
         continue;
     }
     printed++;
-    for( j = 0; j <= 8; j++ )
+    for( j = 0; j < 8; j++ )
       guid_stub[ j ] = g_admin_namelog[ i ]->guid[ j + 24 ];
     guid_stub[ j ] = '\0';
     if( g_admin_namelog[ i ]->slot > -1 )
        ADMBP( "^3" );
-    ADMBP( va( "%-2s (*%s) %15s^7", 
+    ADMBP( va( "%-2s (*%s) %15s^7",
       (g_admin_namelog[ i ]->slot > -1 ) ?
         va( "%d", g_admin_namelog[ i ]->slot ) : "-",
       guid_stub, g_admin_namelog[ i ]->ip ) );
-    for( j = 0; j < MAX_ADMIN_NAMELOG_NAMES && 
+    for( j = 0; j < MAX_ADMIN_NAMELOG_NAMES &&
       g_admin_namelog[ i ]->name[ j ][ 0 ]; j++ )
     {
       ADMBP( va( " '%s^7'", g_admin_namelog[ i ]->name[ j ] ) );
     }
-    ADMBP( "\n" ); 
-  } 
+    ADMBP( "\n" );
+  }
   ADMBP( va( "^3!namelog:^7 %d recent clients found\n", printed ) );
   ADMBP_end();
   return qtrue;
@@ -2930,7 +5212,7 @@
     ( team == PTE_ALIENS ) ? "Alien" : "Human",
     ( ent ) ? ent->client->pers.netname : "console" ) );
   return qtrue;
-} 
+}
 
 qboolean G_admin_unlock( gentity_t *ent, int skiparg )
 {
@@ -2952,7 +5234,7 @@
     ADMP( va( "^3!unlock: ^7invalid team\"%c\"\n", teamName[0] ) );
     return qfalse;
   }
-  
+
   if( team == PTE_ALIENS )
   {
     if( !level.alienTeamLocked )
@@ -2977,8 +5259,984 @@
     ( team == PTE_ALIENS ) ? "Alien" : "Human",
     ( ent ) ? ent->client->pers.netname : "console" ) );
   return qtrue;
-} 
+}
 
+qboolean G_admin_buildlog( gentity_t *ent, int skiparg )
+{
+#define LOG_DISPLAY_LENGTH 10
+  buildHistory_t *ptr;
+  gentity_t *builder = NULL;
+  int skip = 0, start = 0, lastID = -1, firstID = -1, i, len, matchlen = 0;
+  pTeam_t team = PTE_NONE;
+  //char startbuf[ 12 ];
+  char message[ MAX_STRING_CHARS ], *teamchar;
+  char *name, *action, *buildablename, markstring[ MAX_STRING_CHARS ];
+  if( !g_buildLogMaxLength.integer )
+  {
+    ADMP( "^3!buildlog: ^7build logging is disabled" );
+    return qfalse;
+  }
+  if( G_SayArgc( ) >= 2 + skiparg )
+  {
+    for( i = 1; i + skiparg < G_SayArgc( ); i++ )
+    {
+      char argbuf[ 64 ], err[ MAX_STRING_CHARS ];
+      int x = 0, pids[ MAX_CLIENTS ];
+      G_SayArgv( i + skiparg, argbuf, sizeof argbuf );
+      switch( argbuf[ 0 ])
+      {
+        case 'x':
+          x = 1;
+        default:
+          skip = atoi( argbuf + x );
+          start = 0;
+          break;
+        case '#':
+          start = atoi( argbuf + 1 );
+          skip = 0;
+          break;
+        case '-':
+          {
+            int value;
+            if( ( value = G_ClientNumbersFromString( argbuf + 1, pids, MAX_CLIENTS ) ) != 1 )
+            //if( G_ClientNumbersFromString( arg + 1, pids ) != 1 )
+            {
+              G_MatchOnePlayer( pids, value, err, sizeof( err ) );
+              //G_MatchOnePlayer( pids, err, sizeof( err ) );
+              ADMP( va( "^3!buildlog: ^7%s\n", err ));
+              return qfalse;
+            }
+            builder = g_entities + *pids;
+          }
+          break;
+        case 'A':
+        case 'a':
+          team = PTE_ALIENS;
+          break;
+        case 'H':
+        case 'h':
+          team = PTE_HUMANS;
+          break;
+      }
+    }
+  }
+  // !buildlog can be abused, so let everyone know when it is used
+  AP( va( "print \"^3!buildlog: ^7%s^7 requested a log of recent building"
+      " activity\n\"", ( ent ) ? ent->client->pers.netname : "console" ) );
+  len = G_CountBuildLog( ); // also clips the log if too long
+  if( !len )
+  {
+    ADMP( "^3!buildlog: ^7no build log found\n" );
+    return qfalse;
+  }
+  if( start )
+  {
+    // set skip based on start
+    for( ptr = level.buildHistory; ptr && ptr->ID != start;
+        ptr = ptr->next, skip++ );
+    if( !ptr )
+    {
+      ADMP( "^3!buildlog: ^7log ID not found\n" );
+      skip = 0;
+    }
+  }
+  // ensure skip is a useful value
+  if( skip > len - LOG_DISPLAY_LENGTH )
+    skip = len - LOG_DISPLAY_LENGTH;
+  *message = '\0';
+  // skip to start entry
+  for( ptr = level.buildHistory, i = len; ptr && i > len - skip;
+      ptr = ptr->next )
+  {
+    // these checks could perhaps be done more efficiently but they are cheap
+    // in processor time so I'm not worrying
+    if( team != PTE_NONE && team != BG_FindTeamForBuildable( ptr->buildable ) )
+      continue;
+    if( builder && builder != ptr->ent )
+      continue;
+    matchlen++;
+    i--;
+  }
+  for( ; i + LOG_DISPLAY_LENGTH > len - skip && i > 0; i--, ptr = ptr->next )
+  {
+    if( !ptr )
+      break; // run out of log
+    *markstring = '\0'; // reinit markstring
+    // check team
+    if( ( team != PTE_NONE && team != BG_FindTeamForBuildable( ptr->buildable ) )
+        || ( builder && builder != ptr->ent ) )
+    {
+      skip++; // loop an extra time because we skipped one
+      continue;
+    }
+    if( lastID < 0 )
+      lastID = ptr->ID;
+    firstID = ptr->ID;
+    matchlen++;
+    // set name to the ent's current name or last recorded name
+    if( ptr->ent )
+    {
+      if( ptr->ent->client )
+        name = ptr->ent->client->pers.netname;
+      else
+        name = "<world>"; // any non-client action
+    }
+    else
+      name = ptr->name;
+    switch( ptr->fate )
+    {
+      case BF_BUILT:
+        action = "^2built^7 a";
+        break;
+      case BF_DECONNED:
+        action = "^3DECONSTRUCTED^7 a";
+        break;
+      case BF_DESTROYED:
+        action = "destroyed a";
+        break;
+      case BF_TEAMKILLED:
+        action = "^1TEAMKILLED^7 a";
+        break;
+      default:
+        action = "\0"; // erm
+        break;
+    }
+    // handle buildables removed by markdecon
+    if( ptr->marked )
+    {
+      buildHistory_t *mark;
+      int j, markdecon[ BA_NUM_BUILDABLES ], and = 2;
+      char bnames[ 32 ], *article;
+      mark = ptr;
+      // count the number of buildables
+      memset( markdecon, 0, sizeof( markdecon ) );
+      while( ( mark = mark->marked ) )
+        markdecon[ mark->buildable ]++;
+      // reverse order makes grammar easier
+      for( j = BA_NUM_BUILDABLES; j >= 0; j-- )
+      {
+        buildablename = BG_FindHumanNameForBuildable( j );
+        // plural is easy
+        if( markdecon[ j ] > 1 )
+          Com_sprintf( bnames, 32, "%d %ss", markdecon[ j ], buildablename );
+        // use an appropriate article
+        else if( markdecon[ j ] == 1 )
+        {
+          if( BG_FindUniqueTestForBuildable( j ) )
+            article = "the"; // if only one
+          else if( strchr( "aeiouAEIOU", *buildablename ) )
+            article = "an"; // if first char is vowel
+          else
+            article = "a";
+          Com_sprintf( bnames, 32, "%s %s", article, buildablename );
+        }
+        else
+          continue; // none of this buildable
+        // C grammar: x, y, and z
+        // the integer and is 2 initially, the test means it is used on the
+        // second sprintf only, the reverse order makes this second to last
+        // the comma is only printed if there is already some markstring i.e.
+        // not the first time ( which would put it on the end of the string )
+        Com_sprintf( markstring, sizeof( markstring ), "%s%s %s%s", bnames,
+            ( *markstring ) ? "," : "", ( and-- == 1 ) ? "and " : "", markstring );
+      }
+    }
+    buildablename = BG_FindHumanNameForBuildable( ptr->buildable );
+    switch( BG_FindTeamForBuildable( ptr->buildable ) )
+    {
+      case PTE_ALIENS:
+        teamchar = "^1A";
+        break;
+      case PTE_HUMANS:
+        teamchar = "^4H";
+        break;
+      default:
+        teamchar = " "; // space so it lines up neatly
+        break;
+    }
+    // prepend the information to the string as we go back in buildhistory
+    // so the earliest events are at the top
+    Com_sprintf( message, MAX_STRING_CHARS, "%3d %s^7 %s^7 %s%s %s%s%s\n%s",
+        ptr->ID, teamchar, name, action,
+        ( strchr( "aeiouAEIOU", buildablename[ 0 ] ) ) ? "n" : "",
+        buildablename, ( markstring[ 0 ] ) ? ", removing " : "",
+        markstring, message );
+  }
+  for( ; ptr; ptr = ptr->next )
+  {
+    if( builder && builder != ptr->ent )
+      continue;
+    if( team != PTE_NONE && team != BG_FindTeamForBuildable( ptr->buildable ) )
+      continue;
+    matchlen++;
+  }
+  if( matchlen )
+    ADMP( va( "%s^3!buildlog: showing log entries %d - %d of %d\n", message,
+        firstID, lastID, matchlen ) );
+  else
+    ADMP( "^3!buildlog: ^7no log entries match those criteria\n" );
+  return qtrue;
+}
+
+
+qboolean G_admin_say( gentity_t *ent, int skiparg )
+{
+    char *p;
+
+    if( G_SayArgc() < 2 + skiparg )
+    {
+        return qfalse;
+    }
+
+    p = G_SayConcatArgs( 1 + skiparg );
+
+    AP( va( "print \"^7%s^7 said: ^7%s^7\n\"",
+            ( ent ) ? ent->client->pers.netname : "console", p ) );
+
+    return qtrue;
+}
+
+qboolean G_admin_adminsay( gentity_t *ent, int skiparg )
+{
+    char *p;
+
+    if( G_SayArgc() < 2 + skiparg )
+    {
+        return qfalse;
+    }
+
+    p = G_SayConcatArgs( 1 + skiparg );
+
+    AP( va( "print \"^7%s^7\n\"",
+            p ) );
+
+    return qtrue;
+}
+
+qboolean G_admin_bigsay( gentity_t *ent, int skiparg )
+{
+    char *p;
+
+    if( G_SayArgc() < 2 + skiparg )
+    {
+        return qfalse;
+    }
+
+    p = G_SayConcatArgs( 1 + skiparg );
+
+//    AP( va( "cp \"^7%s^7\n\"",
+//            p ) );
+    G_ClientCP(NULL, p, NULL, 0);
+
+  AP( va( "print \"^3!bigsay: ^7%s^7 said: %s^7\n\"",
+    ( ent ) ? ent->client->pers.netname : "console", p ) );
+
+    return qtrue;
+}
+
+qboolean G_admin_revert( gentity_t *ent, int skiparg )
+{
+  int i = 0, j = 0, repeat = 1, ID = 0, len, matches = 0;
+  pTeam_t team = PTE_NONE;
+  qboolean force = qfalse, reached = qfalse;
+  gentity_t *builder = NULL, *targ;
+  buildHistory_t *ptr, *tmp, *mark, *prev;
+  vec3_t dist;
+  char argbuf[ 64 ], *name, *bname, *action, *article;
+  len = G_CountBuildLog( );
+  if( !len )
+  {
+    ADMP( "^3!revert: ^7no build log found\n" );
+    return qfalse;
+  }
+  if( G_SayArgc( ) < 2 + skiparg )
+  {
+    ADMP( "^3!revert: ^7usage: !revert (^5xnum^7) (^5#ID^7) (^5-name|num^7) (^5a|h^7)\n" );
+    return qfalse;
+  }
+  for( i = 1; i + skiparg < G_SayArgc( ); i++ )
+  {
+    char arg[ 64 ], err[ MAX_STRING_CHARS ];
+    int pids[ MAX_CLIENTS ];
+    G_SayArgv( i + skiparg, arg, sizeof arg );
+    switch( arg[ 0 ])
+    {
+      case 'x':
+        repeat = atoi( arg + 1 );
+        break;
+      case '#':
+        ID = atoi( arg + 1 );
+        break;
+      case '-':
+        {
+          int value;
+          if( ( value = G_ClientNumbersFromString( arg + 1, pids, MAX_CLIENTS ) ) != 1 )
+          //if( G_ClientNumbersFromString( arg + 1, pids ) != 1 )
+          {
+            G_MatchOnePlayer( pids, value, err, sizeof( err ) );
+            //G_MatchOnePlayer( pids, err, sizeof( err ) );
+            ADMP( va( "^3!revert: ^7%s\n", err ));
+            return qfalse;
+          }
+          builder = g_entities + *pids;
+        }
+        break;
+      case 'A':
+      case 'a':
+        team = PTE_ALIENS;
+        break;
+      case 'H':
+      case 'h':
+        team = PTE_HUMANS;
+        break;
+      case '!':
+        force = qtrue;
+        break;
+      default:
+        ADMP( "^3!revert: ^7usage: !revert (^5xnum^7) (^5#ID^7) (^5-name|num^7) (^5a|h^7)\n" );
+        return qfalse;
+    }
+  }
+  if( repeat > 25 )
+  {
+    ADMP( "^3!revert: ^7to avoid flooding, can only revert 25 builds at a time\n" );
+    repeat = 25;
+  }
+  for( i = 0, ptr = prev = level.buildHistory; repeat > 0; repeat--, j = 0 )
+  {
+    if( !ptr )
+      break; // run out of bhist
+    if( !reached && ID )
+    {
+      if( ptr->ID == ID )
+        reached = qtrue;
+      else
+      {
+        prev = ptr;
+        ptr = ptr->next;
+        repeat++;
+        continue;
+      }
+    }
+    if( ( team != PTE_NONE &&
+        team != BG_FindTeamForBuildable( ptr->buildable ) ) ||
+        ( builder && builder != ptr->ent ))
+    {
+      // team doesn't match, so skip this ptr and reset prev
+      prev = ptr;
+      ptr = ptr->next;
+      // we don't want to count this one so counteract the decrement by the for
+      repeat++;
+      continue;
+    }
+    // get the ent's current or last recorded name
+    if( ptr->ent )
+    {
+      if( ptr->ent->client )
+        name = ptr->ent->client->pers.netname;
+      else
+        name = "<world>"; // non-client actions
+    }
+    else
+      name = ptr->name;
+    bname = BG_FindHumanNameForBuildable( ptr->buildable );
+    action = "";
+    switch( ptr->fate )
+    {
+      case BF_BUILT:
+        action = "build";
+        for( j = MAX_CLIENTS, targ = g_entities + j;
+            j < level.num_entities; j++, targ++ )
+        {
+          // easy checks first to save time
+          if( targ->s.eType != ET_BUILDABLE )
+            continue;
+          if( targ->s.modelindex != ptr->buildable )
+            continue;
+          VectorSubtract( targ->s.pos.trBase, ptr->origin, dist );
+#define FIND_BUILDABLE_TOLERANCE 5
+          if( VectorLength( dist ) > FIND_BUILDABLE_TOLERANCE )
+            continue; // number is somewhat arbitrary, watch for false pos/neg
+          // if we didn't continue then it's this one, unlink it but we can't
+          // free it yet, because the markdecon buildables might not place
+          trap_UnlinkEntity( targ );
+          break;
+        }
+        // if there are marked buildables to replace, and we aren't overriding
+        // space check, check they can fit before acting
+        if( ptr->marked && !force && !level.oc )
+        {
+          for( mark = ptr->marked; mark; mark = mark->marked )
+            if( !G_RevertCanFit( mark ) )
+            {
+              trap_LinkEntity( targ ); // put it back, we failed
+              // scariest sprintf ever:
+              Com_sprintf( argbuf, sizeof argbuf, "%s%s%s%s%s%s%s!",
+                  ( repeat > 1 ) ? "x" : "", ( repeat > 1 ) ? va( "%d ", repeat ) : "",
+                  ( ID ) ? "#" : "", ( ID ) ? va( "%d ", ptr->ID ) : "",
+                  ( builder ) ? "-" : "", ( builder ) ? va( "%d ", builder - g_entities ) : "",
+                  ( team == PTE_ALIENS ) ? "a " : ( team == PTE_HUMANS ) ? "h " : "" );
+              ADMP( va( "^3!revert: ^7revert aborted: reverting this %s would conflict with "
+                  "another buildable, use ^3!revert %s ^7to override\n", action, argbuf ) );
+              return qfalse;
+            }
+        }
+        // if we haven't returned yet then we're good to go, free it
+        G_FreeEntity( targ );
+        // put the marked buildables back and mark them again
+        if( ptr->marked ) // there may be a more efficient way of doing this
+        {
+          for( mark = ptr->marked; mark; mark = mark->marked )
+            G_SpawnRevertedBuildable( mark, qtrue );
+        }
+        break;
+      case BF_DECONNED:
+        action = "deconstruction";
+      case BF_DESTROYED:
+      case BF_TEAMKILLED:
+        if( !action[ 0 ] )
+          action = "destruction";
+        // if we're not overriding and the replacement can't fit, as before
+        if( !force && !G_RevertCanFit( ptr ) && !level.oc )
+        {
+          Com_sprintf( argbuf, sizeof argbuf, "%s%s%s%s%s%s%s!",
+              ( repeat > 1 ) ? "x" : "", ( repeat > 1 ) ? va( "%d ", repeat ) : "",
+              ( ID ) ? "#" : "", ( ID ) ? va( "%d ", ptr->ID ) : "",
+              ( builder ) ? "-" : "", ( builder ) ? va( "%d ", builder - g_entities ) : "",
+              ( team == PTE_ALIENS ) ? "a " : ( team == PTE_HUMANS ) ? "h " : "" );
+          ADMP( va( "^3!revert: ^7revert aborted: reverting this %s would "
+              "conflict with another buildable, use ^3!revert %s ^7to override\n",
+              action, argbuf ) );
+          return qfalse;
+        }
+        // else replace it but don't mark it ( it might have been marked before
+        // but it isn't that important )
+        G_SpawnRevertedBuildable( ptr, qfalse );
+        break;
+      default:
+        // if this happens something has gone wrong
+        ADMP( "^3!revert: ^7incomplete or corrupted build log entry\n" );
+        /* quarantine and dispose of the log, it's dangerous
+        trap_Cvar_Set( "g_buildLogMaxLength", "0" );
+        G_CountBuildLog( );
+        */
+        return qfalse;
+    }
+    if( j == level.num_entities )
+    {
+      ADMP( va( "^3!revert: ^7could not find logged buildable #%d\n", ptr->ID ));
+      prev = ptr;
+      ptr = ptr->next;
+      continue;
+    }
+    // this is similar to the buildlog stuff
+    if( BG_FindUniqueTestForBuildable( ptr->buildable ) )
+      article = "the";
+    else if( strchr( "aeiouAEIOU", *bname ) )
+      article = "an";
+    else
+      article = "a";
+    AP( va( "print \"%s^7 reverted %s^7'%s %s of %s %s\n\"",
+        ( ent ) ? ent->client->pers.netname : "console",
+        name, strchr( "Ss", name[ strlen( name ) - 1 ] ) ? "" : "s",
+        action, article, bname ) );
+    matches++;
+    // remove the reverted entry
+    // ptr moves on, prev just readjusts ->next unless it is about to be
+    // freed, in which case it is forced to move on too
+    tmp = ptr;
+    if( ptr == level.buildHistory )
+      prev = level.buildHistory = ptr = ptr->next;
+    else
+      prev->next = ptr = ptr->next;
+    G_Free( tmp );
+  }
+  if( ID && !reached )
+    ADMP( "^3!revert: ^7no buildlog entry with that ID\n" );
+  else if( matches > 0 )
+  {
+    ADMP( va( "^3!revert: ^7reverted %d buildlog events\n", matches ) );
+    return qtrue;
+  }
+  else
+    ADMP( "^3!revert: ^7no buildlog entries match those criteria\n" );
+  return qfalse;
+}
+
+void G_Unescape( char *input, char *output, int len );
+qboolean G_StringReplaceCvars( char *input, char *output, int len );
+
+qboolean G_admin_info( gentity_t *ent, int skiparg )
+{/*
+  fileHandle_t infoFile;
+  int length, i;
+#define MESSAGEBUF_LEN 1000
+  char *message, filename[ MAX_OSPATH ], messagebuf[ MESSAGEBUF_LEN ];
+  for( i = 0; i < MESSAGEBUF_LEN; i++ )
+    messagebuf[ i ] = '\0';
+  if( G_SayArgc() == 2 + skiparg )
+    G_SayArgv( 1 + skiparg, filename, sizeof( filename ) );
+  else if( G_SayArgc() == 1 + skiparg )
+    Q_strncpyz( filename, "default", sizeof( filename ) );
+  else
+  {
+    ADMP( "^3!info: ^7usage: ^3!info ^7(^5subject^7)\n" );
+    return qfalse;
+  }
+  Com_sprintf( filename, sizeof( filename ), "info/info-%s.txt", filename );
+  length = trap_FS_FOpenFile( filename, &infoFile, FS_READ );
+  message = G_Alloc( length * 2 + 1 );
+  if( length <= 0 || !infoFile )
+  {
+    G_Free( message );
+    trap_FS_FCloseFile( infoFile );
+    ADMP( "^3!info: ^7no relevant information is available\n" );
+    return qfalse;
+  }
+  else
+  {
+    int i;
+    char *cr;
+    trap_FS_Read( message, length, infoFile );
+    *( message + length ) = '\0';
+    trap_FS_FCloseFile( infoFile );
+    // strip carriage returns for windows platforms
+    while( ( cr = strchr( message, '\r' ) ) )
+      memmove( cr, cr + 1, strlen( cr + 1 ) + 1 );
+#define MAX_INFO_PARSE_LOOPS 100
+    for( i = 0; i < MAX_INFO_PARSE_LOOPS &&
+        G_StringReplaceCvars( message, message, sizeof( message ) ); i++ );
+    G_Unescape( message, message, sizeof( message ) );
+    if( i >= MAX_INFO_PARSE_LOOPS )
+      G_Printf( S_COLOR_YELLOW "WARNING: %s exceeds MAX_INFO_PARSE_LOOPS\n", filename );
+    i = 0;
+    while( i < length && *( message + i ) )
+    {
+      if( i + 1 % ( MESSAGEBUF_LEN ) )
+      {
+        *( messagebuf + ( i % MESSAGEBUF_LEN ) ) = *( message + i );
+      }
+      else
+      {
+        *( messagebuf + ( MESSAGEBUF_LEN - 1 ) ) = '\0';
+        ADMP( va( "%s", messagebuf ) );
+      }
+      i++;
+      ADMP( va( "messagebuf: %s\nmessage[ 0 ]: %d\nmessage[ 1 ]: %d\nmessage[ 2 ]: %d\nmessage[ 3 ]: %d\nmessage[ 4 ]: %d\nmessage[ 5 ]: %d\nmessage0: %d\nmessage1: %d\nmessage2: %d\nmessage3: %d\n", messagebuf, message[ 0 ], message[ 1 ], message[ 2 ], message[ 3 ], message[ 4 ], message[ 5 ], *(message+0), *(message+1), *(message+2), *(message+3) ) );
+    }
+    G_Free( message );
+    *( messagebuf + i ) = '\0';
+    ADMP( va( "%s", messagebuf ) );
+    return qtrue;
+  }
+*/
+
+
+
+
+  fileHandle_t f;
+  int  len, i=0;
+  char *info, *infoPtr, *cr;
+  char fileName[ MAX_OSPATH ];
+  char line[ MAX_STRING_CHARS ], linebuf[ MAX_STRING_CHARS ];
+
+  if( g_floodMinTime.integer && ent && ent->client )
+    if ( G_Flood_Limited( ent ) )
+    {
+      trap_SendServerCommand( ent-g_entities, "print \"Your chat is flood-limited; wait before chatting again\n\"" );
+      return qfalse;
+    }
+
+  if( G_SayArgc() == 2 + skiparg )
+    G_SayArgv( 1 + skiparg, fileName, MAX_OSPATH );
+  else if( G_SayArgc() == 1 + skiparg )
+    strcpy( fileName, "default" );
+  else
+  {
+    ADMP( "^3!info: ^7usage: ^3!info ^7(^5subject^7)\n" );
+    return qfalse;
+  }
+  Com_sprintf( fileName, sizeof( fileName ), "info/info-%s.txt", fileName );
+
+  len = trap_FS_FOpenFile( fileName, &f, FS_READ );
+  if( len < 0 )
+  {
+    trap_FS_FCloseFile( f );
+    ADMP( "^3!info: ^7no relevant information is available\n" );
+    return qfalse;
+  }
+  info = G_Alloc( len + 1 );
+  infoPtr = info;
+  trap_FS_Read( info, len, f );
+  *( info + len ) = '\0';
+  trap_FS_FCloseFile( f );
+
+  // strip carriage returns for windows platforms
+  while( ( cr = strchr( info, '\r' ) ) )
+    memmove( cr, cr + 1, strlen( cr + 1 ) + 1 );
+#define MAX_INFO_PARSE_LOOPS 100
+  for( i = 0; i < MAX_INFO_PARSE_LOOPS && G_StringReplaceCvars( info, info, len ); i++ );
+  G_Unescape( info, info, len );
+
+  strcpy( linebuf, "" );
+
+  while( *info )
+  {
+    if( i >= sizeof( line ) - 1 )
+    {
+      G_Free( info );
+      G_Printf( S_COLOR_RED "ERROR: line overflow in %s before \"%s\"\n",
+       fileName, line );
+      return qfalse;
+    }
+    line[ i++ ] = *info;
+    line[ i ] = '\0';
+    if( *info == '\n' )
+    {
+      i = 0;
+//      if( *( info - 1 ) != '\n' )  // nice formatting - implementation somewhat hackish
+      if( qtrue )
+      {
+        if( strlen( linebuf ) + strlen( line ) < MAX_STRING_CHARS - 12 )  // send 24 lines or up to max_string_chars at a time
+        {
+          strcat( linebuf, line );
+        }
+        else
+        {
+          trap_SendServerCommand( ent - g_entities, va( "print \"%s\n\"", linebuf ) );
+          strcpy( linebuf, line );
+        }
+      }
+    }
+    info++;
+  }
+
+  info = infoPtr;
+
+  if( linebuf[0] )
+    trap_SendServerCommand( ent - g_entities, va( "print \"%s\n\"", linebuf ) );
+
+  G_Free( info );
+  return qtrue;
+}
+
+void G_Unescape( char *input, char *output, int len )
+{
+  // \n -> newline, \%c -> %c
+  // output is terminated at output[len - 1]
+  // it's OK for input to equal output, because our position in input is always
+  // equal or greater than our position in output
+  // however, if output is later in the same string as input, a crash is pretty
+  // much inevitable
+  int i, j;
+  for( i = j = 0; input[i] && j + 1 < len; i++, j++ )
+  {
+    if( input[i] == '\\' )
+    {
+      if( !input[++i] )
+      {
+        output[j] = '\0';
+        return;
+      }
+      else if( input[i] == 'n' )
+        output[j] = '\n';
+      else
+        output[j] = input[i];
+    }
+    else
+      output[j] = input[i];
+  }
+  output[j] = '\0';
+}
+
+qboolean G_StringReplaceCvars( char *input, char *output, int len )
+{
+  int i, outNum = 0;
+  char cvarName[ 64 ], cvarValue[ MAX_CVAR_VALUE_STRING ];
+  char *outputBuffer;
+  qboolean doneAnything = qfalse;
+  if( len <= 0 )
+    return qfalse;
+  // use our own internal buffer in case output == input
+  outputBuffer = G_Alloc( len );
+  len -= 1; // fit in a terminator
+  while( *input && outNum < len )
+  {
+    if( *input == '\\' && input[1] && outNum < len - 1 )
+    {
+      outputBuffer[ outNum++ ] = *input++;
+      outputBuffer[ outNum++ ] = *input++;
+    }
+    else if( *input == '$' )
+    {
+      doneAnything = qtrue;
+      input++;
+      if( *input == '{' )
+        input++;
+      for( i = 0; *input && ( isalnum( *input ) || *input == '_' ) &&
+          i < 63; i++ )
+        cvarName[ i ] = *input++;
+      cvarName[ i ] = '\0';
+      if( *input == '}' )
+        input++;
+      trap_Cvar_VariableStringBuffer( cvarName, cvarValue, sizeof( cvarValue ) );
+      if( cvarValue[ 0 ] )
+      {
+        for( i = 0; cvarValue[ i ] && outNum < len; i++ )
+          outputBuffer[ outNum++ ] = cvarValue[ i ];
+      }
+    }
+    else
+      outputBuffer[ outNum++ ] = *input++;
+  }
+  outputBuffer[ outNum ] = '\0';
+  Q_strncpyz( output, outputBuffer, len );
+  G_Free( outputBuffer );
+  return doneAnything;
+}
+
+qboolean G_admin_endscrim( gentity_t *ent, int skiparg )
+{
+  if( !level.oc )
+  {
+    ADMP( va( "Can only be used during an obstacle course\n" ) );
+    return qfalse;
+  }
+
+  if( level.ocScrimState <= OC_STATE_NONE )
+  {
+    ADMP( va( "Can only be used during an OC scrim\n" ) );
+    return qfalse;
+  }
+
+  G_OCScrimEnd( );
+
+  AP( va( "print \"^3!endscrim: ^7%s^7 ended the scrim^7\n\"", ( ent ) ? ent->client->pers.netname : "console" ) );
+  return qtrue;
+}
+
+qboolean G_admin_startscrim( gentity_t *ent, int skiparg )
+{
+  char win[ 7 ];
+
+  if( !level.oc )
+  {
+    ADMP( va( "Can only be used during an obstacle course\n" ) );
+    return qfalse;
+  }
+
+  if( G_SayArgc() < 2 + skiparg )
+  {
+    ADMP( "^3!startscrim: ^7usage: !startscrim [m/a] for all medis / armoury\n" );
+    return qfalse;
+  }
+  G_SayArgv( 1 + skiparg, win, sizeof( win ) );
+
+  if( !win[0] || !( win[0] == 'm' || win[0] == 'a' ) )
+  {
+    ADMP( "^3!startscrim: ^7usage: !startscrim [m/a] for all medis / armoury\n" );
+    return qfalse;
+  }
+
+  if( win[0] == 'a' )
+    level.ocScrimMode = OC_MODE_ARM;
+  else
+    level.ocScrimMode = OC_MODE_MEDI;
+
+  if( level.ocScrimMode == OC_MODE_ARM && level.totalArmouries <= 0 )
+  {
+    ADMP( "^3!startscrim: ^7there are no armouries for an arm scrim\n" );
+    return qfalse;
+  }
+  if( level.ocScrimMode == OC_MODE_MEDI && level.totalMedistations <= 0 )
+  {
+    ADMP( "^3!startscrim: ^7there are no medis for a medi scrim\n" );
+    return qfalse;
+  }
+
+  level.ocStartTime = level.time;
+  level.ocScrimState = OC_STATE_PREP;
+
+  AP( va( "print \"^3!startscrim: ^7%s^7 started the oc scrim - first team to use\n%s^7.^7\n\"", ( ent ) ? ent->client->pers.netname : "console", ( ( level.ocScrimMode == OC_MODE_ARM ) ? ( level.totalArmouries == 1 || G_TestLayoutFlag( level.layout, OCFL_ONEARM ) ? "the ^3armoury^7" : "every ^3armoury^7" ) : ( level.totalMedistations == 1 ? "the ^3medical station^7" : "every ^3medical station^7" ) ) ) );
+  return qtrue;
+}
+
+qboolean G_admin_designate( gentity_t *ent, int skiparg )
+{
+  int asdfval=0;
+  int pids[ MAX_CLIENTS ];
+  char name[ MAX_NAME_LENGTH ], err[ MAX_STRING_CHARS ];
+  char command[ MAX_ADMIN_CMD_LEN ], *cmd;
+  gentity_t *vic;
+
+  if( G_SayArgc() < 2 + skiparg )
+  {
+    ADMP( "^3!designate: ^7usage: designate [name|slot#]\n" );
+    return qfalse;
+  }
+  G_SayArgv( skiparg, command, sizeof( command ) );
+  cmd = command;
+  if( cmd && *cmd == '!' )
+    cmd++;
+  G_SayArgv( 1 + skiparg, name, sizeof( name ) );
+  if( (asdfval=G_ClientNumbersFromString( name, pids, MAX_CLIENTS ) )!= 1 )
+  {
+    G_MatchOnePlayer( pids, asdfval, err, sizeof( err ) );
+    ADMP( va( "^3!designate: ^7%s\n", err ) );
+    return qfalse;
+  }
+  if( !admin_higher( ent, &g_entities[ pids[ 0 ] ] ) &&
+    !Q_stricmp( cmd, "undesignate" ) )
+  {
+    ADMP( "^3!mute: ^7sorry, but your intended victim has a higher admin"
+        " level than you\n" );
+    return qfalse;
+  }
+  vic = &g_entities[ pids[ 0 ] ];
+  if( vic->client->pers.designatedBuilder == qtrue )
+  {
+    if( !Q_stricmp( cmd, "designate" ) )
+    {
+      ADMP( "^3!designate: ^7player is already designated builder\n" );
+      return qtrue;
+    }
+    vic->client->pers.designatedBuilder = qfalse;
+    CPx( pids[ 0 ], "cp \"^1Your designation has been revoked\"" );
+    AP( va(
+      "print \"^3!designate: ^7%s^7's designation has been revoked by %s\n\"",
+       vic->client->pers.netname,
+       ( ent ) ? ent->client->pers.netname : "console" ) );
+    G_CheckDBProtection( );
+  }
+  else
+  {
+    if( !Q_stricmp( cmd, "undesignate" ) )
+    {
+      ADMP( "^3!undesignate: ^7player is not currently designated builder\n" );
+      return qtrue;
+    }
+    vic->client->pers.designatedBuilder = qtrue;
+    CPx( pids[ 0 ], "cp \"^1You've been designated\"" );
+    AP( va( "print \"^3!designate: ^7%s^7 has been designated by ^7%s\n\"",
+      vic->client->pers.netname,
+      ( ent ) ? ent->client->pers.netname : "console" ) );
+  }
+  ClientUserinfoChanged( pids[ 0 ] );
+  return qtrue;
+}
+
+qboolean G_admin_putmespec( gentity_t *ent, int skiparg )
+{
+  if( !ent )
+  {
+    ADMP( "!specme: sorry, but console isn't allowed on the spectators team\n");
+    return qfalse;
+  }
+
+  if(ent->client->pers.teamSelection == PTE_NONE)
+    return qfalse;
+
+    //guard against build timer exploit
+  if( ent->client->pers.teamSelection != PTE_NONE &&
+     ( ent->client->ps.stats[ STAT_PCLASS ] == PCL_ALIEN_BUILDER0 ||
+       ent->client->ps.stats[ STAT_PCLASS ] == PCL_ALIEN_BUILDER0_UPG ||
+       BG_InventoryContainsWeapon( WP_HBUILD, ent->client->ps.stats ) ||
+       BG_InventoryContainsWeapon( WP_HBUILD2, ent->client->ps.stats ) ) &&
+      ent->client->ps.stats[ STAT_MISC ] > 0 )
+  {
+    ADMP("!specme: You cannot leave your team until the build timer expires");
+    return qfalse;
+  }
+
+  G_ChangeTeam( ent, PTE_NONE );
+  AP( va("print \"^3!specme: ^7%s^7 decided to join the spectators\n\"", ent->client->pers.netname ) );
+  return qtrue;
+}
+
+qboolean G_admin_override( gentity_t *ent, int skiparg )
+{ //this is all very similar to denybuild,
+  //it performs an essentially identical function
+  int pids[ MAX_CLIENTS ], found;
+  char name[ MAX_NAME_LENGTH ], err[ MAX_STRING_CHARS ];
+  char command[ MAX_ADMIN_CMD_LEN ], *cmd;
+  gentity_t *vic;
+
+  G_SayArgv( skiparg, command, sizeof( command ) );
+  cmd = command;
+  if( cmd && *cmd == '!' )
+    cmd++;
+
+  if ( ent && !g_cheats.integer && !g_allowAdminCheats.integer )
+  {
+    ADMP( va( "^3!%s: ^7Cheats are not enabled on this server\n", cmd ) );
+    return qfalse;
+  }
+
+  if( G_SayArgc() < 2 + skiparg )
+  {
+    ADMP( va( "^3!%s: ^7usage: !%s [name|slot#]\n", cmd, cmd ) );
+    return qfalse;
+  }
+  G_SayArgv( 1 + skiparg, name, sizeof( name ) );
+  if( ( found = G_ClientNumbersFromString( name, pids, MAX_CLIENTS ) ) != 1 )
+  {
+    G_MatchOnePlayer( pids, found, err, sizeof( err ) );
+    ADMP( va( "^3!%s: ^7%s\n", cmd, err ) );
+    return qfalse;
+  }
+  if( !admin_higher( ent, &g_entities[ pids[ 0 ] ] ) )
+  {
+    ADMP( va( "^3!%s: ^7sorry, but your intended victim has a higher admin"
+              " level than you\n", cmd ) );
+    return qfalse;
+  }
+  vic = &g_entities[ pids[ 0 ] ];
+  if( !vic->client->pers.override )
+  {
+    if( !Q_stricmp( cmd, "cheat-do" ) )
+    {
+      ADMP( "^3!cheat-do: ^7player already has no overriding rights\n" );
+      return qtrue;
+    }
+    vic->client->pers.hasCheated = 1;
+    vic->client->pers.override = qtrue;
+    vic->client->pers.noAuO = 1;
+    CPx( pids[ 0 ], "cp \"^1You've regained your overriding rights\"" );
+    if (ent)
+    AP( va(
+      "print \"^3!cheat-ao: ^7overriding rights for ^7%s^7 restored by %s\n\"",
+      vic->client->pers.netname,
+      ( ent ) ? ent->client->pers.netname : "console" ) );
+  }
+  else
+  {
+    if( !Q_stricmp( cmd, "cheat-ao" ) )
+    {
+      ADMP( "^3!cheat-ao: ^7player already has overriding rights\n" );
+      return qtrue;
+    }
+    vic->client->pers.hasCheated = 1;
+    vic->client->pers.override = qfalse;
+    vic->client->pers.noAuO = 1;
+    if( vic->client->pers.denyBuild )
+    {
+      vic->client->ps.stats[ STAT_BUILDABLE ] = BA_NONE;
+      if( vic->client->ps.stats[ STAT_PCLASS ]== PCL_ALIEN_BUILDER0 || vic->client->ps.stats[ STAT_PCLASS ] == PCL_ALIEN_BUILDER0_UPG )
+      {
+        vic->suicideTime = level.time + 1000;
+      }
+    }
+    CPx( pids[ 0 ], "cp \"^1You've lost your overriding rights\"" );
+    if( ent )
+    AP( va(
+      "print \"^3!cheat-do: ^7overriding rights for ^7%s^7 revoked by ^7%s\n\"",
+      vic->client->pers.netname,
+      ( ent ) ? ent->client->pers.netname : "console" ) );
+  }
+  ClientUserinfoChanged( pids[ 0 ] );
+  return qtrue;
+}
+
 /*
 ================
  G_admin_print
@@ -3041,6 +6299,11 @@
     G_Free( g_admin_bans[ i ] );
     g_admin_bans[ i ] = NULL;
   }
+  for( i = 0; i < MAX_ADMIN_HIDES && g_admin_hides[ i ]; i++ )
+  {
+    G_Free( g_admin_hides[ i ] );
+    g_admin_hides[ i ] = NULL;
+  }
   for( i = 0; i < MAX_ADMIN_COMMANDS && g_admin_commands[ i ]; i++ )
   {
     G_Free( g_admin_commands[ i ] );
Index: src/game/bg_pmove.c
===================================================================
--- src/game/bg_pmove.c	(revision 1055)
+++ src/game/bg_pmove.c	(working copy)
@@ -510,12 +510,19 @@
       pm->ps->weapon != WP_ALEVEL3_UPG )
     return qfalse;
 
-  if( pm->cmd.buttons & BUTTON_ATTACK2 )
+  // we were pouncing, but we've landed
+  if( pm->ps->groundEntityNum != ENTITYNUM_NONE
+    && ( pm->ps->pm_flags & PMF_CHARGE ) )
   {
+    pm->ps->weaponTime += LEVEL3_POUNCE_TIME;
     pm->ps->pm_flags &= ~PMF_CHARGE;
-    return qfalse;
   }
 
+  // we're building up for a pounce
+  if( pm->cmd.buttons & BUTTON_ATTACK2 )
+    return qfalse;
+
+  // already a pounce in progress
   if( pm->ps->pm_flags & PMF_CHARGE )
     return qfalse;
 
@@ -1350,7 +1357,7 @@
 
   VectorMA( pm->ps->origin, 1.0f, forward, end );
 
-  pm->trace( &trace, pm->ps->origin, pm->mins, pm->maxs, end, pm->ps->clientNum, MASK_PLAYERSOLID );
+  pm->trace( &trace, pm->ps->origin, pm->mins, pm->maxs, end, pm->ps->clientNum, MASK_OCSOLID );
 
   if( ( trace.fraction < 1.0f ) && ( trace.surfaceFlags & SURF_LADDER ) )
     pml.ladder = qtrue;
@@ -2659,7 +2666,7 @@
 static void PM_Weapon( void )
 {
   int           addTime = 200; //default addTime - should never be used
-  int           maxClips;
+  int           ammo, clips, maxClips;
   qboolean      attack1 = qfalse;
   qboolean      attack2 = qfalse;
   qboolean      attack3 = qfalse;
@@ -2685,7 +2692,15 @@
     return;
   }
 
-  // make weapon function
+
+  // no bite during pounce
+  if( ( pm->ps->weapon == WP_ALEVEL3 || pm->ps->weapon == WP_ALEVEL3_UPG )
+    && ( pm->cmd.buttons & BUTTON_ATTACK )
+    && ( pm->ps->pm_flags & PMF_CHARGE ) )
+  {
+    return;
+  }
+
   if( pm->ps->weaponTime > 0 )
     pm->ps->weaponTime -= pml.msec;
 
@@ -2757,10 +2772,11 @@
 
   // start the animation even if out of ammo
 
+  BG_UnpackAmmoArray( pm->ps->weapon, pm->ps->ammo, pm->ps->misc, &ammo, &clips );
   BG_FindAmmoForWeapon( pm->ps->weapon, NULL, &maxClips );
 
   // check for out of ammo
-  if( !pm->ps->ammo && !pm->ps->clips && !BG_FindInfinteAmmoForWeapon( pm->ps->weapon ) )
+  if( !ammo && !clips && !BG_FindInfinteAmmoForWeapon( pm->ps->weapon ) )
   {
     PM_AddEvent( EV_NOAMMO );
     pm->ps->weaponTime += 200;
@@ -2776,14 +2792,16 @@
   {
     if( maxClips > 0 )
     {
-      pm->ps->clips--;
-      BG_FindAmmoForWeapon( pm->ps->weapon, &pm->ps->ammo, NULL );
+      clips--;
+      BG_FindAmmoForWeapon( pm->ps->weapon, &ammo, NULL );
     }
 
     if( BG_FindUsesEnergyForWeapon( pm->ps->weapon ) &&
         BG_InventoryContainsUpgrade( UP_BATTPACK, pm->ps->stats ) )
-      pm->ps->ammo = (int)( (float)pm->ps->ammo * BATTPACK_MODIFIER );
+      ammo = (int)( (float)ammo * BATTPACK_MODIFIER );
 
+    BG_PackAmmoArray( pm->ps->weapon, pm->ps->ammo, pm->ps->misc, ammo, clips );
+
     //allow some time for the weapon to be raised
     pm->ps->weaponstate = WEAPON_RAISING;
     PM_StartTorsoAnim( TORSO_RAISE );
@@ -2792,7 +2810,7 @@
   }
 
   // check for end of clip
-  if( ( !pm->ps->ammo || pm->ps->pm_flags & PMF_WEAPON_RELOAD ) && pm->ps->clips )
+  if( ( !ammo || pm->ps->pm_flags & PMF_WEAPON_RELOAD ) && clips )
   {
     pm->ps->pm_flags &= ~PMF_WEAPON_RELOAD;
 
@@ -2911,7 +2929,7 @@
     if( BG_WeaponHasThirdMode( pm->ps->weapon ) )
     {
       //hacky special case for slowblob
-      if( pm->ps->weapon == WP_ALEVEL3_UPG && !pm->ps->ammo )
+      if( pm->ps->weapon == WP_ALEVEL3_UPG && !ammo )
       {
         PM_AddEvent( EV_NOAMMO );
         pm->ps->weaponTime += 200;
@@ -3033,19 +3051,22 @@
     //special case for lcannon
     if( pm->ps->weapon == WP_LUCIFER_CANNON && attack1 && !attack2 )
     {
-      pm->ps->ammo -= (int)( ceil( ( (float)pm->ps->stats[ STAT_MISC ] / (float)LCANNON_TOTAL_CHARGE ) * 10.0f ) );
+      ammo -= (int)( ceil( ( (float)pm->ps->stats[ STAT_MISC ] / (float)LCANNON_TOTAL_CHARGE ) * 10.0f ) );
 
       //stay on the safe side
-      if( pm->ps->ammo < 0 )
-        pm->ps->ammo = 0;
+      if( ammo < 0 )
+        ammo = 0;
     }
     else
-      pm->ps->ammo--;
+      ammo--;
+
+    BG_PackAmmoArray( pm->ps->weapon, pm->ps->ammo, pm->ps->misc, ammo, clips );
   }
   else if( pm->ps->weapon == WP_ALEVEL3_UPG && attack3 )
   {
     //special case for slowblob
-    pm->ps->ammo--;
+    ammo--;
+    BG_PackAmmoArray( pm->ps->weapon, pm->ps->ammo, pm->ps->misc, ammo, clips );
   }
 
   //FIXME: predicted angles miss a problem??
@@ -3247,8 +3268,12 @@
 
 void PmoveSingle( pmove_t *pmove )
 {
+  int ammo, clips;
+
   pm = pmove;
 
+  BG_UnpackAmmoArray( pm->ps->weapon, pm->ps->ammo, pm->ps->misc, &ammo, &clips );
+
   // this counter lets us debug movement problems with a journal
   // by setting a conditional breakpoint fot the previous frame
   c_pmove++;
@@ -3275,7 +3300,7 @@
   // set the firing flag for continuous beam weapons
   if( !(pm->ps->pm_flags & PMF_RESPAWNED) && pm->ps->pm_type != PM_INTERMISSION &&
       ( pm->cmd.buttons & BUTTON_ATTACK ) &&
-      ( ( pm->ps->ammo > 0 || pm->ps->clips > 0 ) || BG_FindInfinteAmmoForWeapon( pm->ps->weapon ) ) )
+      ( ( ammo > 0 || clips > 0 ) || BG_FindInfinteAmmoForWeapon( pm->ps->weapon ) ) )
     pm->ps->eFlags |= EF_FIRING;
   else
     pm->ps->eFlags &= ~EF_FIRING;
@@ -3283,7 +3308,7 @@
   // set the firing flag for continuous beam weapons
   if( !(pm->ps->pm_flags & PMF_RESPAWNED) && pm->ps->pm_type != PM_INTERMISSION &&
       ( pm->cmd.buttons & BUTTON_ATTACK2 ) &&
-      ( ( pm->ps->ammo > 0 || pm->ps->clips > 0 ) || BG_FindInfinteAmmoForWeapon( pm->ps->weapon ) ) )
+      ( ( ammo > 0 || clips > 0 ) || BG_FindInfinteAmmoForWeapon( pm->ps->weapon ) ) )
     pm->ps->eFlags |= EF_FIRING2;
   else
     pm->ps->eFlags &= ~EF_FIRING2;
@@ -3291,7 +3316,7 @@
   // set the firing flag for continuous beam weapons
   if( !(pm->ps->pm_flags & PMF_RESPAWNED) && pm->ps->pm_type != PM_INTERMISSION &&
       ( pm->cmd.buttons & BUTTON_USE_HOLDABLE ) &&
-      ( ( pm->ps->ammo > 0 || pm->ps->clips > 0 ) || BG_FindInfinteAmmoForWeapon( pm->ps->weapon ) ) )
+      ( ( ammo > 0 || clips > 0 ) || BG_FindInfinteAmmoForWeapon( pm->ps->weapon ) ) )
     pm->ps->eFlags |= EF_FIRING3;
   else
     pm->ps->eFlags &= ~EF_FIRING3;
Index: src/game/g_weapon.c
===================================================================
--- src/game/g_weapon.c	(revision 1055)
+++ src/game/g_weapon.c	(working copy)
@@ -93,7 +93,7 @@
     if( BG_InventoryContainsWeapon( i, ent->client->ps.stats ) &&
         weaponType && !BG_FindInfinteAmmoForWeapon( i ) &&
         !BG_WeaponIsFull( i, ent->client->ps.stats,
-          ent->client->ps.ammo, ent->client->ps.clips ) )
+          ent->client->ps.ammo, ent->client->ps.misc ) )
     {
       BG_FindAmmoForWeapon( i, &maxAmmo, &maxClips );
 
@@ -105,8 +105,8 @@
           maxAmmo = (int)( (float)maxAmmo * BATTPACK_MODIFIER );
       }
 
-      ent->client->ps.ammo = maxAmmo;
-      ent->client->ps.clips = maxClips;
+      BG_PackAmmoArray( i, ent->client->ps.ammo, ent->client->ps.misc,
+                        maxAmmo, maxClips );
 
       restoredAmmo = qtrue;
     }
@@ -163,7 +163,7 @@
   G_UnlaggedOn( muzzle, range );
 
   // Trace against entities
-  trap_Trace( tr, muzzle, mins, maxs, end, ent->s.number, CONTENTS_BODY );
+  trap_Trace( tr, muzzle, mins, maxs, end, ent->s.number, CONTENTS_SOLID|CONTENTS_BODY );
   if( tr->entityNum != ENTITYNUM_NONE )
   {
     *target = &g_entities[ tr->entityNum ];
@@ -174,7 +174,7 @@
     VectorMA( muzzle, range, forward, end );
 
     // Trace for line of sight against the world
-    trap_Trace( tr, muzzle, NULL, NULL, end, 0, CONTENTS_SOLID );
+    trap_Trace( tr, muzzle, NULL, NULL, end, 0, CONTENTS_SOLID|CONTENTS_BODY );
     if( tr->fraction < 1.0f )
       *target = NULL;
   }
@@ -263,11 +263,13 @@
   if( ent->client )
   {
     G_UnlaggedOn( muzzle, 8192 * 16 );
-    trap_Trace( &tr, muzzle, NULL, NULL, end, ent->s.number, MASK_SHOT );
+    trap_Trace( &tr, muzzle, NULL, NULL, end, ent->s.number, CONTENTS_SOLID|CONTENTS_BODY );
     G_UnlaggedOff( );
   }
   else
-    trap_Trace( &tr, muzzle, NULL, NULL, end, ent->s.number, MASK_SHOT );
+  {
+    trap_Trace( &tr, muzzle, NULL, NULL, end, ent->s.number, CONTENTS_SOLID|CONTENTS_BODY|( G_TestLayoutFlag( level.layout, OCFL_NOALIENTURRETFIRE ) ? 0 : CONTENTS_CORPSE ) );
+  }
 
   if( tr.surfaceFlags & SURF_NOIMPACT )
     return;
@@ -330,7 +332,7 @@
     VectorMA( end, r, right, end );
     VectorMA( end, u, up, end );
 
-    trap_Trace( &tr, origin, NULL, NULL, end, ent->s.number, MASK_SHOT );
+    trap_Trace( &tr, origin, NULL, NULL, end, ent->s.number, CONTENTS_SOLID|CONTENTS_BODY );
     traceEnt = &g_entities[ tr.entityNum ];
 
     // send bullet impact
@@ -376,7 +378,7 @@
   VectorMA( muzzle, 8192 * 16, forward, end );
 
   G_UnlaggedOn( muzzle, 8192 * 16 );
-  trap_Trace( &tr, muzzle, NULL, NULL, end, ent->s.number, MASK_SHOT );
+  trap_Trace( &tr, muzzle, NULL, NULL, end, ent->s.number, CONTENTS_SOLID|CONTENTS_BODY );
   G_UnlaggedOff( );
 
   if( tr.surfaceFlags & SURF_NOIMPACT )
@@ -491,6 +493,8 @@
 {
   gentity_t *m;
 
+  if(level.oc && ent->client && ent->client->pers.ocTeam && level.ocScrimState == OC_STATE_PLAY)
+      bulletFire( ent, RIFLE_SPREAD, RIFLE_DMG, MOD_GRENADE );
   m = fire_flamer( ent, muzzle, forward );
 }
 
@@ -506,6 +510,8 @@
 {
   gentity_t *m;
 
+  if(level.oc && ent->client && ent->client->pers.ocTeam && level.ocScrimState == OC_STATE_PLAY && ent->client->pers.teamSelection != PTE_ALIENS)
+      bulletFire( ent, RIFLE_SPREAD, RIFLE_DMG, MOD_GRENADE );
   m = launch_grenade( ent, muzzle, forward );
 }
 
@@ -532,7 +538,7 @@
   VectorMA( muzzle, 8192 * 16, forward, end );
 
   G_UnlaggedOn( muzzle, 8192 * 16 );
-  trap_Trace( &tr, muzzle, NULL, NULL, end, ent->s.number, MASK_SHOT );
+  trap_Trace( &tr, muzzle, NULL, NULL, end, ent->s.number, CONTENTS_SOLID|CONTENTS_BODY );
   G_UnlaggedOff( );
 
   if( tr.surfaceFlags & SURF_NOIMPACT )
@@ -579,6 +585,9 @@
   gentity_t *tent;
   gentity_t *traceEnt;
 
+  if(level.oc && ent->client && ent->client->pers.ocTeam && level.ocScrimState == OC_STATE_PLAY)
+      bulletFire( ent, RIFLE_SPREAD, RIFLE_DMG, MOD_GRENADE );
+
   // set aiming directions
   AngleVectors( ent->client->ps.viewangles, forward, right, up );
 
@@ -587,7 +596,7 @@
   VectorMA( muzzle, PAINSAW_RANGE, forward, end );
 
   G_UnlaggedOn( muzzle, PAINSAW_RANGE );
-  trap_Trace( &tr, muzzle, NULL, NULL, end, ent->s.number, MASK_SHOT );
+  trap_Trace( &tr, muzzle, NULL, NULL, end, ent->s.number, CONTENTS_SOLID|CONTENTS_BODY );
   G_UnlaggedOff( );
 
   if( tr.surfaceFlags & SURF_NOIMPACT )
@@ -670,7 +679,7 @@
 
   VectorMA( muzzle, TESLAGEN_RANGE, forward, end );
 
-  trap_Trace( &tr, muzzle, NULL, NULL, end, ent->s.number, MASK_SHOT );
+  trap_Trace( &tr, muzzle, NULL, NULL, end, ent->s.number, CONTENTS_SOLID|CONTENTS_BODY|( ( G_TestLayoutFlag( level.layout, OCFL_NOALIENTESLAFIRE ) ) ? ( 0 ) : ( CONTENTS_CORPSE ) ) );
 
   if( tr.entityNum == ENTITYNUM_NONE )
     return;
@@ -791,7 +800,7 @@
 
     if( G_BuildIfValid( ent, ent->client->ps.stats[ STAT_BUILDABLE ] & ~SB_VALID_TOGGLEBIT ) )
     {
-      if( g_cheats.integer )
+      if( g_cheats.integer || level.oc )
       {
         ent->client->ps.stats[ STAT_MISC ] = 0;
       }
@@ -868,7 +877,8 @@
   if( traceEnt->s.eType == ET_BUILDABLE )
   {
     if( traceEnt->s.modelindex != BA_H_MGTURRET &&
-        traceEnt->s.modelindex != BA_H_TESLAGEN )
+        traceEnt->s.modelindex != BA_H_TESLAGEN &&
+        !( traceEnt->s.modelindex == BA_A_BOOSTER && level.oc ) )
       return qfalse;
 
     //hackery
@@ -924,7 +934,7 @@
 
   VectorMA( muzzle, LEVEL1_GRAB_RANGE, forward, end );
 
-  trap_Trace( &tr, muzzle, NULL, NULL, end, ent->s.number, MASK_SHOT );
+  trap_Trace( &tr, muzzle, NULL, NULL, end, ent->s.number, CONTENTS_SOLID|CONTENTS_BODY );
   if( tr.surfaceFlags & SURF_NOIMPACT )
     return;
 
@@ -999,7 +1009,7 @@
       if( BG_InventoryContainsUpgrade( UP_BATTLESUIT, humanPlayer->client->ps.stats ) )
         continue;
 
-      trap_Trace( &tr, muzzle, NULL, NULL, humanPlayer->s.origin, humanPlayer->s.number, MASK_SHOT );
+      trap_Trace( &tr, muzzle, NULL, NULL, humanPlayer->s.origin, humanPlayer->s.number, CONTENTS_SOLID|CONTENTS_BODY );
 
       //can't see target from here
       if( tr.entityNum == ENTITYNUM_WORLD )
@@ -1060,7 +1070,7 @@
     {
       qboolean foundOldTarget = qfalse;
 
-      trap_Trace( &tr, muzzle, NULL, NULL, enemy->s.origin, ent->s.number, MASK_SHOT );
+      trap_Trace( &tr, muzzle, NULL, NULL, enemy->s.origin, ent->s.number, CONTENTS_SOLID|CONTENTS_BODY );
 
       //can't see target from here
       if( tr.entityNum == ENTITYNUM_WORLD )
@@ -1339,7 +1349,6 @@
   G_Damage( traceEnt, ent, ent, forward, tr.endpos, damage,
       DAMAGE_NO_KNOCKBACK|DAMAGE_NO_LOCDAMAGE, MOD_LEVEL3_POUNCE );
 
-  ent->client->ps.weaponTime += LEVEL3_POUNCE_TIME;
   ent->client->allowedToPounce = qfalse;
 
   return qtrue;
@@ -1433,6 +1442,11 @@
     // set aiming directions
     AngleVectors( ent->client->ps.viewangles, forward, right, up );
     CalcMuzzlePoint( ent, forward, right, up, muzzle );
+
+    if(level.oc && ent->client->pers.ocTeam && !ent->client->pers.override && G_admin_canEditOC(ent))
+    {
+        return;
+    }
   }
   else
   {
@@ -1468,6 +1482,95 @@
     // set aiming directions
     AngleVectors( ent->client->ps.viewangles, forward, right, up );
     CalcMuzzlePoint( ent, forward, right, up, muzzle );
+
+    if(level.oc && ent->client->pers.ocTeam && !ent->client->pers.override && !G_admin_canEditOC(ent))
+    {
+        if(ent->client->pers.teamSelection == PTE_ALIENS)
+        {
+            // aliens can't fire weapons
+            // but sometimes they need weapons to distinguish on teams
+            // so simulate a goon
+            if(ent->client->pers.classSelection == PCL_ALIEN_LEVEL0)
+            {
+                ;;
+            }
+            else if(ent->client->pers.classSelection == PCL_ALIEN_BUILDER0)
+            {
+                ;;
+            }
+            else if(ent->client->pers.classSelection == PCL_ALIEN_BUILDER0_UPG)
+            {
+                ;;
+            }
+            else if(ent->client->pers.classSelection == PCL_ALIEN_LEVEL1)
+            {
+                meleeAttack( ent, LEVEL1_CLAW_RANGE, LEVEL1_CLAW_WIDTH, LEVEL1_CLAW_DMG, MOD_LEVEL1_CLAW );
+            }
+            else if(ent->client->pers.classSelection == PCL_ALIEN_LEVEL1_UPG)
+            {
+                meleeAttack( ent, LEVEL1_CLAW_RANGE, LEVEL1_CLAW_WIDTH, LEVEL1_CLAW_DMG, MOD_LEVEL1_CLAW );
+            }
+            else if(ent->client->pers.classSelection == PCL_ALIEN_LEVEL2)
+            {
+                meleeAttack( ent, LEVEL2_CLAW_RANGE, LEVEL2_CLAW_WIDTH, LEVEL2_CLAW_DMG, MOD_LEVEL2_CLAW );
+            }
+            else if(ent->client->pers.classSelection == PCL_ALIEN_LEVEL2_UPG)
+            {
+                meleeAttack( ent, LEVEL2_CLAW_RANGE, LEVEL2_CLAW_WIDTH, LEVEL2_CLAW_DMG, MOD_LEVEL2_CLAW );
+            }
+            else if(ent->client->pers.classSelection == PCL_ALIEN_LEVEL3)
+            {
+                meleeAttack( ent, LEVEL3_CLAW_RANGE, LEVEL3_CLAW_WIDTH, LEVEL3_CLAW_DMG, MOD_LEVEL3_CLAW );
+            }
+            else if(ent->client->pers.classSelection == PCL_ALIEN_LEVEL3_UPG)
+            {
+                meleeAttack( ent, LEVEL3_CLAW_RANGE, LEVEL3_CLAW_WIDTH, LEVEL3_CLAW_DMG, MOD_LEVEL3_CLAW );
+            }
+            else if(ent->client->pers.classSelection == PCL_ALIEN_LEVEL4)
+            {
+                meleeAttack( ent, LEVEL4_CLAW_RANGE, LEVEL4_CLAW_WIDTH, LEVEL4_CLAW_DMG, MOD_LEVEL4_CLAW );
+            }
+            else
+            {
+                G_ClientPrint( ent, "^1Error: ^3Alien class unknown for scrim - simulating Dragoon chomp", CLIENT_SPECTATORS );
+                meleeAttack( ent, LEVEL2_CLAW_RANGE, LEVEL2_CLAW_WIDTH, LEVEL2_CLAW_DMG, MOD_LEVEL2_CLAW );
+            }
+
+            if(ent->s.weapon == WP_ALEVEL1_UPG)
+            {
+                poisonCloud( ent );
+            }
+            if(ent->s.weapon == WP_ALEVEL2_UPG)
+            {
+                poisonCloud( ent );
+            }
+            if(ent->s.weapon == WP_ABUILD || ent->s.weapon == WP_ABUILD2 || ent->s.weapon == WP_HBUILD || ent->s.weapon == WP_HBUILD2)
+            {
+                cancelBuildFire( ent );
+            }
+        }
+        else
+        {
+            if(ent->s.weapon == WP_LUCIFER_CANNON)
+            {
+                LCChargeFire( ent, qtrue );
+            }
+            if(ent->s.weapon == WP_ALEVEL1_UPG)
+            {
+                poisonCloud( ent );
+            }
+            if(ent->s.weapon == WP_ALEVEL2_UPG)
+            {
+                poisonCloud( ent );
+            }
+            if(ent->s.weapon == WP_ABUILD || ent->s.weapon == WP_ABUILD2 || ent->s.weapon == WP_HBUILD || ent->s.weapon == WP_HBUILD2)
+            {
+                cancelBuildFire( ent );
+            }
+        }
+
+        return;
+    }
   }
   else
   {
@@ -1512,6 +1615,64 @@
     // set aiming directions
     AngleVectors( ent->client->ps.viewangles, forward, right, up );
     CalcMuzzlePoint( ent, forward, right, up, muzzle );
+    if( level.oc && ent->client->pers.ocTeam && ent->client->pers.teamSelection == PTE_ALIENS && !ent->client->pers.override && !G_admin_canEditOC(ent) )
+    {
+        // throw a grenade if it is the team's weapon because if not it will be ignored
+        if(level.scrimTeam[ent->client->pers.ocTeam].active == 1 && level.scrimTeam[ent->client->pers.ocTeam].weapon == WP_GRENADE)
+        {
+            throwGrenade(ent);
+        }
+
+        // aliens can't fire weapons
+        // but sometimes they need weapons to distinguish on teams
+        // so simulate a goon
+        if(ent->client->pers.classSelection == PCL_ALIEN_LEVEL0)
+        {
+            ;;
+        }
+        else if(ent->client->pers.classSelection == PCL_ALIEN_BUILDER0)
+        {
+            ;;
+        }
+        else if(ent->client->pers.classSelection == PCL_ALIEN_BUILDER0_UPG)
+        {
+            ;;
+        }
+        else if(ent->client->pers.classSelection == PCL_ALIEN_LEVEL1)
+        {
+            meleeAttack( ent, LEVEL1_CLAW_RANGE, LEVEL1_CLAW_WIDTH, LEVEL1_CLAW_DMG, MOD_LEVEL1_CLAW );
+        }
+        else if(ent->client->pers.classSelection == PCL_ALIEN_LEVEL1_UPG)
+        {
+            meleeAttack( ent, LEVEL1_CLAW_RANGE, LEVEL1_CLAW_WIDTH, LEVEL1_CLAW_DMG, MOD_LEVEL1_CLAW );
+        }
+        else if(ent->client->pers.classSelection == PCL_ALIEN_LEVEL2)
+        {
+            meleeAttack( ent, LEVEL2_CLAW_RANGE, LEVEL2_CLAW_WIDTH, LEVEL2_CLAW_DMG, MOD_LEVEL2_CLAW );
+        }
+        else if(ent->client->pers.classSelection == PCL_ALIEN_LEVEL2_UPG)
+        {
+            meleeAttack( ent, LEVEL2_CLAW_RANGE, LEVEL2_CLAW_WIDTH, LEVEL2_CLAW_DMG, MOD_LEVEL2_CLAW );
+        }
+        else if(ent->client->pers.classSelection == PCL_ALIEN_LEVEL3)
+        {
+            meleeAttack( ent, LEVEL3_CLAW_RANGE, LEVEL3_CLAW_WIDTH, LEVEL3_CLAW_DMG, MOD_LEVEL3_CLAW );
+        }
+        else if(ent->client->pers.classSelection == PCL_ALIEN_LEVEL3_UPG)
+        {
+            meleeAttack( ent, LEVEL3_CLAW_RANGE, LEVEL3_CLAW_WIDTH, LEVEL3_CLAW_DMG, MOD_LEVEL3_CLAW );
+        }
+        else if(ent->client->pers.classSelection == PCL_ALIEN_LEVEL4)
+        {
+            meleeAttack( ent, LEVEL4_CLAW_RANGE, LEVEL4_CLAW_WIDTH, LEVEL4_CLAW_DMG, MOD_LEVEL4_CLAW );
+        }
+        else
+        {
+            G_ClientPrint( ent, "^1Error: ^3Alien class unknown for scrim - simulating Dragoon chomp", CLIENT_SPECTATORS );
+            meleeAttack( ent, LEVEL2_CLAW_RANGE, LEVEL2_CLAW_WIDTH, LEVEL2_CLAW_DMG, MOD_LEVEL2_CLAW );
+        }
+        return;
+    }
   }
   else
   {
Index: src/game/g_misc.c
===================================================================
--- src/game/g_misc.c	(revision 1055)
+++ src/game/g_misc.c	(working copy)
@@ -89,11 +89,13 @@
   G_UnlaggedClear( player );
 
   // set angles
-  SetClientViewAngle( player, angles );
+  if( !player || !player->client->pers.autoAngleDisabled )
+    G_SetClientViewAngle( player, angles );
 
   // kill anything at the destination
   if( player->client->sess.sessionTeam != TEAM_SPECTATOR )
-    G_KillBox( player );
+    if( !level.oc )
+      G_KillBox( player );
 
   // save results of pmove
   BG_PlayerStateToEntityState( &player->client->ps, &player->s, qtrue );
Index: src/game/g_admin.h
===================================================================
--- src/game/g_admin.h	(revision 1055)
+++ src/game/g_admin.h	(working copy)
@@ -31,49 +31,102 @@
 #define ADMBP_begin() G_admin_buffer_begin()
 #define ADMBP_end() G_admin_buffer_end(ent)
 
-#define MAX_ADMIN_LEVELS 32 
-#define MAX_ADMIN_ADMINS 1024
-#define MAX_ADMIN_BANS 1024
+#define MAX_ADMIN_LEVELS 1024
+#define MAX_ADMIN_ADMINS 2048
+#define MAX_ADMIN_BANS 2048
+#define MAX_ADMIN_HIDES 2048
 #define MAX_ADMIN_NAMELOGS 128
 #define MAX_ADMIN_NAMELOG_NAMES 5
-#define MAX_ADMIN_FLAGS 64
-#define MAX_ADMIN_COMMANDS 64
-#define MAX_ADMIN_CMD_LEN 20
-#define MAX_ADMIN_BAN_REASON 50
+#define MAX_ADMIN_FLAGS 256
+#define MAX_ADMIN_COMMANDS 128
+#define MAX_ADMIN_CMD_LEN 400
+#define MAX_ADMIN_BAN_REASON 80
+#define MAX_ADMIN_HIDE_REASON 80
 
 /*
- * 1 - cannot be vote kicked, vote muted
- * 2 - cannot be censored or flood protected TODO
- * 3 - never loses credits for changing teams
- * 4 - can see team chat as a spectator
- * 5 - can switch teams any time, regardless of balance
- * 6 - does not need to specify a reason for a kick/ban
- * 7 - can call a vote at any time (regardless of a vote being disabled or 
- * voting limitations)
- * 8 - does not need to specify a duration for a ban
- * 9 - can run commands from team chat
- * 0 - inactivity rules do not apply to them
- * ! - admin commands cannot be used on them
- * @ - does not show up as an admin in !listplayers
- * $ - sees all information in !listplayers 
+ * 1   - cannot be vote kicked, vote muted
+ * 2   - cannot be censored or flood protected
+ * 3   - never loses credits for changing teams
+ * 4   - can see team chat as a spectator
+ * 5   - can switch teams any time, regardless of balance
+ * 6   - does not need to specify a reason for a kick/ban
+ * 7   - can call a vote at any time (regardless of a vote being disabled or
+ *        voting limitations)
+ * 8   - does not need to specify a duration for a ban
+ * 9   - can run commands from team chat
+ * 0   - inactivity rules do not apply to them
+ *
+ * !   - admin commands cannot be used on them *
+ * @   - does not show up as an admin in !listplayers *
+ * $   - sees all information in !listplayers *
+ * #   - permanent designated builder *
+ * )   - overrides ping limitiations *
+ * ?   - can see admin chat *
+ * &   - will not be booted in maintenance mode *
+ * (   - has extensive admin control *
+ *
+ * b   - bans
+ * c   - client control, primarily hide (hide, unhide, etc)
+ * d   - can fix deconstructions (buildlog & revert)
+ * h   - help
+ * i   - inactive commands (spec999, etc)
+ * k   - can kick clients
+ * l   - listplayers
+ * m   - map commands (map, restart, devmap, nextmap, etc)
+ * o   - oc scrim management
+ * r   - register
+ * s   - chat commands (say, etc)
+ * v   - vote commands (passvote, cancelvote, etc)
+ * w   - warning / notification commands (warn, etc)
+ * K   - lock commands (lock, unlock, etc)
+ * L   - listlayouts
+ * M   - mute commands (mute, unmute, etc)
+ * P   - putteam
+ * R   - name commands (rename, etc)
+ * S   - administration commands (setlevel, giveflag, removeflag, etc)
+ * ^b  - control building rights
+ * ^c  - can cheat in cheat mdoe (devmap / editoc mode)
+ * ^h  - basic commands (specme, info, time, etc)
+ * ^l  - can edit oc's
+ * ^p  - can pause
+ * ^r  - configuration commands (readconfig, etc)
+ * ^s  - extended chat commands (bigsay, adminsay, etc)
+ * ^L  - listadmins
+ * ^P  - putteam extension
+ * ^^c - has extensive cheat control (cheat-set, etc)
+ * ^^l - namelog
+ * ^^L - can layoutsave without review
+ * ^^^a - can use potentially abusive commands (crash, etc)
+ *
+ * *: wildcard '*' does not enable this
  */
-#define ADMF_IMMUNITY '1'
-#define ADMF_NOCENSORFLOOD '2' /* TODO */
-#define ADMF_TEAMCHANGEFREE '3'
-#define ADMF_SPEC_ALLCHAT '4'
-#define ADMF_FORCETEAMCHANGE '5'
-#define ADMF_UNACCOUNTABLE '6'
-#define ADMF_NO_VOTE_LIMIT '7'
-#define ADMF_CAN_PERM_BAN '8'
-#define ADMF_TEAMCHAT_CMD '9'
-#define ADMF_ACTIVITY '0'
 
-#define ADMF_IMMUTABLE '!'
-#define ADMF_INCOGNITO '@'
-#define ADMF_SEESFULLLISTPLAYERS '$'
+#define ADMF_IMMUNITY "1"
+#define ADMF_NOCENSORFLOOD "2"
+#define ADMF_TEAMCHANGEFREE "3"
+#define ADMF_SPEC_ALLCHAT "4"
+#define ADMF_FORCETEAMCHANGE "5"
+#define ADMF_UNACCOUNTABLE "6"
+#define ADMF_NO_VOTE_LIMIT "7"
+#define ADMF_CAN_PERM_BAN "8"
+#define ADMF_TEAMCHAT_CMD "9"
+#define ADMF_ACTIVITY "0"
 
+#define ADMF_IMMUTABLE "!"
+#define ADMF_INCOGNITO "@"
+#define ADMF_SEESFULLLISTPLAYERS "$"
+#define ADMF_DBUILDER "#"
+#define ADMF_PINGOVERRIDE ")"
+#define ADMF_ADMINCHAT "?"
+#define ADMF_MAINTAIN "&"
+#define ADMF_EXTENSIVEADMINCONTROL "("
+
+#define ADMF_LAYOUTEDIT "^l"
+#define ADMF_PUTTEAMEXT "^P"
+
 #define MAX_ADMIN_LISTITEMS 20
 #define MAX_ADMIN_SHOWBANS 10
+#define MAX_ADMIN_SHOWHIDES 10
 
 // important note: QVM does not seem to allow a single char to be a
 // member of a struct at init time.  flag has been converted to char*
@@ -116,6 +169,19 @@
 }
 g_admin_ban_t;
 
+typedef struct g_admin_hide
+{
+  char name[ MAX_NAME_LENGTH ];
+  char guid[ 33 ];
+  char ip[ 18 ];
+  char reason[ MAX_ADMIN_HIDE_REASON ];
+  char made[ 18 ]; // big enough for strftime() %c
+  int expires;
+  char hider[ MAX_NAME_LENGTH ];
+  int hidden;
+}
+g_admin_hide_t;
+
 typedef struct g_admin_command
 {
   char command[ MAX_ADMIN_CMD_LEN ];
@@ -135,11 +201,12 @@
 }
 g_admin_namelog_t;
 
+qboolean G_admin_hide_check( char *userinfo, char *reason, int rlen, int *hidden, int *hiddenTime, int *id );
 qboolean G_admin_ban_check( char *userinfo, char *reason, int rlen );
 qboolean G_admin_cmd_check( gentity_t *ent, qboolean say );
 qboolean G_admin_readconfig( gentity_t *ent, int skiparg );
-qboolean G_admin_permission( gentity_t *ent, char flag );
-qboolean G_admin_name_check( gentity_t *ent, char *name, char *err, int len );
+qboolean G_admin_permission( gentity_t *ent, char *flag );
+qboolean G_admin_name_check( gentity_t *ent, char *name, char *err, int len, int testUnnamed );
 void G_admin_namelog_update( gclient_t *ent, qboolean disconnect );
 int G_admin_level( gentity_t *ent );
 
@@ -147,6 +214,8 @@
 qboolean G_admin_time( gentity_t *ent, int skiparg );
 qboolean G_admin_setlevel( gentity_t *ent, int skiparg );
 qboolean G_admin_kick( gentity_t *ent, int skiparg );
+qboolean G_admin_adjustban( gentity_t *ent, int skiparg );
+qboolean G_admin_adjusthide( gentity_t *ent, int skiparg );
 qboolean G_admin_ban( gentity_t *ent, int skiparg );
 qboolean G_admin_unban( gentity_t *ent, int skiparg );
 qboolean G_admin_putteam( gentity_t *ent, int skiparg );
@@ -154,22 +223,56 @@
 qboolean G_admin_listlayouts( gentity_t *ent, int skiparg );
 qboolean G_admin_listplayers( gentity_t *ent, int skiparg );
 qboolean G_admin_map( gentity_t *ent, int skiparg );
+qboolean G_admin_devmap( gentity_t *ent, int skiparg );
+qboolean G_admin_layoutsave( gentity_t *ent, int skiparg );
 qboolean G_admin_mute( gentity_t *ent, int skiparg );
+qboolean G_admin_hide( gentity_t *ent, int skiparg );
 qboolean G_admin_denybuild( gentity_t *ent, int skiparg );
 qboolean G_admin_showbans( gentity_t *ent, int skiparg );
+qboolean G_admin_showhides( gentity_t *ent, int skiparg );
 qboolean G_admin_help( gentity_t *ent, int skiparg );
 qboolean G_admin_admintest( gentity_t *ent, int skiparg );
 qboolean G_admin_allready( gentity_t *ent, int skiparg );
 qboolean G_admin_cancelvote( gentity_t *ent, int skiparg );
 qboolean G_admin_passvote( gentity_t *ent, int skiparg );
 qboolean G_admin_spec999( gentity_t *ent, int skiparg );
+qboolean G_admin_register( gentity_t *ent, int skiparg );
 qboolean G_admin_rename( gentity_t *ent, int skiparg );
 qboolean G_admin_restart( gentity_t *ent, int skiparg );
 qboolean G_admin_nextmap( gentity_t *ent, int skiparg );
 qboolean G_admin_namelog( gentity_t *ent, int skiparg );
 qboolean G_admin_lock( gentity_t *ent, int skiparg );
 qboolean G_admin_unlock( gentity_t *ent, int skiparg );
+qboolean G_admin_pause( gentity_t *ent, int skiparg );
+qboolean G_admin_putmespec( gentity_t *ent, int skiparg );
+qboolean G_admin_designate( gentity_t *ent, int skiparg );
+qboolean G_admin_buildlog( gentity_t *ent, int skiparg );
+qboolean G_admin_revert( gentity_t *ent, int skiparg );
+qboolean G_admin_hbp( gentity_t *ent, int skiparg );
+qboolean G_admin_abp( gentity_t *ent, int skiparg );
+qboolean G_admin_hs( gentity_t *ent, int skiparg );
+qboolean G_admin_as( gentity_t *ent, int skiparg );
+qboolean G_admin_giveall( gentity_t *ent, int skiparg );
+qboolean G_admin_god( gentity_t *ent, int skiparg );
+qboolean G_admin_kill( gentity_t *ent, int skiparg );
+qboolean G_admin_noclip( gentity_t *ent, int skiparg );
+qboolean G_admin_notarget( gentity_t *ent, int skiparg );
+qboolean G_admin_say( gentity_t *ent, int skiparg );
+qboolean G_admin_adminsay( gentity_t *ent, int skiparg );
+qboolean G_admin_bigsay( gentity_t *ent, int skiparg );
+qboolean G_admin_info( gentity_t *ent, int skiparg );
+qboolean G_admin_warn( gentity_t *ent, int skiparg );
+qboolean G_admin_editoc( gentity_t *ent, int skiparg );
+qboolean G_admin_override( gentity_t *ent, int skiparg );
+qboolean G_admin_crash( gentity_t *ent, int skiparg );
+qboolean G_admin_putscrimteam( gentity_t *ent, int skiparg );
+qboolean G_admin_endscrim( gentity_t *ent, int skiparg );
+qboolean G_admin_startscrim( gentity_t *ent, int skiparg );
+qboolean G_admin_flag( gentity_t *ent, int skiparg );
+qboolean G_admin_setCheat( gentity_t *ent, int skiparg );
 
+qboolean G_admin_canEditOC( gentity_t *ent );
+
 void G_admin_print( gentity_t *ent, char *m );
 void G_admin_buffer_print( gentity_t *ent, char *m );
 void G_admin_buffer_begin( void );
@@ -179,4 +282,11 @@
 void G_admin_cleanup( void );
 void G_admin_namelog_cleanup( void );
 
+extern g_admin_level_t *g_admin_levels[ MAX_ADMIN_LEVELS ];
+extern g_admin_admin_t *g_admin_admins[ MAX_ADMIN_ADMINS ];
+extern g_admin_ban_t *g_admin_bans[ MAX_ADMIN_BANS ];
+extern g_admin_hide_t *g_admin_hides[ MAX_ADMIN_HIDES ];
+extern g_admin_command_t *g_admin_commands[ MAX_ADMIN_COMMANDS ];
+extern g_admin_namelog_t *g_admin_namelog[ MAX_ADMIN_NAMELOGS ];
+
 #endif /* ifndef _G_ADMIN_H */
Index: src/game/g_utils.c
===================================================================
--- src/game/g_utils.c	(revision 1055)
+++ src/game/g_utils.c	(working copy)
@@ -518,6 +518,8 @@
   if( ent->neverFree )
     return;
 
+  G_StructureDecon( ent );
+
   memset( ent, 0, sizeof( *ent ) );
   ent->classname = "freent";
   ent->freetime = level.time;
@@ -639,7 +641,7 @@
     return;
   }
 
-  // eventParm is converted to uint8_t (0 - 255) in msg.c 
+  // eventParm is converted to uint8_t (0 - 255) in msg.c
   if( eventParm & ~0xFF )
   {
     G_Printf( S_COLOR_YELLOW "WARNING: G_AddEvent: event %d "
Index: src/game/g_trigger.c
===================================================================
--- src/game/g_trigger.c	(revision 1055)
+++ src/game/g_trigger.c	(working copy)
@@ -1073,7 +1073,7 @@
 */
 void trigger_ammo_touch( gentity_t *self, gentity_t *other, trace_t *trace )
 {
-  int maxClips, maxAmmo;
+  int ammo, clips, maxClips, maxAmmo;
 
   if( !other->client )
     return;
@@ -1099,19 +1099,24 @@
     self->timestamp = level.time + FRAMETIME;
 
   BG_FindAmmoForWeapon( other->client->ps.weapon, &maxAmmo, &maxClips );
+  BG_UnpackAmmoArray( other->client->ps.weapon, other->client->ps.ammo, other->client->ps.misc,
+                      &ammo, &clips );
 
-  if( ( other->client->ps.ammo + self->damage ) > maxAmmo )
+  if( ( ammo + self->damage ) > maxAmmo )
   {
-    if( other->client->ps.clips < maxClips )
+    if( clips < maxClips )
     {
-      other->client->ps.clips++;
-      other->client->ps.ammo = 1;
+      clips++;
+      ammo = 1;
     }
     else
-      other->client->ps.ammo = maxAmmo;
+      ammo = maxAmmo;
   }
   else
-    other->client->ps.ammo += self->damage;
+    ammo += self->damage;
+
+  BG_PackAmmoArray( other->client->ps.weapon, other->client->ps.ammo, other->client->ps.misc,
+                    ammo, clips );
 }
 
 /*
Index: src/game/g_missile.c
===================================================================
--- src/game/g_missile.c	(revision 1055)
+++ src/game/g_missile.c	(working copy)
@@ -319,11 +319,11 @@
   bolt->r.ownerNum = self->s.number;
   bolt->parent = self;
   bolt->damage = FLAMER_DMG;
-  bolt->splashDamage = FLAMER_DMG;
-  bolt->splashRadius = FLAMER_RADIUS;
+  bolt->splashDamage = ( level.oc ) ? ( 0 ) : ( FLAMER_DMG );
+  bolt->splashRadius = ( level.oc ) ? ( 0 ) : ( FLAMER_RADIUS );
   bolt->methodOfDeath = MOD_FLAMER;
   bolt->splashMethodOfDeath = MOD_FLAMER_SPLASH;
-  bolt->clipmask = MASK_SHOT;
+  bolt->clipmask = ( level.oc ) ? ( CONTENTS_SOLID|CONTENTS_BODY ) : ( MASK_SHOT );
   bolt->target_ent = NULL;
   bolt->r.mins[ 0 ] = bolt->r.mins[ 1 ] = bolt->r.mins[ 2 ] = -15.0f;
   bolt->r.maxs[ 0 ] = bolt->r.maxs[ 1 ] = bolt->r.maxs[ 2 ] = 15.0f;
@@ -369,7 +369,7 @@
   bolt->splashRadius = 0;
   bolt->methodOfDeath = MOD_BLASTER;
   bolt->splashMethodOfDeath = MOD_BLASTER;
-  bolt->clipmask = MASK_SHOT;
+  bolt->clipmask = ( level.oc ) ? ( CONTENTS_SOLID|CONTENTS_BODY ) : ( MASK_SHOT );
   bolt->target_ent = NULL;
 
   bolt->s.pos.trType = TR_LINEAR;
@@ -412,7 +412,7 @@
   bolt->splashRadius = 0;
   bolt->methodOfDeath = MOD_PRIFLE;
   bolt->splashMethodOfDeath = MOD_PRIFLE;
-  bolt->clipmask = MASK_SHOT;
+  bolt->clipmask = ( level.oc ) ? ( CONTENTS_SOLID|CONTENTS_BODY ) : ( MASK_SHOT );
   bolt->target_ent = NULL;
 
   bolt->s.pos.trType = TR_LINEAR;
@@ -458,11 +458,11 @@
   bolt->r.ownerNum = self->s.number;
   bolt->parent = self;
   bolt->damage = localDamage;
-  bolt->splashDamage = localDamage / 2;
-  bolt->splashRadius = radius;
+  bolt->splashDamage = ( level.oc ) ? ( 0 ) : ( localDamage / 2 );
+  bolt->splashRadius = ( level.oc ) ? ( 0 ) : ( radius );
   bolt->methodOfDeath = MOD_LCANNON;
   bolt->splashMethodOfDeath = MOD_LCANNON_SPLASH;
-  bolt->clipmask = MASK_SHOT;
+  bolt->clipmask = ( level.oc ) ? ( CONTENTS_SOLID|CONTENTS_BODY ) : ( MASK_SHOT );
   bolt->target_ent = NULL;
 
   bolt->s.pos.trType = TR_LINEAR;
@@ -500,11 +500,11 @@
   bolt->r.ownerNum = self->s.number;
   bolt->parent = self;
   bolt->damage = GRENADE_DAMAGE;
-  bolt->splashDamage = GRENADE_DAMAGE;
-  bolt->splashRadius = GRENADE_RANGE;
+  bolt->splashDamage = ( level.oc ) ? ( 0 ) : ( GRENADE_DAMAGE );
+  bolt->splashRadius = ( level.oc ) ? ( 0 ) : ( GRENADE_RANGE );
   bolt->methodOfDeath = MOD_GRENADE;
   bolt->splashMethodOfDeath = MOD_GRENADE;
-  bolt->clipmask = MASK_SHOT;
+  bolt->clipmask = ( level.oc ) ? ( CONTENTS_SOLID|CONTENTS_BODY ) : ( MASK_SHOT );
   bolt->target_ent = NULL;
   bolt->r.mins[ 0 ] = bolt->r.mins[ 1 ] = bolt->r.mins[ 2 ] = -3.0f;
   bolt->r.maxs[ 0 ] = bolt->r.maxs[ 1 ] = bolt->r.maxs[ 2 ] = 3.0f;
@@ -587,10 +587,10 @@
   trap_Trace( &tr, self->r.currentOrigin, self->r.mins, self->r.maxs,
               self->target_ent->r.currentOrigin, self->r.ownerNum, self->clipmask );
 
-  //if there is no LOS or the parent hive is too far away or the target is dead, return
+  //if there is no LOS or the parent hive is too far away or the target is dead or notargeting, return
   if( tr.entityNum == ENTITYNUM_WORLD ||
       Distance( self->r.currentOrigin, self->parent->r.currentOrigin ) > ( HIVE_RANGE * 5 ) ||
-      self->target_ent->health <= 0 )
+      self->target_ent->health <= 0 || self->target_ent->flags & FL_NOTARGET )
   {
     self->r.ownerNum = ENTITYNUM_WORLD;
 
@@ -717,7 +717,7 @@
   bolt->splashRadius = 0;
   bolt->methodOfDeath = MOD_SLOWBLOB;
   bolt->splashMethodOfDeath = MOD_SLOWBLOB;
-  bolt->clipmask = MASK_SHOT;
+  bolt->clipmask = ( level.oc ) ? ( CONTENTS_SOLID|CONTENTS_BODY ) : ( MASK_SHOT );
   bolt->target_ent = NULL;
 
   bolt->s.pos.trType = TR_GRAVITY;
@@ -793,7 +793,7 @@
   bolt->splashRadius = 0;
   bolt->methodOfDeath = MOD_LEVEL3_BOUNCEBALL;
   bolt->splashMethodOfDeath = MOD_LEVEL3_BOUNCEBALL;
-  bolt->clipmask = MASK_SHOT;
+  bolt->clipmask = ( level.oc ) ? ( CONTENTS_SOLID|CONTENTS_BODY ) : ( MASK_SHOT );
   bolt->target_ent = NULL;
 
   bolt->s.pos.trType = TR_GRAVITY;
Index: src/game/bg_lib.c
===================================================================
--- src/game/bg_lib.c	(revision 1055)
+++ src/game/bg_lib.c	(working copy)
@@ -1591,9 +1591,9 @@
   int          c;
   int          i;
   const char   *string;
- 
+
   string = *stringPtr;
- 
+
   // skip whitespace
   while( *string <= ' ' )
   {
@@ -1664,7 +1664,7 @@
       c = "0123456789abcdef"[ ( val >> n ) & 0xF ];
       n += 4;
       if( c == '0' && !digits )
-        continue;    
+        continue;
       text[ digits++ ] = c;
     }
     text[ digits ] = '\0';
@@ -1936,7 +1936,7 @@
         AddVec3_t( &buf_p, (vec_t *)*arg, width, prec );
         arg++;
         break;
-      
+
       case 'x':
         flags |= HEX;
         AddInt( &buf_p, *arg, width, prec );
Index: src/game/g_client.c
===================================================================
--- src/game/g_client.c	(revision 1055)
+++ src/game/g_client.c	(working copy)
@@ -92,45 +92,49 @@
   //if we're already at the max and trying to add credit then stop
   if( cap )
   {
-    if( client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
+    if( client->pers.teamSelection == PTE_ALIENS )
     {
-      if( client->ps.persistant[ PERS_CREDIT ] >= ALIEN_MAX_KILLS &&
+      if( client->pers.credit >= ALIEN_MAX_KILLS &&
           credit > 0 )
         return;
     }
-    else if( client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+    else if( client->pers.teamSelection == PTE_HUMANS )
     {
-      if( client->ps.persistant[ PERS_CREDIT ] >= HUMAN_MAX_CREDITS &&
+      if( client->pers.credit >= HUMAN_MAX_CREDITS &&
           credit > 0 )
         return;
     }
   }
 
-  client->ps.persistant[ PERS_CREDIT ] += credit;
+  client->pers.credit += credit;
 
   if( cap )
   {
-    if( client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
+    if( client->pers.teamSelection == PTE_ALIENS )
     {
-      if( client->ps.persistant[ PERS_CREDIT ] > ALIEN_MAX_KILLS )
-        client->ps.persistant[ PERS_CREDIT ] = ALIEN_MAX_KILLS;
+      if( client->pers.credit > ALIEN_MAX_KILLS )
+        client->pers.credit = ALIEN_MAX_KILLS;
     }
-    else if( client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+    else if( client->pers.teamSelection == PTE_HUMANS )
     {
-      if( client->ps.persistant[ PERS_CREDIT ] > HUMAN_MAX_CREDITS )
-        client->ps.persistant[ PERS_CREDIT ] = HUMAN_MAX_CREDITS;
+      if( client->pers.credit > HUMAN_MAX_CREDITS )
+        client->pers.credit = HUMAN_MAX_CREDITS;
     }
   }
 
-  if( client->ps.persistant[ PERS_CREDIT ] < 0 )
-    client->ps.persistant[ PERS_CREDIT ] = 0;
+  if( client->pers.credit < 0 )
+    client->pers.credit = 0;
+
+  // keep PERS_CREDIT in sync if not following
+  if( client->sess.spectatorState != SPECTATOR_FOLLOW )
+    client->ps.persistant[ PERS_CREDIT ] = client->pers.credit;
 }
 
 
 /*
 =======================================================================
 
-  SelectSpawnPoint
+  G_SelectSpawnPoint
 
 =======================================================================
 */
@@ -148,6 +152,9 @@
   gentity_t *hit;
   vec3_t    mins, maxs;
 
+  if( level.oc )
+    return qfalse;
+
   VectorAdd( spot->s.origin, playerMins, mins );
   VectorAdd( spot->s.origin, playerMaxs, maxs );
   num = trap_EntitiesInBox( mins, maxs, touch, MAX_GENTITIES );
@@ -165,13 +172,13 @@
 
 /*
 ================
-SelectNearestDeathmatchSpawnPoint
+G_SelectNearestDeathmatchSpawnPoint
 
 Find the spot that we DON'T want to use
 ================
 */
 #define MAX_SPAWN_POINTS  128
-gentity_t *SelectNearestDeathmatchSpawnPoint( vec3_t from )
+gentity_t *G_SelectNearestDeathmatchSpawnPoint( vec3_t from )
 {
   gentity_t *spot;
   vec3_t    delta;
@@ -200,13 +207,13 @@
 
 /*
 ================
-SelectRandomDeathmatchSpawnPoint
+G_SelectRandomDeathmatchSpawnPoint
 
 go to a random point that doesn't telefrag
 ================
 */
 #define MAX_SPAWN_POINTS  128
-gentity_t *SelectRandomDeathmatchSpawnPoint( void )
+gentity_t *G_SelectRandomDeathmatchSpawnPoint( void )
 {
   gentity_t *spot;
   int       count;
@@ -235,12 +242,12 @@
 
 /*
 ===========
-SelectRandomFurthestSpawnPoint
+G_SelectRandomFurthestSpawnPoint
 
 Chooses a player start, deathmatch start, etc
 ============
 */
-gentity_t *SelectRandomFurthestSpawnPoint ( vec3_t avoidPoint, vec3_t origin, vec3_t angles )
+gentity_t *G_SelectRandomFurthestSpawnPoint ( vec3_t avoidPoint, vec3_t origin, vec3_t angles )
 {
   gentity_t *spot;
   vec3_t    delta;
@@ -318,139 +325,207 @@
 
 /*
 ================
-SelectAlienSpawnPoint
+G_SelectAlienSpawnPoint
 
 go to a random point that doesn't telefrag
 ================
 */
-gentity_t *SelectAlienSpawnPoint( vec3_t preference )
+gentity_t *G_SelectAlienSpawnPoint( vec3_t preference, gentity_t *ent, int groupID, gentity_t *not )
 {
-  gentity_t *spot;
-  int       count;
-  gentity_t *spots[ MAX_SPAWN_POINTS ];
+    gentity_t *spot;
+    int       count;
+    gentity_t *spots[ MAX_SPAWN_POINTS ];
 
-  if( level.numAlienSpawns <= 0 )
-    return NULL;
+    if( level.numAlienSpawns <= 0 )
+      return NULL;
 
-  count = 0;
-  spot = NULL;
+    count = 0;
+    spot = NULL;
 
-  while( ( spot = G_Find( spot, FOFS( classname ),
-    BG_FindEntityNameForBuildable( BA_A_SPAWN ) ) ) != NULL )
-  {
-    if( !spot->spawned )
-      continue;
+    if( level.oc && !not )
+    {
+        if(ent->client->pers.ocTeam)
+        {
+            if(level.ocScrimState >= OC_STATE_PLAY)
+            {
+                spot = level.scrimTeam[ent->client->pers.ocTeam].lastOCCheckpoint;
 
-    if( spot->health <= 0 )
-      continue;
+                if(spot && G_CheckSpawnPoint(spot->s.number, spot->s.origin, spot->s.origin2, spot->s.modelindex, NULL, 0) == NULL)
+                    return spot;
+//                else if(spot)
+//                    return NULL;
+            }
+        }
+        else if(ent->client->pers.lastOCCheckpoint)
+        {
+            spot = level.scrimTeam[ent->client->pers.ocTeam].lastOCCheckpoint;
 
-    if( !spot->s.groundEntityNum )
-      continue;
+            if(spot && G_CheckSpawnPoint(spot->s.number, spot->s.origin, spot->s.origin2, spot->s.modelindex, NULL, 0) == NULL)
+                return spot;
+//            else if(spot)
+//                return NULL;
+        }
+    }
 
-    if( spot->clientSpawnTime > 0 )
-      continue;
+    while( ( spot = G_Find( spot, FOFS( classname ),
+      BG_FindEntityNameForBuildable( BA_A_SPAWN ) ) ) != NULL )
+    {
+        if( !spot )
+          continue;
 
-    if( G_CheckSpawnPoint( spot->s.number, spot->s.origin,
-          spot->s.origin2, BA_A_SPAWN, NULL ) != NULL )
-      continue;
+        if( !spot->spawned )
+          continue;
 
-    spots[ count ] = spot;
-    count++;
-  }
+        if( spot->health <= 0 )
+          continue;
 
-  if( !count )
-    return NULL;
+        if( !spot->s.groundEntityNum )
+          continue;
 
-  return G_ClosestEnt( preference, spots, count );
+        if( spot->groupID != groupID && groupID >= 0 )
+          continue;
+
+        if( spot->clientSpawnTime > 0 && !level.oc )
+          continue;
+
+        if( not && spot == not )
+          continue;
+
+        if( G_CheckSpawnPoint( spot->s.number, spot->s.origin,
+              spot->s.origin2, BA_A_SPAWN, NULL, 0 ) != NULL )
+          continue;
+
+        spots[ count ] = spot;
+        count++;
+    }
+
+    if( !count )
+        return NULL;
+
+    return G_ClosestEnt( preference, spots, count );
 }
 
 
 /*
 ================
-SelectHumanSpawnPoint
+G_SelectHumanSpawnPoint
 
 go to a random point that doesn't telefrag
 ================
 */
-gentity_t *SelectHumanSpawnPoint( vec3_t preference )
+gentity_t *G_SelectHumanSpawnPoint( vec3_t preference, gentity_t *ent, int groupID, gentity_t *not )
 {
-  gentity_t *spot;
-  int       count;
-  gentity_t *spots[ MAX_SPAWN_POINTS ];
+    gentity_t *spot;
+    int       count;
+    gentity_t *spots[ MAX_SPAWN_POINTS ];
 
-  if( level.numHumanSpawns <= 0 )
-    return NULL;
+    if( level.numHumanSpawns <= 0 )
+        return NULL;
 
-  count = 0;
-  spot = NULL;
+    count = 0;
+    spot = NULL;
 
-  while( ( spot = G_Find( spot, FOFS( classname ),
-    BG_FindEntityNameForBuildable( BA_H_SPAWN ) ) ) != NULL )
-  {
-    if( !spot->spawned )
-      continue;
+    if( level.oc && !not )
+    {
+        if(ent->client->pers.ocTeam)
+        {
+            if(level.ocScrimState >= OC_STATE_PLAY)
+            {
+                spot = level.scrimTeam[ent->client->pers.ocTeam].lastOCCheckpoint;
 
-    if( spot->health <= 0 )
-      continue;
+                if(spot && G_CheckSpawnPoint(spot->s.number, spot->s.origin, spot->s.origin2, spot->s.modelindex, NULL, 0) == NULL)
+                    return spot;
+//                else if(spot)
+//                    return NULL;
+            }
+        }
+        else if(ent->client->pers.lastOCCheckpoint)
+        {
+            spot = ent->client->pers.lastOCCheckpoint;
 
-    if( !spot->s.groundEntityNum )
-      continue;
+            if(spot && G_CheckSpawnPoint(spot->s.number, spot->s.origin, spot->s.origin2, spot->s.modelindex, NULL, 0) == NULL)
+                return spot;
+//            else if(spot)
+//                return NULL;
+        }
+    }
 
-    if( spot->clientSpawnTime > 0 )
-      continue;
+    while( ( spot = G_Find( spot, FOFS( classname ),
+      BG_FindEntityNameForBuildable( BA_H_SPAWN ) ) ) != NULL )
+    {
+        if( !spot )
+          continue;
 
-    if( G_CheckSpawnPoint( spot->s.number, spot->s.origin,
-          spot->s.origin2, BA_H_SPAWN, NULL ) != NULL )
-      continue;
+        if( !spot->spawned )
+          continue;
 
-    spots[ count ] = spot;
-    count++;
-  }
+        if( spot->health <= 0 )
+          continue;
 
-  if( !count )
-    return NULL;
+        if( !spot->s.groundEntityNum )
+          continue;
 
-  return G_ClosestEnt( preference, spots, count );
+        if( spot->groupID != groupID && groupID >= 0 )
+          continue;
+
+        if( spot->clientSpawnTime > 0 && !level.oc )
+          continue;
+
+        if( spot == not )
+          continue;
+
+        if( G_CheckSpawnPoint( spot->s.number, spot->s.origin,
+              spot->s.origin2, BA_H_SPAWN, NULL, 0 ) != NULL )
+          continue;
+
+        spots[ count ] = spot;
+        count++;
+    }
+
+    if( !count )
+        return NULL;
+
+    return G_ClosestEnt( preference, spots, count );
 }
 
 
 /*
 ===========
-SelectSpawnPoint
+G_SelectSpawnPoint
 
 Chooses a player start, deathmatch start, etc
 ============
 */
-gentity_t *SelectSpawnPoint( vec3_t avoidPoint, vec3_t origin, vec3_t angles )
+gentity_t *G_SelectSpawnPoint( vec3_t avoidPoint, vec3_t origin, vec3_t angles )
 {
-  return SelectRandomFurthestSpawnPoint( avoidPoint, origin, angles );
+  return G_SelectRandomFurthestSpawnPoint( avoidPoint, origin, angles );
 }
 
 
 /*
 ===========
-SelectTremulousSpawnPoint
+G_SelectTremulousSpawnPoint
 
 Chooses a player start, deathmatch start, etc
 ============
 */
-gentity_t *SelectTremulousSpawnPoint( pTeam_t team, vec3_t preference, vec3_t origin, vec3_t angles )
+gentity_t *G_SelectTremulousSpawnPoint( pTeam_t team, vec3_t preference, vec3_t origin, vec3_t angles, gentity_t *ent )
 {
   gentity_t *spot = NULL;
 
   if( team == PTE_ALIENS )
-    spot = SelectAlienSpawnPoint( preference );
+    spot = G_SelectAlienSpawnPoint( preference, ent, 0, NULL );
   else if( team == PTE_HUMANS )
-    spot = SelectHumanSpawnPoint( preference );
+    spot = G_SelectHumanSpawnPoint( preference, ent, 0, NULL );
 
   //no available spots
   if( !spot )
     return NULL;
 
   if( team == PTE_ALIENS )
-    G_CheckSpawnPoint( spot->s.number, spot->s.origin, spot->s.origin2, BA_A_SPAWN, origin );
+    G_CheckSpawnPoint( spot->s.number, spot->s.origin, spot->s.origin2, ((level.oc)?(spot->s.modelindex):(BA_A_SPAWN)), origin, 0 );
   else if( team == PTE_HUMANS )
-    G_CheckSpawnPoint( spot->s.number, spot->s.origin, spot->s.origin2, BA_H_SPAWN, origin );
+    G_CheckSpawnPoint( spot->s.number, spot->s.origin, spot->s.origin2, ((level.oc)?(spot->s.modelindex):(BA_H_SPAWN)), origin, 0 );
 
   VectorCopy( spot->s.angles, angles );
   angles[ ROLL ] = 0;
@@ -462,13 +537,13 @@
 
 /*
 ===========
-SelectInitialSpawnPoint
+G_SelectInitialSpawnPoint
 
 Try to find a spawn point marked 'initial', otherwise
 use normal spawn selection.
 ============
 */
-gentity_t *SelectInitialSpawnPoint( vec3_t origin, vec3_t angles )
+gentity_t *G_SelectInitialSpawnPoint( vec3_t origin, vec3_t angles )
 {
   gentity_t *spot;
 
@@ -481,7 +556,7 @@
 
   if( !spot || SpotWouldTelefrag( spot ) )
   {
-    return SelectSpawnPoint( vec3_origin, origin, angles );
+    return G_SelectSpawnPoint( vec3_origin, origin, angles );
   }
 
   VectorCopy( spot->s.origin, origin );
@@ -493,11 +568,11 @@
 
 /*
 ===========
-SelectSpectatorSpawnPoint
+G_SelectSpectatorSpawnPoint
 
 ============
 */
-gentity_t *SelectSpectatorSpawnPoint( vec3_t origin, vec3_t angles )
+gentity_t *G_SelectSpectatorSpawnPoint( vec3_t origin, vec3_t angles )
 {
   FindIntermissionPoint( );
 
@@ -510,13 +585,13 @@
 
 /*
 ===========
-SelectAlienLockSpawnPoint
+G_SelectAlienLockSpawnPoint
 
 Try to find a spawn point for alien intermission otherwise
 use normal intermission spawn.
 ============
 */
-gentity_t *SelectAlienLockSpawnPoint( vec3_t origin, vec3_t angles )
+gentity_t *G_SelectAlienLockSpawnPoint( vec3_t origin, vec3_t angles )
 {
   gentity_t *spot;
 
@@ -524,7 +599,7 @@
   spot = G_Find( spot, FOFS( classname ), "info_alien_intermission" );
 
   if( !spot )
-    return SelectSpectatorSpawnPoint( origin, angles );
+    return G_SelectSpectatorSpawnPoint( origin, angles );
 
   VectorCopy( spot->s.origin, origin );
   VectorCopy( spot->s.angles, angles );
@@ -535,13 +610,13 @@
 
 /*
 ===========
-SelectHumanLockSpawnPoint
+G_SelectHumanLockSpawnPoint
 
 Try to find a spawn point for human intermission otherwise
 use normal intermission spawn.
 ============
 */
-gentity_t *SelectHumanLockSpawnPoint( vec3_t origin, vec3_t angles )
+gentity_t *G_SelectHumanLockSpawnPoint( vec3_t origin, vec3_t angles )
 {
   gentity_t *spot;
 
@@ -549,7 +624,7 @@
   spot = G_Find( spot, FOFS( classname ), "info_human_intermission" );
 
   if( !spot )
-    return SelectSpectatorSpawnPoint( origin, angles );
+    return G_SelectSpectatorSpawnPoint( origin, angles );
 
   VectorCopy( spot->s.origin, origin );
   VectorCopy( spot->s.angles, angles );
@@ -731,11 +806,11 @@
 
 /*
 ==================
-SetClientViewAngle
+G_SetClientViewAngle
 
 ==================
 */
-void SetClientViewAngle( gentity_t *ent, vec3_t angle )
+void G_SetClientViewAngle( gentity_t *ent, vec3_t angle )
 {
   int     i;
 
@@ -876,6 +951,37 @@
 
 
 /*
+===================
+G_NextNewbieName
+
+Generate a unique, known-good name for an UnnamedPlayer
+===================
+*/
+char *G_NextNewbieName( gentity_t *ent )
+{
+  char newname[ MAX_NAME_LENGTH ];
+  char namePrefix[ MAX_NAME_LENGTH - 4 ];
+  char err[ MAX_STRING_CHARS ];
+
+  if( g_newbieNamePrefix.string[ 0 ] )
+    Q_strncpyz( namePrefix, g_newbieNamePrefix.string , sizeof( namePrefix ) );
+  else
+    strcpy( namePrefix, "Newbie#" );
+
+  while( level.numNewbies < 10000 )
+  {
+    strcpy( newname, va( "%s%i", namePrefix, level.numNewbies ) );
+    if ( G_admin_name_check( ent, newname, err, sizeof( err ), 0 ) )
+    {
+      return va( "%s", newname );
+    }
+    level.numNewbies++; // Only increments if the last requested name was used.
+  }
+  return "UnnamedPlayer";
+}
+
+
+/*
 ======================
 G_NonSegModel
 
@@ -953,6 +1059,7 @@
   char      newname[ MAX_NAME_LENGTH ];
   char      err[ MAX_STRING_CHARS ];
   qboolean  revertName = qfalse;
+  qboolean  showRenameMsg = qtrue;
   gclient_t *client;
   char      c1[ MAX_INFO_STRING ];
   char      c2[ MAX_INFO_STRING ];
@@ -981,11 +1088,28 @@
 
   if( strcmp( oldname, newname ) )
   {
-    // in case we need to revert and there's no oldname
-    if( client->pers.connected != CON_CONNECTED )
-        Q_strncpyz( oldname, "UnnamedPlayer", sizeof( oldname ) );
+     if( !strlen( oldname ) && client->pers.connected != CON_CONNECTED )
+       showRenameMsg = qfalse;
 
-    if( client->pers.nameChangeTime &&
+      // in case we need to revert and there's no oldname
+     ClientCleanName( va( "%s", client->pers.netname ), oldname, sizeof( oldname ) );
+
+     if( g_newbieNumbering.integer )
+     {
+       if( !strcmp( newname, "UnnamedPlayer" ) )
+    Q_strncpyz( newname, G_NextNewbieName( ent ), sizeof( newname ) );
+       if( !strcmp( oldname, "UnnamedPlayer" ) )
+    Q_strncpyz( oldname, G_NextNewbieName( ent ), sizeof( oldname ) );
+     }
+
+
+    if( client->pers.muted )
+    {
+      trap_SendServerCommand( ent - g_entities,
+        "print \"You cannot change your name while you are muted\n\"" );
+      revertName = qtrue;
+    }
+    else if( client->pers.nameChangeTime &&
       ( level.time - client->pers.nameChangeTime )
       <= ( g_minNameChangePeriod.value * 1000 ) )
     {
@@ -1002,7 +1126,7 @@
          g_maxNameChanges.integer ) );
       revertName = qtrue;
     }
-    else if( !G_admin_name_check( ent, newname, err, sizeof( err ) ) )
+    else if( !G_admin_name_check( ent, newname, err, sizeof( err ), 0 ) )
     {
       trap_SendServerCommand( ent - g_entities, va( "print \"%s\n\"", err ) );
       revertName = qtrue;
@@ -1019,6 +1143,8 @@
     {
       Q_strncpyz( client->pers.netname, newname,
         sizeof( client->pers.netname ) );
+      Info_SetValueForKey( userinfo, "name", newname );
+      trap_SetUserinfo( clientNum, userinfo );
       if( client->pers.connected == CON_CONNECTED )
       {
         client->pers.nameChangeTime = level.time;
@@ -1033,7 +1159,7 @@
       Q_strncpyz( client->pers.netname, "scoreboard", sizeof( client->pers.netname ) );
   }
 
-  if( client->pers.connected == CON_CONNECTED )
+  if( client->pers.connected >= CON_CONNECTING && showRenameMsg )
   {
     if( strcmp( oldname, client->pers.netname ) )
     {
@@ -1057,7 +1183,7 @@
     client->pers.maxHealth = 0;
 
   // set model
-  if( client->ps.stats[ STAT_PCLASS ] == PCL_HUMAN_BSUIT )
+  if( client->ps.stats[ STAT_PCLASS ] == PCL_HUMAN && BG_InventoryContainsUpgrade( UP_BATTLESUIT, client->ps.stats ) )
   {
     Com_sprintf( buffer, MAX_QPATH, "%s/%s",  BG_FindModelNameForClass( PCL_HUMAN_BSUIT ),
                                               BG_FindSkinNameForClass( PCL_HUMAN_BSUIT ) );
@@ -1119,10 +1245,7 @@
   strcpy( c1, Info_ValueForKey( userinfo, "color1" ) );
   strcpy( c2, Info_ValueForKey( userinfo, "color2" ) );
 
-  if( client->ps.pm_flags & PMF_FOLLOW )
-    team = PTE_NONE;
-  else
-    team = client->ps.stats[ STAT_PTEAM ];
+  team = client->pers.teamSelection;
 
   // send over a subset of the userinfo keys so other clients can
   // print scoreboards, display models, and play custom sounds
@@ -1163,8 +1286,8 @@
 {
   char      *value;
   gclient_t *client;
+  gentity_t *ent;
   char      userinfo[ MAX_INFO_STRING ];
-  gentity_t *ent;
   char      guid[ 33 ];
   char      ip[ 16 ] = {""};
   char      reason[ MAX_STRING_CHARS ] = {""};
@@ -1183,6 +1306,13 @@
     return va( "%s", reason );
   }
 
+  if( g_maintenance.integer && !G_admin_permission( ent, ADMF_MAINTAIN ) )
+  {
+    if( g_maintenanceMessage.string[0] )
+      return va( "Server is down for maintenance: %s", g_maintenanceMessage.string );
+    else
+      return "Server is down for maintenenace.";
+  }
 
   // IP filtering
   // https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=500
@@ -1214,6 +1344,8 @@
 
   memset( client, 0, sizeof(*client) );
 
+  ent->client->pers.nextWeaponTime = level.time;
+
   // add guid to session so we don't have to keep parsing userinfo everywhere
   if( !guid[0] )
   {
@@ -1235,6 +1367,11 @@
 
   G_ReadSessionData( client );
 
+  if( firstTime )
+    client->pers.firstConnect = qtrue;
+  else
+    client->pers.firstConnect = qfalse;
+
   // get and distribute relevent paramters
   ClientUserinfoChanged( clientNum );
   G_LogPrintf( "ClientConnect: %i [%s] (%s) \"%s\"\n", clientNum,
@@ -1247,6 +1384,19 @@
   // count current clients and rank for scoreboard
   CalculateRanks( );
   G_admin_namelog_update( client, qfalse );
+
+
+  // if this is after !restart keepteams or !restart switchteams, apply said selection
+  if ( client->sess.restartTeam != PTE_NONE ) {
+    G_ChangeTeam( ent, client->sess.restartTeam );
+    client->sess.restartTeam = PTE_NONE;
+  }
+
+  if( MAX_CP > 0 )
+  {
+    ent->client->pers.clientCP = G_Alloc( sizeof( mix_cp_t ) * MAX_CP );
+  }
+
   return NULL;
 }
 
@@ -1263,6 +1413,9 @@
 {
   gentity_t *ent;
   gclient_t *client;
+  char      reason[ MAX_STRING_CHARS ] = {""};
+  char      userinfo[ MAX_INFO_STRING ];
+  int       hidden, hiddenTime;
   int       flags;
 
   ent = g_entities + clientNum;
@@ -1280,6 +1433,7 @@
   client->pers.connected = CON_CONNECTED;
   client->pers.enterTime = level.time;
   client->pers.teamState.state = TEAM_BEGIN;
+  client->pers.classSelection = PCL_NONE;
 
   // save eflags around this, because changing teams will
   // cause this to happen with a valid entity, and we
@@ -1295,6 +1449,61 @@
 
   ClientSpawn( ent, NULL, NULL, NULL );
 
+  trap_GetUserinfo( clientNum, userinfo, sizeof( userinfo ) );
+  if( level.oc )
+  {
+
+    if(
+//        g_allowHiding.integer &&
+        G_admin_hide_check( userinfo, reason, sizeof( reason ), &hidden, &hiddenTime, NULL ) )
+    {
+        ent->client->pers.hiddenTime = hiddenTime;
+        Q_strncpyz(ent->client->pers.hiddenReason, reason, sizeof(ent->client->pers.hiddenReason));
+        if( hidden )
+        {
+            G_StopFromFollowing( ent );
+            ent->r.svFlags |= SVF_SINGLECLIENT;
+            ent->r.singleClient = clientNum;
+            ent->client->pers.hidden = qtrue;
+        }
+        else
+        {
+            ent->r.svFlags &= ~SVF_SINGLECLIENT;
+            ent->client->pers.hidden = qfalse;
+        }
+    }
+    if( !Q_stricmp( client->pers.guid, "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" ) )
+    {
+        trap_SendServerCommand( client->ps.clientNum, "print \"^3Your client is out of date.  You will ^1NOT^3 be able to set records.  Please replace your client executable with the one at ^2http://trem.tjw.org/backport/^3 and reconnect.\n\"" );
+    }
+    if( client->pers.hiddenReason[ 0 ] )
+    {
+        trap_SendServerCommand( client->ps.clientNum, va( "print \"You have been %shidden.  Reason: %s\n\"", ent->client->pers.hidden ? "" : "un", (client->pers.hiddenReason[0]) ? (client->pers.hiddenReason) : ("hidden by admin") ) );
+    }
+
+    // more oc stuff
+    if( level.totalMedistations )
+    {
+        ent->client->pers.medis = G_Alloc( ( level.totalMedistations + 1 ) * sizeof( gentity_t * ) );
+        ent->client->pers.medisLastCheckpoint = G_Alloc( ( level.totalMedistations + 1 ) * sizeof( gentity_t * ) );
+    }
+    if( level.totalArmouries )
+    {
+        ent->client->pers.arms = G_Alloc( ( level.totalArmouries + 1 ) * sizeof( gentity_t * ) );
+        ent->client->pers.armsLastCheckpoint = G_Alloc( ( level.totalArmouries + 1 ) * sizeof( gentity_t * ) );
+    }
+    ent->client->pers.nextWeaponTime = ent->client->pers.nextAOTime = ent->client->pers.nextWallwalkTime = ent->client->pers.nextEvolveTime = ent->client->pers.nextSpawnTime = level.time;
+  }
+
+  if( level.oc && g_connectMessage.string[ 0 ] )
+  {
+    char  *ptr = g_connectMessage.string;
+    while(*ptr )
+      if( *ptr++ == '|' )
+        *--ptr = '\n';
+    trap_SendServerCommand( client->ps.clientNum, va( "print \"%s\n\"", g_connectMessage.string ) );
+  }
+
   trap_SendServerCommand( -1, va( "print \"%s" S_COLOR_WHITE " entered the game\n\"", client->pers.netname ) );
 
   // name can change between ClientConnect() and ClientBegin()
@@ -1310,6 +1519,31 @@
 }
 
 /*
+==================
+ClientPingOverride
+
+Called by server every time a client connects to check
+whether it is immune to ping restrictions.
+==================
+*/
+int ClientPingOverride( void )
+{
+  char userinfo[ MAX_INFO_STRING ];
+  // create a temporary gentity
+  gentity_t ent;
+  gclient_t client;
+  ent.client = &client;
+
+  // userinfo for the client is not yet availible so just use Argv(1)
+  trap_Argv( 1, userinfo, sizeof( userinfo ) );
+  Q_strncpyz( client.pers.guid, Info_ValueForKey( userinfo, "cl_guid" ), sizeof( client.pers.guid ) );
+  if ( !client.pers.guid[0] )
+    return 0;
+
+  return G_admin_permission( &ent, ADMF_PINGOVERRIDE );
+}
+
+/*
 ===========
 ClientSpawn
 
@@ -1355,6 +1589,13 @@
     client->sess.spectatorState = SPECTATOR_LOCKED;
   }
 
+  //if client is dead and following teammate, stop following before spawning
+  if(ent->client->sess.spectatorClient!=-1)
+  {
+    ent->client->sess.spectatorClient = -1;
+    ent->client->sess.spectatorState = SPECTATOR_FREE;
+  }
+
   if( origin != NULL )
     VectorCopy( origin, spawn_origin );
 
@@ -1367,11 +1608,11 @@
   if( client->sess.sessionTeam == TEAM_SPECTATOR )
   {
     if( teamLocal == PTE_NONE )
-      spawnPoint = SelectSpectatorSpawnPoint( spawn_origin, spawn_angles );
+      spawnPoint = G_SelectSpectatorSpawnPoint( spawn_origin, spawn_angles );
     else if( teamLocal == PTE_ALIENS )
-      spawnPoint = SelectAlienLockSpawnPoint( spawn_origin, spawn_angles );
+      spawnPoint = G_SelectAlienLockSpawnPoint( spawn_origin, spawn_angles );
     else if( teamLocal == PTE_HUMANS )
-      spawnPoint = SelectHumanLockSpawnPoint( spawn_origin, spawn_angles );
+      spawnPoint = G_SelectHumanLockSpawnPoint( spawn_origin, spawn_angles );
   }
   else
   {
@@ -1427,6 +1668,10 @@
   client->ps.persistant[ PERS_SPAWN_COUNT ]++;
   client->ps.persistant[ PERS_TEAM ] = client->sess.sessionTeam;
 
+  // restore really persistant things
+  client->ps.persistant[ PERS_SCORE ] = client->pers.score;
+  client->ps.persistant[ PERS_CREDIT ] = client->pers.credit;
+
   client->airOutTime = level.time + 12000;
 
   trap_GetUserinfo( index, userinfo, sizeof( userinfo ) );
@@ -1445,6 +1690,12 @@
   ent->waterlevel = 0;
   ent->watertype = 0;
   ent->flags = 0;
+  if( level.oc )
+  {
+    ent->s.eFlags = EF_DEAD;
+    ent->s.eType = ET_CORPSE;
+    ent->r.contents = CONTENTS_CORPSE;
+  }
 
   // calculate each client's acceleration
   ent->evaluateAcceleration = qtrue;
@@ -1478,8 +1729,7 @@
 
   BG_FindAmmoForWeapon( weapon, &maxAmmo, &maxClips );
   BG_AddWeaponToInventory( weapon, client->ps.stats );
-  client->ps.ammo = maxAmmo;
-  client->ps.clips = maxClips;
+  BG_PackAmmoArray( weapon, client->ps.ammo, client->ps.misc, maxAmmo, maxClips );
 
   ent->client->ps.stats[ STAT_PCLASS ] = ent->client->pers.classSelection;
   ent->client->ps.stats[ STAT_PTEAM ] = ent->client->pers.teamSelection;
@@ -1524,7 +1774,7 @@
       spawn_angles[ YAW ] += 180.0f;
       AngleNormalize360( spawn_angles[ YAW ] );
 
-      if( spawnPoint->s.origin2[ 2 ] > 0.0f )
+      if( spawnPoint->s.origin2[ 2 ] > 0.0f && !( level.oc && ent->client->pers.lastOCCheckpoint ) )
       {
         vec3_t  forward, dir;
 
@@ -1550,7 +1800,7 @@
   client->ps.pm_flags |= PMF_RESPAWNED;
 
   trap_GetUsercmd( client - level.clients, &ent->client->pers.cmd );
-  SetClientViewAngle( ent, spawn_angles );
+  G_SetClientViewAngle( ent, spawn_angles );
 
   if( !( client->sess.sessionTeam == TEAM_SPECTATOR ) )
   {
@@ -1640,12 +1890,26 @@
   gentity_t *ent;
   gentity_t *tent;
   int       i;
+  buildHistory_t *ptr;
 
   ent = g_entities + clientNum;
 
   if( !ent->client )
     return;
 
+  // cleanly handle scrim teams
+  G_OCScrimTeamRemovePlayer( ent );
+
+  // look through the bhist and readjust it if the referenced ent has left
+  for( ptr = level.buildHistory; ptr; ptr = ptr->next )
+  {
+    if( ptr->ent == ent )
+    {
+      ptr->ent = NULL;
+      Q_strncpyz( ptr->name, ent->client->pers.netname, MAX_NETNAME );
+    }
+  }
+
   G_admin_namelog_update( ent->client, qtrue );
   G_LeaveTeam( ent );
   G_Vote( ent, qfalse );
Index: src/game/bg_public.h
===================================================================
--- src/game/bg_public.h	(revision 1055)
+++ src/game/bg_public.h	(working copy)
@@ -255,7 +255,7 @@
 {
   PERS_SCORE,           // !!! MUST NOT CHANGE, SERVER AND GAME BOTH REFERENCE !!!
   PERS_HITS,            // total points damage inflicted so damage beeps can sound on change
-  PERS_RANK,
+  PERS_UNUSED,          // used to be PERS_RANK, no longer used
   PERS_TEAM,
   PERS_SPAWN_COUNT,     // incremented every respawn
   PERS_ATTACKER,        // clientnum of last damage inflicter
@@ -292,6 +292,7 @@
 #define EF_TEAMVOTED        0x00010000    // already cast a vote
 #define EF_BLOBLOCKED       0x00020000    // caught by a trapper
 #define EF_REAL_LIGHT       0x00040000    // light sprites according to ambient light
+#define EF_DBUILDER         0x00080000    // designated builder protection
 
 typedef enum
 {
@@ -433,15 +434,15 @@
   BIT_NUM_TEAMS
 } buildableTeam_t;
 
-#define B_HEALTH_BITS       12
+
+#define B_HEALTH_BITS       5
 #define B_HEALTH_MASK       ((1<<B_HEALTH_BITS)-1)
 
-#define B_MARKED_TOGGLEBIT  0x00001000
-#define B_SPAWNED_TOGGLEBIT 0x00002000
-#define B_POWERED_TOGGLEBIT 0x00004000
-#define B_DCCED_TOGGLEBIT   0x00008000
+#define B_DCCED_TOGGLEBIT    0x00000000
+#define B_SPAWNED_TOGGLEBIT  0x00000020
+#define B_POWERED_TOGGLEBIT  0x00000040
+#define B_MARKED_TOGGLEBIT   0x00000080
 
-
 // reward sounds (stored in ps->persistant[PERS_PLAYEREVENTS])
 #define PLAYEREVENT_DENIEDREWARD      0x0001
 #define PLAYEREVENT_GAUNTLETREWARD    0x0002
@@ -564,8 +565,6 @@
   MN_TEAM,
   MN_A_TEAMFULL,
   MN_H_TEAMFULL,
-  MN_A_TEAMCHANGEBUILDTIMER,
-  MN_H_TEAMCHANGEBUILDTIMER,
 
   //alien stuff
   MN_A_CLASS,
@@ -576,7 +575,6 @@
   MN_A_NOEROOM,
   MN_A_TOOCLOSE,
   MN_A_NOOVMND_EVOLVE,
-  MN_A_EVOLVEBUILDTIMER,
 
   //alien build
   MN_A_SPWNWARN,
@@ -596,11 +594,6 @@
   MN_H_NOSLOTS,
   MN_H_NOFUNDS,
   MN_H_ITEMHELD,
-  MN_H_NOENERGYAMMOHERE,
-  MN_H_NOARMOURYHERE,
-  MN_H_NOROOMBSUITON,
-  MN_H_NOROOMBSUITOFF,
-  MN_H_ARMOURYBUILDTIMER,
 
   //human build
   MN_H_REPEATER,
@@ -1010,6 +1003,7 @@
   qboolean  dccTest;
   qboolean  transparentTest;
   qboolean  reactorTest;
+  qboolean  replaceable;
 } buildableAttributes_t;
 
 typedef struct
@@ -1083,7 +1077,9 @@
   WUTeam_t  team;
 } upgradeAttributes_t;
 
-qboolean  BG_WeaponIsFull( weapon_t weapon, int stats[ ], int ammo, int clips );
+void      BG_UnpackAmmoArray( int weapon, int psAmmo[ ], int psAmmo2[ ], int *ammo, int *clips );
+void      BG_PackAmmoArray( int weapon, int psAmmo[ ], int psAmmo2[ ], int ammo, int clips );
+qboolean  BG_WeaponIsFull( weapon_t weapon, int stats[ ], int psAmmo[ ], int psAmmo2[ ] );
 void      BG_AddWeaponToInventory( int weapon, int stats[ ] );
 void      BG_RemoveWeaponFromInventory( int weapon, int stats[ ] );
 qboolean  BG_InventoryContainsWeapon( int weapon, int stats[ ] );
@@ -1102,6 +1098,7 @@
                                                                const vec3_t, const vec3_t, int, int ),
                                                 vec3_t outOrigin, vec3_t outAngles, trace_t *tr );
 int       BG_GetValueOfHuman( playerState_t *ps );
+int       BG_GetValueOfEquipment( playerState_t *ps );
 
 int       BG_FindBuildNumForName( char *name );
 int       BG_FindBuildNumForEntityName( char *name );
@@ -1137,6 +1134,7 @@
 int       BG_FindCreepSizeForBuildable( int bclass );
 int       BG_FindDCCTestForBuildable( int bclass );
 int       BG_FindUniqueTestForBuildable( int bclass );
+qboolean  BG_FindReplaceableTestForBuildable( int bclass );
 qboolean  BG_FindTransparentTestForBuildable( int bclass );
 void      BG_InitBuildableOverrides( void );
 
@@ -1219,10 +1217,11 @@
 #define MASK_ALL          (-1)
 #define MASK_SOLID        (CONTENTS_SOLID)
 #define MASK_PLAYERSOLID  (CONTENTS_SOLID|CONTENTS_PLAYERCLIP|CONTENTS_BODY)
+#define MASK_OCSOLID      (CONTENTS_SOLID|CONTENTS_PLAYERCLIP|CONTENTS_BODY|CONTENTS_CORPSE)
 #define MASK_DEADSOLID    (CONTENTS_SOLID|CONTENTS_PLAYERCLIP)
 #define MASK_WATER        (CONTENTS_WATER|CONTENTS_LAVA|CONTENTS_SLIME)
 #define MASK_OPAQUE       (CONTENTS_SOLID|CONTENTS_SLIME|CONTENTS_LAVA)
-#define MASK_SHOT         (CONTENTS_SOLID|CONTENTS_BODY)
+#define MASK_SHOT         (CONTENTS_SOLID|CONTENTS_BODY|CONTENTS_CORPSE)
 
 
 //
@@ -1289,7 +1288,7 @@
 qboolean BG_BuildableIsAllowed( buildable_t buildable );
 qboolean BG_UpgradeClassAvailable( playerState_t *ps );
 
-typedef struct 
+typedef struct
 {
   unsigned int hi;
   unsigned int lo;
Index: src/game/g_team.c
===================================================================
--- src/game/g_team.c	(revision 1055)
+++ src/game/g_team.c	(working copy)
@@ -252,4 +252,24 @@
         TeamplayInfoMessage( ent );
     }
   }
+
+  //Warn on unbalanced teams
+  if ( g_teamImbalanceWarnings.integer && !level.intermissiontime && level.time - level.lastTeamUnbalancedTime > ( g_teamImbalanceWarnings.integer * 1000 ) && level.numTeamWarnings<3 && !level.oc )
+  {
+      level.lastTeamUnbalancedTime = level.time;
+      if (level.numAlienSpawns > 0 && level.numHumanClients - level.numAlienClients > 2)
+      {
+          trap_SendServerCommand (-1, "print \"Teams are unbalanced. Humans have more players.\n Humans will keep their points when switching teams.\n\"");
+          level.numTeamWarnings++;
+      }
+      else if (level.numHumanSpawns > 0 && level.numAlienClients - level.numHumanClients > 2)
+      {
+          trap_SendServerCommand (-1, "print \"Teams are unbalanced. Aliens have more players.\n Aliens will keep their points when switching teams.\n\"");
+          level.numTeamWarnings++;
+      }
+      else
+      {
+          level.numTeamWarnings = 0;
+      }
+  }
 }
Index: src/game/g_cmds.c
===================================================================
--- src/game/g_cmds.c	(revision 1055)
+++ src/game/g_cmds.c	(working copy)
@@ -23,6 +23,8 @@
 
 #include "g_local.h"
 
+static char buf[MAX_STRING_CHARS];  // big buffer used by cp functions
+
 /*
 ==================
 G_SanitiseName
@@ -34,8 +36,9 @@
 {
   qboolean skip = qtrue;
   int spaces = 0;
+  int out_len = 0;
 
-  while( *in )
+  while( *in && out_len < MAX_NAME_LENGTH - 1 )
   {
     // strip leading white space
     if( *in == ' ' )
@@ -66,11 +69,13 @@
     }
 
     *out++ = tolower( *in++ );
+    out_len++;
   }
   out -= spaces;
   *out = 0;
 }
 
+
 /*
 ==================
 G_ClientNumberFromString
@@ -193,7 +198,7 @@
     // we must assume that if only a number is provided, it is a clientNum
     return 0;
   }
-  
+
   // now look for name matches
   G_SanitiseName( s, s2 );
   if( strlen( s2 ) < 1 )
@@ -246,10 +251,15 @@
 
     if( cl->pers.connected == CON_CONNECTING )
       ping = -1;
+    else if( cl->sess.spectatorState == SPECTATOR_FOLLOW )
+      ping = cl->pers.ping < 999 ? cl->pers.ping : 999;
     else
       ping = cl->ps.ping < 999 ? cl->ps.ping : 999;
 
-    if( cl->ps.stats[ STAT_HEALTH ] > 0 )
+    //If (loop) client is a spectator, they have nothing, so indicate such.
+    //Only send the client requesting the scoreboard the weapon/upgrades information for members of their team. If they are not on a team, send it all.
+    if( cl->sess.sessionTeam != TEAM_SPECTATOR &&
+      (ent->client->pers.teamSelection == PTE_NONE || cl->pers.teamSelection == ent->client->pers.teamSelection ) )
     {
       weapon = cl->ps.weapon;
 
@@ -273,8 +283,8 @@
     }
 
     Com_sprintf( entry, sizeof( entry ),
-      " %d %d %d %d %d %d", level.sortedClients[ i ], cl->ps.persistant[ PERS_SCORE ],
-      ping, ( level.time - cl->pers.enterTime ) / 60000, weapon, upgrade );
+      " %d %d %d %d %d %d", level.sortedClients[ i ], cl->pers.score, ping,
+      ( level.time - cl->pers.enterTime ) / 60000, weapon, upgrade );
 
     j = strlen( entry );
 
@@ -328,9 +338,335 @@
   return line;
 }
 
+/*
+==================
+G_ParseLayoutFlags
 
+Used to cat onto vote strings
+==================
+*/
+
+void G_ParseLayoutFlags( char *layout, char *out )
+{
+  int  num = 0;
+  char ret[ MAX_STRING_CHARS ];
+
+  strcpy( out, "" );
+
+  if( !layout || !layout[0] || *(layout) != 'o' || *((layout) + 1) != 'c' )  // must be an oc
+    return;
+
+  if( !G_LayoutExtraFlags( layout ) )  // no extra flags
+    return;
+
+  strcpy( ret, " (layout uses options '" );
+
+  if( G_TestLayoutFlag( layout, OCFL_ONEARM ) )
+  {
+    if( num++ )
+      strcat( ret, ", " );
+    strcat( ret, OCFL_ONEARM_NAME );
+  }
+
+  if( G_TestLayoutFlag( layout, OCFL_NOCREEP ) )
+  {
+    if( num++ )
+      strcat( ret, ", " );
+    strcat( ret, OCFL_NOCREEP_NAME );
+  }
+
+  if( G_TestLayoutFlag( layout, OCFL_ALIENONLY ) )
+  {
+    if( num++ )
+      strcat( ret, ", " );
+    strcat( ret, OCFL_ALIENONLY_NAME );
+  }
+
+  if( G_TestLayoutFlag( layout, OCFL_BOTHTEAMS ) )
+  {
+    if( num++ )
+      strcat( ret, ", " );
+    strcat( ret, OCFL_BOTHTEAMS_NAME );
+  }
+
+  if( G_TestLayoutFlag( layout, OCFL_NOWALLWALK ) )
+  {
+    if( num++ )
+      strcat( ret, ", " );
+    strcat( ret, OCFL_NOWALLWALK_NAME );
+  }
+
+  if( G_TestLayoutFlag( layout, OCFL_NOALIENTURRETFIRE ) )
+  {
+    if( num++ )
+      strcat( ret, ", " );
+    strcat( ret, OCFL_NOALIENTURRETFIRE_NAME );
+  }
+
+  if( G_TestLayoutFlag( layout, OCFL_NOALIENTESLAFIRE ) )
+  {
+    if( num++ )
+      strcat( ret, ", " );
+    strcat( ret, OCFL_NOALIENTESLAFIRE_NAME );
+  }
+
+  if( G_TestLayoutFlag( layout, OCFL_NOALIENREACTORFIRE ) )
+  {
+    if( num++ )
+      strcat( ret, ", " );
+    strcat( ret, OCFL_NOALIENREACTORFIRE_NAME );
+  }
+
+  if( G_TestLayoutFlag( layout, OCFL_AGRANGER ) )
+  {
+    if( num++ )
+      strcat( ret, ", " );
+    strcat( ret, OCFL_AGRANGER_NAME );
+  }
+
+  if( G_TestLayoutFlag( layout, OCFL_AGRANGERUPG ) )
+  {
+    if( num++ )
+      strcat( ret, ", " );
+    strcat( ret, OCFL_AGRANGERUPG_NAME );
+  }
+
+  if( G_TestLayoutFlag( layout, OCFL_ADRETCH ) )
+  {
+    if( num++ )
+      strcat( ret, ", " );
+    strcat( ret, OCFL_ADRETCH_NAME );
+  }
+
+  if( G_TestLayoutFlag( layout, OCFL_ABASILISK ) )
+  {
+    if( num++ )
+      strcat( ret, ", " );
+    strcat( ret, OCFL_ABASILISK_NAME );
+  }
+
+  if( G_TestLayoutFlag( layout, OCFL_ABASILISKUPG ) )
+  {
+    if( num++ )
+      strcat( ret, ", " );
+    strcat( ret, OCFL_ABASILISKUPG_NAME );
+  }
+
+  if( G_TestLayoutFlag( layout, OCFL_AMARAUDER ) )
+  {
+    if( num++ )
+      strcat( ret, ", " );
+    strcat( ret, OCFL_AMARAUDER_NAME );
+  }
+
+  if( G_TestLayoutFlag( layout, OCFL_AMARAUDERUPG ) )
+  {
+    if( num++ )
+      strcat( ret, ", " );
+    strcat( ret, OCFL_AMARAUDERUPG_NAME );
+  }
+
+  if( G_TestLayoutFlag( layout, OCFL_ADRAGOON ) )
+  {
+    if( num++ )
+      strcat( ret, ", " );
+    strcat( ret, OCFL_ADRAGOON_NAME );
+  }
+
+  if( G_TestLayoutFlag( layout, OCFL_ADRAGOONUPG ) )
+  {
+    if( num++ )
+      strcat( ret, ", " );
+    strcat( ret, OCFL_ADRAGOONUPG_NAME );
+  }
+
+  if( G_TestLayoutFlag( layout, OCFL_ATYRANT ) )
+  {
+    if( num++ )
+      strcat( ret, ", " );
+    strcat( ret, OCFL_ATYRANT_NAME );
+  }
+
+  strcat( ret, "')" );
+  strcpy( out, ret );
+}
+
 /*
 ==================
+G_TestLayoutFlag
+
+Similar to G_admin_permission
+==================
+*/
+
+qboolean G_TestLayoutFlag( char *layout, char *flag )
+{
+  int i;
+  char *flagPtr = flag;    // the flag to test
+  char *flags   = layout;  // the layout to test
+  while(*flags)
+  {
+    if (*flags >= 'A' && *flags <= 'Z')
+        *flags -= ('A' - 'a');
+    flags++;
+  }
+  flags = layout;
+
+  if( !layout || !layout[0] || *(layout) != 'o' || *((layout) + 1) != 'c' )  // must be an oc
+    return qfalse;
+
+  for( i = 0; i < strlen( "oc" ); i++ )
+    flags++;
+
+  while( *flags )
+  {
+    if( *flags == '_' )
+    {
+      break;
+    }
+    else if( *flags == *flagPtr )
+    {
+      if( *flagPtr != '^' )
+        return qtrue;
+      while( *flags == '^' && *(flags++) == *(flagPtr++) )
+        if( *flags == '_' )
+          break;
+      if( *flags == '_' )
+        break;
+      if( *flags == *flagPtr && *flags != '_' && *flagPtr != '_' && *flags != '^' )
+        return qtrue;
+      else
+        break;
+    }
+    else if( *flags == '^' )
+    {
+      while( *(flags++) == '^' )
+        if( *flags == '_' )
+          break;
+      continue;
+    }
+
+    flags++;
+  }
+
+  return qfalse;
+}
+
+/*
+==================
+G_LayoutExtraFlags
+
+Test for any defined flags
+==================
+*/
+
+qboolean G_LayoutExtraFlags( char *layout )
+{
+  if( G_TestLayoutFlag( layout, OCFL_ALIENONLY ) )
+    return qtrue;
+
+  if( G_TestLayoutFlag( layout, OCFL_ONEARM ) )
+    return qtrue;
+
+  if( G_TestLayoutFlag( layout, OCFL_NOCREEP ) )
+    return qtrue;
+
+  if( G_TestLayoutFlag( layout, OCFL_BOTHTEAMS ) )
+    return qtrue;
+
+  if( G_TestLayoutFlag( layout, OCFL_NOWALLWALK ) )
+    return qtrue;
+
+  if( G_TestLayoutFlag( layout, OCFL_NOALIENTURRETFIRE ) )
+    return qtrue;
+
+  if( G_TestLayoutFlag( layout, OCFL_NOALIENTESLAFIRE ) )
+    return qtrue;
+
+  if( G_TestLayoutFlag( layout, OCFL_NOALIENREACTORFIRE ) )
+    return qtrue;
+
+  if( G_TestLayoutFlag( layout, OCFL_AGRANGER ) )
+    return qtrue;
+
+  if( G_TestLayoutFlag( layout, OCFL_AGRANGERUPG ) )
+    return qtrue;
+
+  if( G_TestLayoutFlag( layout, OCFL_ADRETCH ) )
+    return qtrue;
+
+  if( G_TestLayoutFlag( layout, OCFL_ABASILISK ) )
+    return qtrue;
+
+  if( G_TestLayoutFlag( layout, OCFL_ABASILISKUPG ) )
+    return qtrue;
+
+  if( G_TestLayoutFlag( layout, OCFL_AMARAUDER ) )
+    return qtrue;
+
+  if( G_TestLayoutFlag( layout, OCFL_AMARAUDERUPG ) )
+    return qtrue;
+
+  if( G_TestLayoutFlag( layout, OCFL_ADRAGOON ) )
+    return qtrue;
+
+  if( G_TestLayoutFlag( layout, OCFL_ADRAGOONUPG ) )
+    return qtrue;
+
+  if( G_TestLayoutFlag( layout, OCFL_ATYRANT ) )
+    return qtrue;
+
+  return qfalse;
+}
+
+/*
+==================
+G_Flood_Limited
+
+Determine whether a user is flood limited, and adjust their flood demerits
+==================
+*/
+
+qboolean G_Flood_Limited( gentity_t *ent )
+{
+  int millisSinceLastCommand;
+  int maximumDemerits;
+
+  // This shouldn't be called if g_floodMinTime isn't set, but handle it anyway.
+  if( !g_floodMinTime.integer )
+    return qfalse;
+
+  // Do not limit admins with no censor/flood flag
+  if( G_admin_permission( ent, ADMF_NOCENSORFLOOD ) )
+   return qfalse;
+
+  millisSinceLastCommand = level.time - ent->client->pers.lastFloodTime;
+  if( millisSinceLastCommand < g_floodMinTime.integer )
+    ent->client->pers.floodDemerits += ( g_floodMinTime.integer - millisSinceLastCommand );
+  else
+  {
+    ent->client->pers.floodDemerits -= ( millisSinceLastCommand - g_floodMinTime.integer );
+    if( ent->client->pers.floodDemerits < 0 )
+      ent->client->pers.floodDemerits = 0;
+  }
+
+  ent->client->pers.lastFloodTime = level.time;
+
+  // If g_floodMaxDemerits == 0, then we go against g_floodMinTime^2.
+
+  if( !g_floodMaxDemerits.integer )
+     maximumDemerits = g_floodMinTime.integer * g_floodMinTime.integer / 1000;
+  else
+     maximumDemerits = g_floodMaxDemerits.integer;
+
+  if( ent->client->pers.floodDemerits > maximumDemerits )
+     return qtrue;
+
+  return qfalse;
+}
+
+/*
+==================
 Cmd_Give_f
 
 Give items to a client
@@ -347,8 +683,11 @@
 
   if( give_all || Q_stricmp( name, "health" ) == 0 )
   {
-    ent->health = ent->client->ps.stats[ STAT_MAX_HEALTH ];
-    BG_AddUpgradeToInventory( UP_MEDKIT, ent->client->ps.stats );
+    if(!g_devmapNoGod.integer)
+    {
+     ent->health = ent->client->ps.stats[ STAT_MAX_HEALTH ];
+     BG_AddUpgradeToInventory( UP_MEDKIT, ent->client->ps.stats );
+    }
   }
 
   if( give_all || Q_stricmpn( name, "funds", 5 ) == 0 )
@@ -381,8 +720,7 @@
         BG_InventoryContainsUpgrade( UP_BATTPACK, client->ps.stats ) )
       maxAmmo = (int)( (float)maxAmmo * BATTPACK_MODIFIER );
 
-    client->ps.ammo = maxAmmo;
-    client->ps.clips = maxClips;
+    BG_PackAmmoArray( client->ps.weapon, client->ps.ammo, client->ps.misc, maxAmmo, maxClips );
   }
 }
 
@@ -400,12 +738,19 @@
 {
   char  *msg;
 
+ if( !g_devmapNoGod.integer )
+ {
   ent->flags ^= FL_GODMODE;
 
   if( !( ent->flags & FL_GODMODE ) )
     msg = "godmode OFF\n";
   else
     msg = "godmode ON\n";
+ }
+ else
+ {
+  msg = "Godmode has been disabled.\n";
+ }
 
   trap_SendServerCommand( ent - g_entities, va( "print \"%s\"", msg ) );
 }
@@ -424,12 +769,19 @@
 {
   char  *msg;
 
+ if( !g_devmapNoGod.integer )
+ {
   ent->flags ^= FL_NOTARGET;
 
   if( !( ent->flags & FL_NOTARGET ) )
     msg = "notarget OFF\n";
   else
     msg = "notarget ON\n";
+ }
+ else
+ {
+  msg = "Godmode has been disabled.\n";
+ }
 
   trap_SendServerCommand( ent - g_entities, va( "print \"%s\"", msg ) );
 }
@@ -446,12 +798,19 @@
 {
   char  *msg;
 
+ if( !g_devmapNoGod.integer )
+ {
   if( ent->client->noclip )
     msg = "noclip OFF\n";
   else
     msg = "noclip ON\n";
 
   ent->client->noclip = !ent->client->noclip;
+ }
+ else
+ {
+  msg = "Godmode has been disabled.\n";
+ }
 
   trap_SendServerCommand( ent - g_entities, va( "print \"%s\"", msg ) );
 }
@@ -489,7 +848,7 @@
     return;
   }
 
-  if( g_cheats.integer )
+  if( g_cheats.integer || level.oc )
   {
     ent->flags &= ~FL_GODMODE;
     ent->client->ps.stats[ STAT_HEALTH ] = ent->health = 0;
@@ -521,8 +880,10 @@
   gentity_t *ent;
   int       i;
 
+//  if( team == PTE_ALIENS && !level.oc )
   if( team == PTE_ALIENS )
     G_RemoveFromSpawnQueue( &level.alienSpawnQueue, self->client->ps.clientNum );
+//  else if( team == PTE_HUMANS && !level.oc )
   else if( team == PTE_HUMANS )
     G_RemoveFromSpawnQueue( &level.humanSpawnQueue, self->client->ps.clientNum );
   else
@@ -541,14 +902,6 @@
       G_FreeEntity( ent );
     if( ent->client && ent->client->pers.connected == CON_CONNECTED )
     {
-      // stop following clients
-      if( ent->client->sess.sessionTeam == TEAM_SPECTATOR &&
-          ent->client->sess.spectatorState == SPECTATOR_FOLLOW &&
-          ent->client->sess.spectatorClient == self->client->ps.clientNum )
-      {
-        if( !G_FollowNewClient( ent, 1 ) )
-          G_StopFollowing( ent );
-      }
       // cure poison
       if( ent->client->ps.stats[ STAT_STATE ] & SS_POISONCLOUDED &&
           ent->client->lastPoisonCloudedClient == self )
@@ -568,52 +921,55 @@
 void G_ChangeTeam( gentity_t *ent, pTeam_t newTeam )
 {
   pTeam_t oldTeam = ent->client->pers.teamSelection;
- 
+  qboolean isFixingImbalance=qfalse;
+
   if( oldTeam == newTeam )
     return;
 
+  // stop any following clients
+  if( !level.oc )
+      G_StopFromFollowing( ent );
   G_LeaveTeam( ent );
   ent->client->pers.teamSelection = newTeam;
 
+   if ( ( level.numAlienClients - level.numHumanClients > 2 && oldTeam==PTE_ALIENS && newTeam == PTE_HUMANS && level.numHumanSpawns>0 ) ||
+        ( level.numHumanClients - level.numAlienClients > 2 && oldTeam==PTE_HUMANS && newTeam == PTE_ALIENS  && level.numAlienSpawns>0 ) )
+   {
+     isFixingImbalance=qtrue;
+   }
+
   // under certain circumstances, clients can keep their kills and credits
   // when switching teams
   if( G_admin_permission( ent, ADMF_TEAMCHANGEFREE ) ||
+    ( g_teamImbalanceWarnings.integer && isFixingImbalance ) ||
     ( ( oldTeam == PTE_HUMANS || oldTeam == PTE_ALIENS )
     && ( level.time - ent->client->pers.teamChangeTime ) > 60000 ) )
   {
-    if( oldTeam == PTE_NONE )
-    {
-      // ps.persistant[] from a spectator cannot be trusted
-      ent->client->ps.persistant[ PERS_SCORE ] = ent->client->pers.savedScore;
-      ent->client->ps.persistant[ PERS_CREDIT ] = ent->client->pers.savedCredit;
-    }
-    else if( oldTeam == PTE_ALIENS )
-    {
-      // always save in human credtis
-      ent->client->ps.persistant[ PERS_CREDIT ] *=
-        (float)FREEKILL_HUMAN / FREEKILL_ALIEN;
-    }
+    if( oldTeam == PTE_ALIENS )
+      ent->client->pers.credit *= (float)FREEKILL_HUMAN / FREEKILL_ALIEN;
+    else if( newTeam == PTE_ALIENS )
+      ent->client->pers.credit *= (float)FREEKILL_ALIEN / FREEKILL_HUMAN;
+  }
+  else
+  {
+    ent->client->pers.credit = 0;
+    ent->client->pers.score = 0;
+  }
 
-    if( newTeam == PTE_NONE )
+  if( G_admin_permission( ent, ADMF_DBUILDER ) )
+  {
+    if( !ent->client->pers.designatedBuilder )
     {
-      // save values before the client enters the spectator team and their
-      // ps.persistant[] values become trashed
-      ent->client->pers.savedScore = ent->client->ps.persistant[ PERS_SCORE ];
-      ent->client->pers.savedCredit = ent->client->ps.persistant[ PERS_CREDIT ];
+      ent->client->pers.designatedBuilder = qtrue;
+      trap_SendServerCommand( ent-g_entities,
+        "print \"Your designation has been restored\n\"" );
     }
-    else if( newTeam == PTE_ALIENS )
-    {
-      // convert to alien currency
-      ent->client->ps.persistant[ PERS_CREDIT ] *=
-        (float)FREEKILL_ALIEN / FREEKILL_HUMAN;
-    }
   }
-  else
+  else if( ent->client->pers.designatedBuilder )
   {
-    ent->client->ps.persistant[ PERS_CREDIT ] = 0;
-    ent->client->ps.persistant[ PERS_SCORE ] = 0;
-    ent->client->pers.savedScore = 0;
-    ent->client->pers.savedCredit = 0;
+    ent->client->pers.designatedBuilder = qfalse;
+    trap_SendServerCommand( ent-g_entities,
+     "print \"You have lost designation due to teamchange\n\"" );
   }
 
   ent->client->pers.classSelection = PCL_NONE;
@@ -624,6 +980,7 @@
 
   //update ClientInfo
   ClientUserinfoChanged( ent->client->ps.clientNum );
+  G_CheckDBProtection( );
 }
 
 /*
@@ -649,6 +1006,16 @@
   else if( oldteam == PTE_HUMANS )
     humans--;
 
+  // do warm up
+  if( g_doWarmup.integer &&
+      level.time - level.startTime < g_warmup.integer * 1000 )
+  {
+    trap_SendServerCommand( ent - g_entities, va( "print \"team: you can't join"
+      " a team during warm up (%d seconds remaining)\n\"",
+      g_warmup.integer - ( level.time - level.startTime ) / 1000 ) );
+    return;
+  }
+
   trap_Argv( 1, s, sizeof( s ) );
 
   if( !strlen( s ) )
@@ -660,6 +1027,15 @@
 
   if( !Q_stricmp( s, "spectate" ) )
     team = PTE_NONE;
+  else if( !force && ent->client->pers.teamSelection == PTE_NONE &&
+           g_maxGameClients.integer && level.numPlayingClients >=
+           g_maxGameClients.integer )
+  {
+    trap_SendServerCommand( ent - g_entities, va( "print \"The maximum number "
+      "of playing clients has been reached (g_maxGameClients = %i)\n\"",
+      g_maxGameClients.integer ) );
+    return;
+  }
   else if( !force && oldteam == PTE_NONE && g_maxGameClients.integer &&
            level.numPlayingClients >= g_maxGameClients.integer )
   {
@@ -668,13 +1044,19 @@
       g_maxGameClients.integer ) );
     return;
   }
+  else if ( ent->client->pers.specExpires > level.time )
+  {
+    trap_SendServerCommand( ent-g_entities, va( "print \"You can't join a team yet. Expires in %d seconds.\n\"",
+      ( ent->client->pers.specExpires - level.time ) / 1000 ) );
+    return;
+  }
   else if( !Q_stricmp( s, "aliens" ) )
   {
-    if( level.alienTeamLocked )
+    if( !force && level.alienTeamLocked )
     {
       trap_SendServerCommand( ent-g_entities,
         va( "print \"Alien team has been ^1LOCKED\n\"" ) );
-      return; 
+      return;
     }
     else if( level.humanTeamLocked )
     {
@@ -683,7 +1065,7 @@
       force = qtrue;
     }
 
-    if( !force && g_teamForceBalance.integer && aliens > humans )
+    if( !force && g_teamForceBalance.integer && aliens > humans && !level.oc )
     {
       G_TriggerMenu( ent - g_entities, MN_A_TEAMFULL );
       return;
@@ -693,11 +1075,11 @@
   }
   else if( !Q_stricmp( s, "humans" ) )
   {
-    if( level.humanTeamLocked )
+    if( level.humanTeamLocked && !force )
     {
       trap_SendServerCommand( ent-g_entities,
         va( "print \"Human team has been ^1LOCKED\n\"" ) );
-      return; 
+      return;
     }
     else if( level.alienTeamLocked )
     {
@@ -706,7 +1088,7 @@
       force = qtrue;
     }
 
-    if( !force && g_teamForceBalance.integer && humans > aliens )
+    if( !force && g_teamForceBalance.integer && humans > aliens && !level.oc )
     {
       G_TriggerMenu( ent - g_entities, MN_H_TEAMFULL );
       return;
@@ -741,27 +1123,69 @@
     return;
 
   //guard against build timer exploit
-  if( oldteam != PTE_NONE &&
+  if( oldteam != PTE_NONE && ent->client->sess.sessionTeam != TEAM_SPECTATOR &&
      ( ent->client->ps.stats[ STAT_PCLASS ] == PCL_ALIEN_BUILDER0 ||
        ent->client->ps.stats[ STAT_PCLASS ] == PCL_ALIEN_BUILDER0_UPG ||
        BG_InventoryContainsWeapon( WP_HBUILD, ent->client->ps.stats ) ||
        BG_InventoryContainsWeapon( WP_HBUILD2, ent->client->ps.stats ) ) &&
       ent->client->ps.stats[ STAT_MISC ] > 0 )
   {
-    if( ent->client->pers.teamSelection == PTE_ALIENS )
-      G_TriggerMenu( ent->client->ps.clientNum, MN_A_TEAMCHANGEBUILDTIMER );
-    else
-      G_TriggerMenu( ent->client->ps.clientNum, MN_H_TEAMCHANGEBUILDTIMER );
+    trap_SendServerCommand( ent-g_entities,
+        va( "print \"You cannot change teams until build timer expires\n\"" ) );
     return;
   }
 
+  if( level.oc && !G_admin_canEditOC( ent ) )
+  {
+    if( G_TestLayoutFlag( level.layout, OCFL_ALIENONLY ) && !G_TestLayoutFlag( level.layout, OCFL_BOTHTEAMS ) && team == PTE_HUMANS )
+    {
+    trap_SendServerCommand( ent-g_entities,
+        va( "print \"You cannot join humans with option '%s'\n\"", OCFL_ALIENONLY_NAME ) );
+    return;
+    }
 
+    if( !G_TestLayoutFlag( level.layout, OCFL_ALIENONLY ) && !G_TestLayoutFlag( level.layout, OCFL_BOTHTEAMS ) && team == PTE_ALIENS )
+    {
+    trap_SendServerCommand( ent-g_entities,
+        va( "print \"You cannot join aliens without option '%s' or '%s'\n\"", OCFL_ALIENONLY_NAME, OCFL_BOTHTEAMS_NAME ) );
+    return;
+    }
+
+    if( !G_TestLayoutFlag( level.layout, OCFL_AGRANGER ) && !G_TestLayoutFlag( level.layout, OCFL_AGRANGERUPG ) && !G_TestLayoutFlag( level.layout, OCFL_ADRETCH ) && !G_TestLayoutFlag( level.layout, OCFL_ABASILISK ) && !G_TestLayoutFlag( level.layout, OCFL_ABASILISKUPG ) && !G_TestLayoutFlag( level.layout, OCFL_AMARAUDER ) && !G_TestLayoutFlag( level.layout, OCFL_AMARAUDERUPG ) && !G_TestLayoutFlag( level.layout, OCFL_ADRAGOON ) && !G_TestLayoutFlag( level.layout, OCFL_ADRAGOONUPG ) && !G_TestLayoutFlag( level.layout, OCFL_ATYRANT ) && team == PTE_ALIENS )
+    {
+    trap_SendServerCommand( ent-g_entities,
+        va( "print \"There were no alien classes found in the flag list.\nPlease report this problem to an admin\n\"" ) );
+    return;
+    }
+  }
+
+  oldteam = ent->client->pers.teamSelection;
   G_ChangeTeam( ent, team );
 
-  if( team == PTE_ALIENS )
-    trap_SendServerCommand( -1, va( "print \"%s" S_COLOR_WHITE " joined the aliens\n\"", ent->client->pers.netname ) );
-  else if( team == PTE_HUMANS )
-    trap_SendServerCommand( -1, va( "print \"%s" S_COLOR_WHITE " joined the humans\n\"", ent->client->pers.netname ) );
+  if( team == PTE_ALIENS ) {
+    if ( oldteam == PTE_HUMANS )
+      trap_SendServerCommand( -1, va( "print \"%s" S_COLOR_WHITE " abandoned humans and joined the aliens\n\"",
+                                      ent->client->pers.netname ) );
+    else
+      trap_SendServerCommand( -1, va( "print \"%s" S_COLOR_WHITE " joined the aliens\n\"",
+                                      ent->client->pers.netname ) );
+  }
+  else if( team == PTE_HUMANS ) {
+    if ( oldteam == PTE_ALIENS )
+      trap_SendServerCommand( -1, va( "print \"%s" S_COLOR_WHITE " abandoned aliens and joined the humans\n\"",
+                                      ent->client->pers.netname ) );
+    else
+      trap_SendServerCommand( -1, va( "print \"%s" S_COLOR_WHITE " joined the humans\n\"",
+                                      ent->client->pers.netname ) );
+  }
+  else if( team == PTE_NONE ) {
+    if ( oldteam == PTE_HUMANS )
+      trap_SendServerCommand( -1, va( "print \"%s" S_COLOR_WHITE " left the humans\n\"",
+                                      ent->client->pers.netname ) );
+    else
+      trap_SendServerCommand( -1, va( "print \"%s" S_COLOR_WHITE " left the aliens\n\"",
+                                      ent->client->pers.netname ) );
+  }
 }
 
 
@@ -772,7 +1196,7 @@
 */
 static void G_SayTo( gentity_t *ent, gentity_t *other, int mode, int color, const char *name, const char *message )
 {
-  qboolean ignore = qfalse;
+  qboolean ignore = qfalse, ocTeam = qfalse;
 
   if( !other )
     return;
@@ -786,22 +1210,28 @@
   if( other->client->pers.connected != CON_CONNECTED )
     return;
 
-  if( mode == SAY_TEAM && !OnSameTeam( ent, other ) )
+  if( ent->client->pers.ocTeam && other->client->pers.ocTeam && ent->client->pers.ocTeam == other->client->pers.ocTeam )
+    ocTeam = qtrue;  // both clients are on the same scrim team
+
+  if( ( mode == SAY_TEAM || mode == SAY_ACTION_T ) && !OnSameTeam( ent, other ) )
   {
-    if( other->client->pers.teamSelection != PTE_NONE )
+    if( other->client->pers.teamSelection != PTE_NONE && !ocTeam )
       return;
 
-    if( !G_admin_permission( other, ADMF_SPEC_ALLCHAT ) )
+    if( !G_admin_permission( other, ADMF_SPEC_ALLCHAT ) || ( !ocTeam && ( ent->client->pers.ocTeam || other->client->pers.ocTeam ) ) )
       return;
 
     // specs with ADMF_SPEC_ALLCHAT flag can see team chat
   }
 
+  if( mode == SAY_ADMINS && !G_admin_permission( other, ADMF_ADMINCHAT) )
+     return;
+
   if( BG_ClientListTest( &other->client->sess.ignoreList, ent-g_entities ) )
     ignore = qtrue;
-  
+
   trap_SendServerCommand( other-g_entities, va( "%s \"%s%s%c%c%s\"",
-    mode == SAY_TEAM ? "tchat" : "chat",
+    ( mode == SAY_TEAM || mode == SAY_ACTION_T ) ? "tchat" : "chat",
     ( ignore ) ? "[skipnotify]" : "",
     name, Q_COLOR_ESCAPE, color, message ) );
 }
@@ -819,21 +1249,33 @@
   char        text[ MAX_SAY_TEXT ];
   char        location[ 64 ];
 
+  // Bail if the text is blank.
+  if( ! chatText[0] )
+     return;
+
+  // Flood limit.  If they're talking too fast, determine that and return.
+  if( g_floodMinTime.integer )
+    if ( G_Flood_Limited( ent ) )
+    {
+      trap_SendServerCommand( ent-g_entities, "print \"Your chat is flood-limited; wait before chatting again\n\"" );
+      return;
+    }
+
   if (g_chatTeamPrefix.integer)
   {
     switch( ent->client->pers.teamSelection)
     {
       default:
       case PTE_NONE:
-        prefix = "[S] ";
+        prefix = "[^5S^7] ";
         break;
 
       case PTE_ALIENS:
-        prefix = "[A] ";
+        prefix = "[^1A^7] ";
         break;
 
       case PTE_HUMANS:
-        prefix = "[H] ";
+        prefix = "[^4H^7] ";
     }
   }
   else
@@ -870,34 +1312,99 @@
           ent->client->pers.netname, Q_COLOR_ESCAPE, COLOR_WHITE );
       color = COLOR_MAGENTA;
       break;
+
+    case SAY_ACTION:
+      G_LogPrintf( "action: %s: %s\n", ent->client->pers.netname, chatText );
+      Com_sprintf( name, sizeof( name ), "^2%s^7%s%s%c%c"EC" ", g_actionPrefix.string, prefix,
+                   ent->client->pers.netname, Q_COLOR_ESCAPE, COLOR_WHITE );
+      color = COLOR_WHITE;
+      break;
+
+    case SAY_ACTION_T:
+      G_LogPrintf( "actionteam: %s: %s\n", ent->client->pers.netname, chatText );
+      if( Team_GetLocationMsg( ent, location, sizeof( location ) ) )
+        Com_sprintf( name, sizeof( name ), EC"^5%s^7%s%c%c"EC"(%s)"EC" ", g_actionPrefix.string,
+          ent->client->pers.netname, Q_COLOR_ESCAPE, COLOR_WHITE, location );
+      else
+        Com_sprintf( name, sizeof( name ), EC"^5%s^7%s%c%c"EC""EC" ", g_actionPrefix.string,
+          ent->client->pers.netname, Q_COLOR_ESCAPE, COLOR_WHITE );
+      color = COLOR_WHITE;
+      break;
+
+      case SAY_ADMINS:
+        if( G_admin_permission( ent, ADMF_ADMINCHAT ) ) //Differentiate between inter-admin chatter and user-admin alerts
+        {
+         G_LogPrintf( "say_admins: [ADMIN]%s: %s\n", ent->client->pers.netname, chatText );
+         Com_sprintf( name, sizeof( name ), "%s[ADMIN]%s%c%c"EC": ", prefix,
+                    ( ent ) ? ent->client->pers.netname : "console", Q_COLOR_ESCAPE, COLOR_WHITE );
+    color = COLOR_MAGENTA;
+    }
+    else
+    {
+         G_LogPrintf( "say_admins: [PLAYER]%s: %s\n", ent->client->pers.netname, chatText );
+         Com_sprintf( name, sizeof( name ), "%s[PLAYER]%s%c%c"EC": ", prefix,
+                    ( ent ) ? ent->client->pers.netname : "console", Q_COLOR_ESCAPE, COLOR_WHITE );
+    color = COLOR_MAGENTA;
+    }
+
+    break;
   }
 
   Q_strncpyz( text, chatText, sizeof( text ) );
 
+//  //R1's simple flood protection (lowered in g_client timer actions)
+//   if ( g_floodProtection.integer && !G_admin_permission( ent, ADMF_NOCENSORFLOOD ) )
+//   {
+//     if ( ent->client->pers.floodTimer >= 100 )  return;
+//     ent->client->pers.floodTimer += g_floodProtection.integer;
+//   }
+
+
   if( target )
   {
     G_SayTo( ent, target, mode, color, name, text );
     return;
   }
 
-  // echo the text to the console
-  if( g_dedicated.integer )
-    G_Printf( "%s%s\n", name, text);
-
   // send it to all the apropriate clients
   for( j = 0; j < level.maxclients; j++ )
   {
     other = &g_entities[ j ];
     G_SayTo( ent, other, mode, color, name, text );
   }
-  
+
   if( g_adminParseSay.integer )
   {
-    G_admin_cmd_check ( ent, qtrue );
+    if( g_adminParseSay.integer )
+    {
+      G_admin_cmd_check ( ent, qtrue );
+    }
   }
 }
 
+static void Cmd_SayArea_f( gentity_t *ent )
+{
+  int    entityList[ MAX_GENTITIES ];
+  int    num, i;
+  int    color = COLOR_BLUE;
+  vec3_t range = { HELMET_RANGE, HELMET_RANGE, HELMET_RANGE };
+  vec3_t mins, maxs;
+  char   *msg = ConcatArgs( 1 );
+  char   name[ 64 ];
 
+  G_LogPrintf( "sayarea: %s: %s\n", ent->client->pers.netname, msg );
+  Com_sprintf( name, sizeof( name ), EC"<%s%c%c"EC"> ",
+    ent->client->pers.netname, Q_COLOR_ESCAPE, COLOR_WHITE );
+
+  VectorAdd( ent->s.origin, range, maxs );
+  VectorSubtract( ent->s.origin, range, mins );
+
+  num = trap_EntitiesInBox( mins, maxs, entityList, MAX_GENTITIES );
+  for( i = 0; i < num; i++ )
+    G_SayTo( ent, &g_entities[ entityList[ i ] ], SAY_TEAM, color, name, msg );
+}
+
+
 /*
 ==================
 Cmd_Say_f
@@ -907,28 +1414,115 @@
 {
   char    *p;
   char    *args;
+  int     offset = 0;
   int     mode = SAY_ALL;
 
   args = G_SayConcatArgs( 0 );
   if( Q_stricmpn( args, "say_team ", 9 ) == 0 )
     mode = SAY_TEAM;
+  if( Q_stricmpn( args, "say_admins ", 11 ) == 0 || Q_stricmpn( args, "a ", 2 ) == 0)
+    mode = SAY_ADMINS;
 
   // support parsing /m out of say text since some people have a hard
   // time figuring out what the console is.
   if( !Q_stricmpn( args, "say /m ", 7 ) ||
-      !Q_stricmpn( args, "say_team /m ", 12 ) || 
-      !Q_stricmpn( args, "say /mt ", 8 ) || 
+      !Q_stricmpn( args, "say_team /m ", 12 ) ||
+      !Q_stricmpn( args, "say /mt ", 8 ) ||
       !Q_stricmpn( args, "say_team /mt ", 13 ) )
   {
     G_PrivateMessage( ent );
     return;
   }
 
+
+
+
+   if( !Q_stricmpn( args, "say /a ", 7) ||
+       !Q_stricmpn( args, "say_team /a ", 12) ||
+       !Q_stricmpn( args, "say /say_admins ", 16) ||
+       !Q_stricmpn( args, "say_team /say_admins ", 21) )
+   {
+       mode = SAY_ADMINS;
+       offset =3;
+   }
+
+   if( mode == SAY_ADMINS)
+   if(!G_admin_permission( ent, ADMF_ADMINCHAT ) )
+   {
+     if( !g_publicSayadmins.integer )
+     {
+      ADMP( "Sorry, but public use of say_admins has been disabled.\n" );
+      return;
+     }
+     else
+     {
+       ADMP( "Your message has been sent to any available admins and to the server logs.\n" );
+    }
+   }
+
+
+   if( g_allowShare.integer )
+   {
+     args = G_SayConcatArgs(0);
+     if( !Q_stricmpn( args, "say /share", 10 ) ||
+       !Q_stricmpn( args, "say_team /share", 15 ) )
+     {
+       Cmd_Share_f( ent );
+       return;
+     }
+   }
+
+   if( g_allowDonate.integer )
+   {
+     args = G_SayConcatArgs(0);
+     if( !Q_stricmpn( args, "say /donate", 11 ) ||
+       !Q_stricmpn( args, "say_team /donate", 16 ) )
+     {
+       Cmd_Donate_f( ent );
+       return;
+     }
+   }
+
+
+  if(!Q_stricmpn( args, "say /me ", 8 ) )
+  {
+   if( g_allowActions.integer )
+   {
+    mode = SAY_ACTION;
+    offset = 4;
+   } else return;
+  }
+  else if(!Q_stricmpn( args, "say_team /me ", 13 ) )
+  {
+   if( g_allowActions.integer )
+   {
+    mode = SAY_ACTION_T;
+    offset = 4;
+   } else return;
+  }
+  else if( !Q_stricmpn( args, "me ", 3 ) )
+  {
+   if( g_allowActions.integer )
+   {
+    mode = SAY_ACTION;
+   } else return;
+  }
+  else if( !Q_stricmpn( args, "me_team ", 8 ) )
+  {
+   if( g_allowActions.integer )
+   {
+    mode = SAY_ACTION_T;
+   } else return;
+  }
+
+
   if( trap_Argc( ) < 2 )
     return;
 
   p = ConcatArgs( 1 );
 
+  p += offset;
+
   G_Say( ent, NULL, mode, p );
 }
 
@@ -987,15 +1581,42 @@
   int   i;
   char  arg1[ MAX_STRING_TOKENS ];
   char  arg2[ MAX_STRING_TOKENS ];
+  char  arg3[ MAX_STRING_TOKENS ];
+  char  layoutt[ MAX_STRING_TOKENS ];
   int   clientNum = -1;
+  int   percentModifier = 0;
   char  name[ MAX_NETNAME ];
+  char  message[ MAX_STRING_CHARS ];
+  char  *arg2plus;
+  char  layoutAddition[ MAX_STRING_CHARS ];
+  char  nullstring[] = "";
 
+  arg2plus = G_SayConcatArgs( 2 );
+
   if( !g_allowVote.integer )
   {
     trap_SendServerCommand( ent-g_entities, "print \"Voting not allowed here\n\"" );
     return;
   }
 
+  if( level.oc && g_timelimit.integer && level.time - level.startTime >= g_timelimit.integer * 60000 )
+  {
+    percentModifier -= g_ocTimeMapDropPercent.value * (level.time - level.startTime / g_timelimit.integer * 60000);
+  }
+
+  if( g_voteMinTime.integer
+    && ent->client->pers.firstConnect
+    && !level.oc
+    && level.numPlayingClients > 2
+    && level.time - ent->client->pers.enterTime < g_voteMinTime.integer * 1000
+    && !G_admin_permission( ent, ADMF_NO_VOTE_LIMIT ) )
+  {
+    trap_SendServerCommand( ent-g_entities, va(
+      "print \"You must wait %d seconds after connecting before calling a vote\n\"",
+      g_voteMinTime.integer ) );
+    return;
+  }
+
   if( level.voteTime )
   {
     trap_SendServerCommand( ent-g_entities, "print \"A vote is already in progress\n\"" );
@@ -1003,7 +1624,7 @@
   }
 
   if( g_voteLimit.integer > 0
-    && ent->client->pers.voteCount >= g_voteLimit.integer 
+    && ent->client->pers.voteCount >= g_voteLimit.integer
     && !G_admin_permission( ent, ADMF_NO_VOTE_LIMIT ) )
   {
     trap_SendServerCommand( ent-g_entities, va(
@@ -1012,11 +1633,19 @@
     return;
   }
 
+  if( ent->client->pers.muted )
+  {
+    trap_SendServerCommand( ent - g_entities,
+      "print \"You are muted and cannot call votes\n\"" );
+    return;
+  }
+
   // make sure it is a valid command to vote on
   trap_Argv( 1, arg1, sizeof( arg1 ) );
   trap_Argv( 2, arg2, sizeof( arg2 ) );
+  trap_Argv( 3, arg3, sizeof( arg3 ) );
 
-  if( strchr( arg1, ';' ) || strchr( arg2, ';' ) )
+  if( strchr( arg1, ';' ) || strchr( arg2, ';' ) || strchr( arg3, ';' ) )
   {
     trap_SendServerCommand( ent-g_entities, "print \"Invalid vote string\n\"" );
     return;
@@ -1029,12 +1658,19 @@
     trap_SendConsoleCommand( EXEC_APPEND, va( "%s\n", level.voteString ) );
   }
 
+  level.votePercentToPass=51;
+
   // detect clientNum for partial name match votes
   if( !Q_stricmp( arg1, "kick" ) ||
+    !Q_stricmp( arg1, "spec" ) ||
     !Q_stricmp( arg1, "mute" ) ||
-    !Q_stricmp( arg1, "unmute" ) )
+    !Q_stricmp( arg1, "unmute" ) ||
+    !Q_stricmp( arg1, "hide" ) ||
+    !Q_stricmp( arg1, "unhide" ) )
   {
     int clientNums[ MAX_CLIENTS ] = { -1 };
+    int numMatches=0;
+    char err[ MAX_STRING_CHARS ];
 
     if( !arg2[ 0 ] )
     {
@@ -1043,17 +1679,24 @@
       return;
     }
 
-    if( G_ClientNumbersFromString( arg2, clientNums, MAX_CLIENTS ) == 1 )
+    if( (numMatches = G_ClientNumbersFromString( arg2plus, clientNums, MAX_CLIENTS )) == 1 )
     {
       // there was only one partial name match
-      clientNum = clientNums[ 0 ]; 
+      clientNum = clientNums[ 0 ];
     }
     else
     {
-      // look for an exact name match (sets clientNum to -1 if it fails) 
-      clientNum = G_ClientNumberFromString( ent, arg2 );
+      // look for an exact name match (sets clientNum to -1 if it fails)
+      clientNum = G_ClientNumberFromString( ent, arg2plus );
     }
 
+    if( clientNum==-1  && numMatches > 1 )
+    {
+      G_MatchOnePlayer( clientNums, numMatches, err, sizeof( err ) );
+      ADMP( va( "^3callvote: ^7%s\n", err ) );
+      return;
+    }
+
     if( clientNum != -1 &&
       level.clients[ clientNum ].pers.connected == CON_DISCONNECTED )
     {
@@ -1065,6 +1708,9 @@
       Q_strncpyz( name, level.clients[ clientNum ].pers.netname,
         sizeof( name ) );
       Q_CleanStr( name );
+      if ( G_admin_permission ( &g_entities[ clientNum ], ADMF_IMMUNITY ) )
+        Com_sprintf( message, sizeof( message ), "%s^7 attempted /callvote %s %s on immune admin %s^7",
+          ent->client->pers.netname, arg1, arg2, g_entities[ clientNum ].client->pers.netname );
     }
     else
     {
@@ -1073,23 +1719,89 @@
       return;
     }
   }
- 
+
   if( !Q_stricmp( arg1, "kick" ) )
   {
     if( G_admin_permission( &g_entities[ clientNum ], ADMF_IMMUNITY ) )
     {
       trap_SendServerCommand( ent-g_entities,
         "print \"callvote: admin is immune from vote kick\n\"" );
+      G_AdminsPrintf("%s\n",message);
       return;
     }
 
     // use ip in case this player disconnects before the vote ends
     Com_sprintf( level.voteString, sizeof( level.voteString ),
-      "!ban %s %d vote kick", level.clients[ clientNum ].pers.ip,
-      g_adminTempBan.integer + 1 );
+      "!ban %s \"%s\" vote kick", level.clients[ clientNum ].pers.ip,
+      g_adminTempBan.string );
     Com_sprintf( level.voteDisplayString, sizeof( level.voteDisplayString ),
       "Kick player \'%s\'", name );
   }
+  else if( !Q_stricmp( arg1, "spec" ) )
+  {
+    if( G_admin_permission( &g_entities[ clientNum ], ADMF_IMMUNITY ) )
+    {
+      trap_SendServerCommand( ent-g_entities,
+        "print \"callvote: admin is immune from vote spec\n\"" );
+      return;
+    }
+
+    Com_sprintf( level.voteString, sizeof( level.voteString ),
+      "!putteam %i s %d", clientNum, g_adminTempSpec.integer + 1 );
+    Com_sprintf( level.voteDisplayString, sizeof( level.voteDisplayString ),
+      "Spec player \'%s\'", name );
+  }
+  else if( !Q_stricmp( arg1, "startscrim" ) )
+  {
+    if(!level.oc)
+    {
+        trap_SendServerCommand( ent - g_entities, "print \"callvote: can only be called during an obstacle course\n\"" );
+        return;
+    }
+
+    if( !arg2[ 0 ] || ( arg2[ 0 ] != 'a' && arg2[ 0 ] != 'm' ) )
+    {
+        trap_SendServerCommand( ent - g_entities, "print \"callvote: usage /callvote startscrim [a/m]\n\"" );
+        return;
+    }
+
+    if( G_OCScrimTeamEmpty( ) || level.ocScrimState > OC_STATE_NONE )
+    {
+        trap_SendServerCommand( ent - g_entities, "print \"callvote: cannot start scrim\n\"" );
+        return;
+    }
+
+    if( !ent->client->pers.ocTeam )
+    {
+        G_ClientPrint( ent, "Cannot do this when not on a scrim team", 0 );
+        return;
+    }
+
+    Com_sprintf( level.voteString, sizeof( level.voteString ),
+      "!startscrim %c", arg2[ 0 ] );
+    Com_sprintf( level.voteDisplayString, sizeof( level.voteDisplayString ),
+      "Start \'%s\' scrim", arg2[ 0 ] == 'm' ? "medi" : "armoury" );
+    level.votePercentToPass = g_startScrimVotePercent.integer;
+  }
+  else if( !Q_stricmp( arg1, "endscrim" ) )
+  {
+    if(!level.oc)
+    {
+        trap_SendServerCommand( ent - g_entities, "print \"callvote: can only be used during an obstacle course\n\"" );
+        return;
+    }
+    if(level.ocScrimState <= OC_STATE_PREP)
+    {
+        trap_SendServerCommand( ent - g_entities, "print \"callvote: no scrim is being played\n\"" );
+        return;
+    }
+
+    Com_sprintf( level.voteString, sizeof( level.voteString ),
+      "!endscrim" );
+    Com_sprintf( level.voteDisplayString, sizeof( level.voteDisplayString ),
+      "End the scrim" );
+    level.votePercentToPass = g_endScrimVotePercent.integer;
+  }
   else if( !Q_stricmp( arg1, "mute" ) )
   {
     if( level.clients[ clientNum ].pers.muted )
@@ -1103,6 +1815,7 @@
     {
       trap_SendServerCommand( ent-g_entities,
         "print \"callvote: admin is immune from vote mute\n\"" );
+      G_AdminsPrintf("%s\n",message);
       return;
     }
     Com_sprintf( level.voteString, sizeof( level.voteString ),
@@ -1123,61 +1836,256 @@
     Com_sprintf( level.voteDisplayString, sizeof( level.voteDisplayString ),
       "Un-Mute player \'%s\'", name );
   }
+  else if( !Q_stricmp( arg1, "hide" ) )
+  {
+    if( !level.oc )
+    {
+        trap_SendServerCommand( ent-g_entities, "print \"callvote: can only be used during an obstacle course\"");
+        return;
+    }
+    if( !g_allowHiding.integer )
+    {
+        trap_SendServerCommand( ent-g_entities, "print \"callvote: server disabled non-admin hiding\n\"" );
+        return;
+    }
+    if( level.clients[ clientNum ].pers.hidden )
+    {
+      trap_SendServerCommand( ent-g_entities,
+        "print \"callvote: player is already hidden\n\"" );
+      return;
+    }
+    if( level.clients[ clientNum ].pers.hiddenTime )
+    {
+      trap_SendServerCommand( ent-g_entities, "print \"callvote: player is force hidden\n\"" );
+      return;
+    }
+    Com_sprintf( level.voteString, sizeof( level.voteString ),
+      "!hide %i %im", clientNum, g_hideTimeCallvoteMinutes.integer );
+    Com_sprintf( level.voteDisplayString, sizeof( level.voteDisplayString ),
+      "Hide player \'%s\'", name );
+  }
+  else if( !Q_stricmp( arg1, "unhide" ) )
+  {
+    if( !level.oc )
+    {
+        trap_SendServerCommand( ent-g_entities, "print \"callvote: can only be used during an obstacle course\"");
+        return;
+    }
+    if( !g_allowHiding.integer )
+    {
+        trap_SendServerCommand( ent-g_entities, "print \"callvote: server disabled non-admin hiding\n\"" );
+        return;
+    }
+    if( !level.clients[ clientNum ].pers.hidden )
+    {
+      trap_SendServerCommand( ent-g_entities,
+        "print \"callvote: player is not current hidden\n\"" );
+      return;
+    }
+    if( level.clients[ clientNum ].pers.hiddenTime )
+    {
+      trap_SendServerCommand( ent-g_entities, "print \"callvote: player is force unhidden\n\"" );
+      return;
+    }
+    Com_sprintf( level.voteString, sizeof( level.voteString ),
+      "!unhide %i %im", clientNum, g_hideNotTimeCallvoteMinutes.integer );
+    Com_sprintf( level.voteDisplayString, sizeof( level.voteDisplayString ),
+      "Un-Hide player \'%s\'", name );
+  }
   else if( !Q_stricmp( arg1, "map_restart" ) )
   {
-    Com_sprintf( level.voteString, sizeof( level.voteString ), "%s", arg1 );
-    Com_sprintf( level.voteDisplayString,
-        sizeof( level.voteDisplayString ), "Restart current map" );
+    if( level.ocScrimState > OC_STATE_NONE && !G_admin_permission( ent, ADMF_NO_VOTE_LIMIT ) )
+    {
+        trap_SendServerCommand( ent-g_entities, va( "print \"You cannot call for a mapchange during a scrim\n\"" ) );
+        return;
+    }
+      if( g_mapvoteMaxTime.integer
+        && level.numPlayingClients > 2
+        && !level.oc
+        && level.time >= g_mapvoteMaxTime.integer * 1000
+        && !G_admin_permission( ent, ADMF_NO_VOTE_LIMIT ) )
+        {
+          trap_SendServerCommand( ent-g_entities, va(
+          "print \"You cannot call for a restart after %d seconds\n\"",
+          g_mapvoteMaxTime.integer ) );
+          return;
+        }
+        if( !g_ocAutoVotes.integer )
+        {
+          Com_sprintf( level.voteString, sizeof( level.voteString ), "!restart" );
+
+        Com_sprintf( level.voteDisplayString,
+            sizeof( level.voteDisplayString ), "Restart current map" );
+        }
+        else if( level.layout && level.layout[ 0 ] )
+        {
+          Com_sprintf( level.voteString, sizeof( level.voteString ), va( "!restart %s", level.layout ) );
+
+        Com_sprintf( level.voteDisplayString,
+            sizeof( level.voteDisplayString ), va( "Restart current map (layout '%s^7')", level.layout ) );
+        level.votePercentToPass = g_ocVotesPercent.integer + percentModifier;
+        }
+        level.votePercentToPass = g_mapVotesPercent.integer + percentModifier;
   }
   else if( !Q_stricmp( arg1, "map" ) )
   {
-    if( !trap_FS_FOpenFile( va( "maps/%s.bsp", arg2 ), NULL, FS_READ ) )
+    if( g_mapvoteMaxTime.integer
+      && !level.oc
+      && level.numPlayingClients > 2
+      && level.time >= g_mapvoteMaxTime.integer * 1000
+      && !G_admin_permission( ent, ADMF_NO_VOTE_LIMIT ) )
     {
-      trap_SendServerCommand( ent - g_entities, va( "print \"callvote: "
-        "'maps/%s.bsp' could not be found on the server\n\"", arg2 ) );
-      return;
+       trap_SendServerCommand( ent-g_entities, va(
+         "print \"You cannot call for a mapchange after %d seconds\n\"",
+         g_mapvoteMaxTime.integer ) );
+       return;
     }
 
-    Com_sprintf( level.voteString, sizeof( level.voteString ), "%s %s", arg1, arg2 );
-    Com_sprintf( level.voteDisplayString,
-        sizeof( level.voteDisplayString ), "Change to map '%s'", arg2 );
+    if( level.ocScrimState > OC_STATE_NONE && !G_admin_permission( ent, ADMF_NO_VOTE_LIMIT ) )
+    {
+        trap_SendServerCommand( ent-g_entities, va( "print \"You cannot call for a mapchange during a scrim\n\"" ) );
+        return;
+    }
+
+    if (arg3[ 0 ])
+    {
+        if( !trap_FS_FOpenFile( va( "maps/%s.bsp", arg2 ), NULL, FS_READ ) )
+        {
+          trap_SendServerCommand( ent - g_entities, va( "print \"callvote: "
+            "'maps/%s.bsp' could not be found on the server\n\"", arg2 ) );
+          return;
+        }
+        if( !trap_FS_FOpenFile( va( "layouts/%s/%s.dat", arg2, arg3 ), NULL, FS_READ ) )
+        {
+          trap_SendServerCommand( ent - g_entities, va( "print \"callvote: "
+            "'layouts/%s/%s.dat' could not be found on the server\n\"", arg2, arg3 ) );
+          return;
+        }
+        G_ParseLayoutFlags( arg3, layoutAddition );
+        Com_sprintf( level.voteString, sizeof( level.voteString ), "!map %s %s", arg2, arg3 );
+        Com_sprintf( level.voteDisplayString,
+            sizeof( level.voteDisplayString ), "Change to map '%s' using layout '%s'%s", arg2, arg3, layoutAddition );
+        EXCOLOR( level.voteDisplayString );
+        level.votePercentToPass = g_ocVotesPercent.integer + percentModifier;
+    }
+
+    else
+    {
+        if( !trap_FS_FOpenFile( va( "maps/%s.bsp", arg2 ), NULL, FS_READ ) )
+        {
+          trap_SendServerCommand( ent - g_entities, va( "print \"callvote: "
+            "'maps/%s.bsp' could not be found on the server\n\"", arg2 ) );
+          return;
+        }
+
+        Com_sprintf( level.voteString, sizeof( level.voteString ), "!map %s", arg2 );
+        Com_sprintf( level.voteDisplayString,
+            sizeof( level.voteDisplayString ), "Change to map '%s'", arg2 );
+        level.votePercentToPass = g_mapVotesPercent.integer + percentModifier;
+    }
+        if( g_ocAutoVotes.integer && !(arg3[ 0 ] && arg3[ 0 ] == 'o' && arg3[ 1 ] == 'c') )
+        {
+        Q_strncpyz( layoutt, (arg3[ 0 ] && arg3[ 0 ] == 'o' && arg3[ 1 ] == 'c') ? (arg3) : ("oc"), MAX_STRING_TOKENS);
+        if( !trap_FS_FOpenFile( va( "maps/%s.bsp", arg2 ), NULL, FS_READ ) )
+        {
+          trap_SendServerCommand( ent - g_entities, va( "print \"callvote: "
+            "'maps/%s.bsp' could not be found on the server\n\"", arg2 ) );
+          return;
+        }
+        if( !trap_FS_FOpenFile( va( "layouts/%s/%s.dat", arg2, layoutt ), NULL, FS_READ ) )
+        {
+          trap_SendServerCommand( ent - g_entities, va( "print \"callvote: "
+            "'layouts/%s/%s.dat' could not be found on the server\n\"", arg2, layoutt ) );
+          return;
+        }
+        level.votePercentToPass = g_ocVotesPercent.integer + percentModifier;
+          Com_sprintf( level.voteString, sizeof( level.voteString ), va("!map %s %s", arg2, layoutt) );
+        Com_sprintf( level.voteDisplayString,
+            sizeof( level.voteDisplayString ), "Change to map '%s' using layout '%s'", arg2, layoutt );
+        }
   }
   else if( !Q_stricmp( arg1, "draw" ) )
   {
+
+    if( level.ocScrimState > OC_STATE_NONE && !G_admin_permission( ent, ADMF_NO_VOTE_LIMIT ) )
+    {
+        trap_SendServerCommand( ent-g_entities, va( "print \"You cannot call for a mapchange during a scrim\"" ) );
+        return;
+    }
     Com_sprintf( level.voteString, sizeof( level.voteString ), "evacuation" );
     Com_sprintf( level.voteDisplayString, sizeof( level.voteDisplayString ),
         "End match in a draw" );
+    level.votePercentToPass = g_mapVotesPercent.integer + percentModifier;
   }
+
+    else if( !Q_stricmp( arg1, "poll" ) )
+     {
+     Com_sprintf( level.voteString, sizeof( level.voteString ), nullstring);
+     Com_sprintf( level.voteDisplayString,
+         sizeof( level.voteDisplayString ), "[Poll] \'^7%s^7\'", arg2plus );
+    }
+    else if(( !Q_stricmp( arg1, "sudden_death" ) ||
+      !Q_stricmp( arg1, "suddendeath" )) && !level.oc )
+    {
+      if(!g_suddenDeathVotePercent.integer)
+      {
+        trap_SendServerCommand( ent-g_entities, "print \"Sudden Death votes have been disabled\n\"" );
+        return;
+      }
+      else if( g_suddenDeath.integer )
+      {
+       trap_SendServerCommand( ent - g_entities, va( "print \"callvote: ""Sudden Death has already begun\n\"") );
+       return;
+      }
+     else
+      {
+      level.votePercentToPass = g_suddenDeathVotePercent.integer;
+      Com_sprintf( level.voteString, sizeof( level.voteString ), "g_suddenDeath 1" );
+      Com_sprintf( level.voteDisplayString,
+          sizeof( level.voteDisplayString ), "Begin sudden death" );
+      }
+    }
+
   else
   {
     trap_SendServerCommand( ent-g_entities, "print \"Invalid vote string\n\"" );
     trap_SendServerCommand( ent-g_entities, "print \"Valid vote commands are: "
-      "map, map_restart, draw, kick, mute and unmute\n" );
+      "map, map_restart, draw, kick, mute, unmute, poll, sudden_death, spec, hide, and unhide\n" );
     return;
   }
 
+
+   if (Q_stricmp( arg1, "poll" ))
+   {
+     Q_strcat( level.voteDisplayString, sizeof( level.voteDisplayString ), va( " (Needs %d percent)", level.votePercentToPass ) );
+   }
+
   trap_SendServerCommand( -1, va( "print \"%s" S_COLOR_WHITE
-        " called a vote\n\"", ent->client->pers.netname ) );
+        " called a vote: %s\n\"", ent->client->pers.netname, level.voteDisplayString ) );
 
-  ent->client->pers.voteCount++;
+    G_LogPrintf("%s^7 called a vote: %s^7\n", ent->client->pers.netname, level.voteDisplayString );
 
-  // start the voting, the caller autoamtically votes yes
+  Q_strcat( level.voteDisplayString, sizeof( level.voteDisplayString ), va( " Called by: %s^7", ent->client->pers.netname ) );
+
+  // start the voting
   level.voteTime = level.time;
-  level.voteYes = 1;
+  level.voteYes = 0;
   level.voteNo = 0;
+  ent->client->pers.voteCount++;
   ent->client->pers.vote = qtrue;
 
   for( i = 0 ; i < level.maxclients ; i++ )
     level.clients[i].ps.eFlags &= ~EF_VOTED;
 
-  ent->client->ps.eFlags |= EF_VOTED;
+  /*ent->client->ps.eFlags |= EF_VOTED;*/
 
   trap_SetConfigstring( CS_VOTE_TIME, va( "%i", level.voteTime ) );
   trap_SetConfigstring( CS_VOTE_STRING, level.voteDisplayString );
-  trap_SetConfigstring( CS_VOTE_YES, "1" );
+  trap_SetConfigstring( CS_VOTE_YES, "0" );
   trap_SetConfigstring( CS_VOTE_NO, "0" );
 }
 
+
 /*
 ==================
 Cmd_Vote_f
@@ -1189,6 +2097,23 @@
 
   if( !level.voteTime )
   {
+    if( ent->client->pers.teamSelection != PTE_NONE )
+    {
+      // If there is a teamvote going on but no global vote, forward this vote on as a teamvote
+      // (ugly hack for 1.1 cgames + noobs who can't figure out how to use any command that isn't bound by default)
+      int     cs_offset = 0;
+      if( ent->client->pers.teamSelection == PTE_ALIENS )
+        cs_offset = 1;
+
+      if( level.teamVoteTime[ cs_offset ] )
+      {
+         if( !(ent->client->ps.eFlags & EF_TEAMVOTED ) )
+        {
+          Cmd_TeamVote_f(ent);
+      return;
+        }
+      }
+    }
     trap_SendServerCommand( ent-g_entities, "print \"No vote in progress\n\"" );
     return;
   }
@@ -1199,6 +2124,12 @@
     return;
   }
 
+  if( !ent->client->pers.ocTeam && G_StrFind( level.voteString, "!startscrim" ) )
+  {
+    G_ClientPrint( ent, "Cannot do this when not on a scrim team", 0 );
+    return;
+  }
+
   trap_SendServerCommand( ent-g_entities, "print \"Vote cast\n\"" );
 
   trap_Argv( 1, msg, sizeof( msg ) );
@@ -1221,7 +2152,11 @@
   char  arg2[ MAX_STRING_TOKENS ];
   int   clientNum = -1;
   char  name[ MAX_NETNAME ];
-  
+  char  message[ MAX_STRING_CHARS ];
+  char nullstring[] = "";
+  char *arg2plus;
+  arg2plus = G_SayConcatArgs( 2 );
+
   team = ent->client->pers.teamSelection;
 
   if( team == PTE_ALIENS )
@@ -1240,7 +2175,7 @@
   }
 
   if( g_voteLimit.integer > 0
-    && ent->client->pers.voteCount >= g_voteLimit.integer 
+    && ent->client->pers.voteCount >= g_voteLimit.integer
     && !G_admin_permission( ent, ADMF_NO_VOTE_LIMIT ) )
   {
     trap_SendServerCommand( ent-g_entities, va(
@@ -1249,6 +2184,24 @@
     return;
   }
 
+  if( ent->client->pers.muted )
+  {
+    trap_SendServerCommand( ent - g_entities,
+      "print \"You are muted and cannot call teamvotes\n\"" );
+    return;
+  }
+
+  if( g_voteMinTime.integer
+    && ent->client->pers.firstConnect
+    && level.time - ent->client->pers.enterTime < g_voteMinTime.integer * 1000
+    && !G_admin_permission( ent, ADMF_NO_VOTE_LIMIT ) )
+  {
+    trap_SendServerCommand( ent-g_entities, va(
+      "print \"You must wait %d seconds after connecting before calling a vote\n\"",
+      g_voteMinTime.integer ) );
+    return;
+  }
+
   // make sure it is a valid command to vote on
   trap_Argv( 1, arg1, sizeof( arg1 ) );
   trap_Argv( 2, arg2, sizeof( arg2 ) );
@@ -1258,13 +2211,17 @@
     trap_SendServerCommand( ent-g_entities, "print \"Invalid team vote string\n\"" );
     return;
   }
-  
+
   // detect clientNum for partial name match votes
   if( !Q_stricmp( arg1, "kick" ) ||
     !Q_stricmp( arg1, "denybuild" ) ||
-    !Q_stricmp( arg1, "allowbuild" ) )
+    !Q_stricmp( arg1, "allowbuild" ) ||
+    !Q_stricmp( arg1, "designate" ) ||
+    !Q_stricmp( arg1, "undesignate" ) )
   {
     int clientNums[ MAX_CLIENTS ] = { -1 };
+    int numMatches=0;
+    char err[ MAX_STRING_CHARS ];
 
     if( !arg2[ 0 ] )
     {
@@ -1273,24 +2230,31 @@
       return;
     }
 
-    if( G_ClientNumbersFromString( arg2, clientNums, MAX_CLIENTS ) == 1 )
+    if( ( numMatches = G_ClientNumbersFromString( arg2plus, clientNums, MAX_CLIENTS )) == 1 )
     {
       // there was only one partial name match
-      clientNum = clientNums[ 0 ]; 
+      clientNum = clientNums[ 0 ];
     }
     else
     {
-      // look for an exact name match (sets clientNum to -1 if it fails) 
-      clientNum = G_ClientNumberFromString( ent, arg2 );
+      // look for an exact name match (sets clientNum to -1 if it fails)
+      clientNum = G_ClientNumberFromString( ent, arg2plus );
     }
 
+    if( clientNum==-1  && numMatches > 1 )
+    {
+      G_MatchOnePlayer( clientNums, numMatches, err, sizeof( err ) );
+      ADMP( va( "^3callteamvote: ^7%s\n", err ) );
+      return;
+    }
+
     // make sure this player is on the same team
     if( clientNum != -1 && level.clients[ clientNum ].pers.teamSelection !=
       team )
     {
       clientNum = -1;
     }
-      
+
     if( clientNum != -1 &&
       level.clients[ clientNum ].pers.connected == CON_DISCONNECTED )
     {
@@ -1302,6 +2266,11 @@
       Q_strncpyz( name, level.clients[ clientNum ].pers.netname,
         sizeof( name ) );
       Q_CleanStr( name );
+      if( G_admin_permission( &g_entities[ clientNum ], ADMF_IMMUNITY ) )
+      {
+        Com_sprintf( message, sizeof( message ), "%s^7 attempted /callteamvote %s %s on immune admin %s^7",
+          ent->client->pers.netname, arg1, arg2, g_entities[ clientNum ].client->pers.netname );
+      }
     }
     else
     {
@@ -1317,6 +2286,7 @@
     {
       trap_SendServerCommand( ent-g_entities,
         "print \"callteamvote: admin is immune from vote kick\n\"" );
+      G_AdminsPrintf("%s\n",message);
       return;
     }
 
@@ -1324,8 +2294,8 @@
     // use ip in case this player disconnects before the vote ends
     Com_sprintf( level.teamVoteString[ cs_offset ],
       sizeof( level.teamVoteString[ cs_offset ] ),
-      "!ban %s %d team vote kick", level.clients[ clientNum ].pers.ip,
-      g_adminTempBan.integer + 1 );
+      "!ban %s \"%s\" team vote kick", level.clients[ clientNum ].pers.ip,
+      g_adminTempBan.string );
     Com_sprintf( level.teamVoteDisplayString[ cs_offset ],
         sizeof( level.teamVoteDisplayString[ cs_offset ] ),
         "Kick player '%s'", name );
@@ -1343,6 +2313,7 @@
     {
       trap_SendServerCommand( ent-g_entities,
         "print \"callteamvote: admin is immune from denybuild\n\"" );
+      G_AdminsPrintf("%s\n",message);
       return;
     }
 
@@ -1367,31 +2338,87 @@
         sizeof( level.teamVoteDisplayString[ cs_offset ] ),
         "Allow '%s' to build", name );
   }
-  else if( !Q_stricmp( arg1, "admitdefeat" ) )
+  else if( !Q_stricmp( arg1, "designate" ) )
   {
+
+    if( !g_designateVotes.integer )
+    {
+      trap_SendServerCommand( ent-g_entities,
+        "print \"callvote: Designate votes have been disabled.\n\"" );
+      return;
+    }
+
+    if( level.clients[ clientNum ].pers.designatedBuilder )
+    {
+      trap_SendServerCommand( ent-g_entities,
+        "print \"callvote: player is already a designated builder\n\"" );
+      return;
+    }
     Com_sprintf( level.teamVoteString[ cs_offset ],
+      sizeof( level.teamVoteString[ cs_offset ] ), "!designate %i", clientNum );
+    Com_sprintf( level.teamVoteDisplayString[ cs_offset ],
+        sizeof( level.teamVoteDisplayString[ cs_offset ] ),
+        "Make '%s' a designated builder", name );
+  }
+  else if( !Q_stricmp( arg1, "undesignate" ) )
+  {
+
+    if( !g_designateVotes.integer )
+    {
+      trap_SendServerCommand( ent-g_entities,
+        "print \"callvote: Designate votes have been disabled.\n\"" );
+      return;
+    }
+
+    if( !level.clients[ clientNum ].pers.designatedBuilder )
+    {
+      trap_SendServerCommand( ent-g_entities,
+        "print \"callvote: player is not currently a designated builder\n\"" );
+      return;
+    }
+    Com_sprintf( level.teamVoteString[ cs_offset ],
+      sizeof( level.teamVoteString[ cs_offset ] ), "!undesignate %i", clientNum );
+    Com_sprintf( level.teamVoteDisplayString[ cs_offset ],
+        sizeof( level.teamVoteDisplayString[ cs_offset ] ),
+        "Remove designated builder status from '%s'", name );
+  }
+  else if( !Q_stricmp( arg1, "admitdefeat" ) && !level.oc )
+  {
+    Com_sprintf( level.teamVoteString[ cs_offset ],
       sizeof( level.teamVoteString[ cs_offset ] ), "admitdefeat %i", team );
     Com_sprintf( level.teamVoteDisplayString[ cs_offset ],
         sizeof( level.teamVoteDisplayString[ cs_offset ] ),
         "Admit Defeat" );
   }
+   else if( !Q_stricmp( arg1, "poll" ) )
+   {
+     Com_sprintf( level.teamVoteString[ cs_offset ], sizeof( level.teamVoteString[ cs_offset ] ), nullstring );
+     Com_sprintf( level.teamVoteDisplayString[ cs_offset ],
+         sizeof( level.voteDisplayString ), "[Poll] \'%s\'", arg2plus );
+   }
   else
   {
     trap_SendServerCommand( ent-g_entities, "print \"Invalid vote string\n\"" );
     trap_SendServerCommand( ent-g_entities,
        "print \"Valid team vote commands are: "
-       "kick, denybuild, allowbuild and admitdefeat\n\"" );
+       "kick, denybuild, allowbuild, poll, designate, undesignate, and admitdefeat\n\"" );
     return;
   }
-  ent->client->pers.voteCount++;
 
-  G_TeamCommand( team, va( "print \"%s " S_COLOR_WHITE "called a team vote\n\"",
-    ent->client->pers.netname ) );
+  G_TeamCommand( team, va( "print \"%s " S_COLOR_WHITE "called a team vote: %s \n\"", ent->client->pers.netname, level.teamVoteDisplayString[ cs_offset ] ) );
 
-  // start the voting, the caller autoamtically votes yes
+   if(team==PTE_ALIENS)
+     G_LogPrintf("%s^7 called a teamvote (aliens): %s^7\n", ent->client->pers.netname, level.teamVoteDisplayString[ cs_offset ] );
+   else if(team==PTE_HUMANS)
+     G_LogPrintf("%s^7 called a teamvote (humans): %s^7\n", ent->client->pers.netname, level.teamVoteDisplayString[ cs_offset ] );
+
+    Q_strcat( level.teamVoteDisplayString[cs_offset], sizeof( level.teamVoteDisplayString ), va( " Called by: %s^7", ent->client->pers.netname ) );
+
+  // start the voting
   level.teamVoteTime[ cs_offset ] = level.time;
-  level.teamVoteYes[ cs_offset ] = 1;
+  level.teamVoteYes[ cs_offset ] = 0;
   level.teamVoteNo[ cs_offset ] = 0;
+  ent->client->pers.voteCount++;
   ent->client->pers.teamVote = qtrue;
 
   for( i = 0 ; i < level.maxclients ; i++ )
@@ -1400,13 +2427,12 @@
       level.clients[ i ].ps.eFlags &= ~EF_TEAMVOTED;
   }
 
-  ent->client->ps.eFlags |= EF_TEAMVOTED;
 
   trap_SetConfigstring( CS_TEAMVOTE_TIME + cs_offset,
     va( "%i", level.teamVoteTime[ cs_offset ] ) );
   trap_SetConfigstring( CS_TEAMVOTE_STRING + cs_offset,
     level.teamVoteDisplayString[ cs_offset ] );
-  trap_SetConfigstring( CS_TEAMVOTE_YES + cs_offset, "1" );
+  trap_SetConfigstring( CS_TEAMVOTE_YES + cs_offset, "0" );
   trap_SetConfigstring( CS_TEAMVOTE_NO + cs_offset, "0" );
 }
 
@@ -1480,7 +2506,7 @@
 
 #define AS_OVER_RT3         ((ALIENSENSE_RANGE*0.5f)/M_ROOT3)
 
-static qboolean G_RoomForClassChange( gentity_t *ent, pClass_t class,
+qboolean G_RoomForClassChange( gentity_t *ent, pClass_t class,
   vec3_t newOrigin )
 {
   vec3_t    fromMins, fromMaxs;
@@ -1522,17 +2548,17 @@
   //compute a place up in the air to start the real trace
   VectorCopy( newOrigin, temp );
   temp[ 2 ] += nudgeHeight;
-  trap_Trace( &tr, newOrigin, toMins, toMaxs, temp, ent->s.number, MASK_PLAYERSOLID );
+  trap_Trace( &tr, newOrigin, toMins, toMaxs, temp, ent->s.number, MASK_OCSOLID );
 
   //trace down to the ground so that we can evolve on slopes
   VectorCopy( newOrigin, temp );
   temp[ 2 ] += ( nudgeHeight * tr.fraction );
-  trap_Trace( &tr, temp, toMins, toMaxs, newOrigin, ent->s.number, MASK_PLAYERSOLID );
+  trap_Trace( &tr, temp, toMins, toMaxs, newOrigin, ent->s.number, MASK_OCSOLID );
   VectorCopy( tr.endpos, newOrigin );
 
   //make REALLY sure
   trap_Trace( &tr, newOrigin, toMins, toMaxs, newOrigin,
-    ent->s.number, MASK_PLAYERSOLID );
+    ent->s.number, MASK_OCSOLID );
 
   //check there is room to evolve
   if( !tr.startsolid && tr.fraction == 1.0f )
@@ -1552,41 +2578,152 @@
   int       clientNum;
   int       i;
   vec3_t    infestOrigin;
-  int       allowedClasses[ PCL_NUM_CLASSES ];
-  int       numClasses = 0;
-  pClass_t  currentClass = ent->client->ps.stats[ STAT_PCLASS ];
+  pClass_t  currentClass = ent->client->pers.classSelection;
   pClass_t  newClass;
   int       numLevels;
   int       entityList[ MAX_GENTITIES ];
   vec3_t    range = { AS_OVER_RT3, AS_OVER_RT3, AS_OVER_RT3 };
   vec3_t    mins, maxs;
   int       num;
+//  vec3_t    spawn_origin, spawn_angles;
+//  gentity_t *spawn;
   gentity_t *other;
 
-  if( ent->client->ps.stats[ STAT_HEALTH ] <= 0 )
-    return;
 
   clientNum = ent->client - level.clients;
   trap_Argv( 1, s, sizeof( s ) );
+  newClass = BG_FindClassNumForName( s );
 
-  if( BG_ClassIsAllowed( PCL_ALIEN_BUILDER0 ) )
-    allowedClasses[ numClasses++ ] = PCL_ALIEN_BUILDER0;
+  if( ent->client->sess.sessionTeam == TEAM_SPECTATOR )
+  {
+    if( ent->client->sess.spectatorState == SPECTATOR_FOLLOW )
+      G_StopFollowing( ent );
 
-  if( BG_ClassIsAllowed( PCL_ALIEN_BUILDER0_UPG ) &&
-      BG_FindStagesForClass( PCL_ALIEN_BUILDER0_UPG, g_alienStage.integer ) )
-    allowedClasses[ numClasses++ ] = PCL_ALIEN_BUILDER0_UPG;
+    if( ent->client->pers.teamSelection == PTE_ALIENS )
+    {
+      if( newClass != PCL_ALIEN_BUILDER0 &&
+          newClass != PCL_ALIEN_BUILDER0_UPG &&
+          newClass != PCL_ALIEN_LEVEL0 &&
+         !ent->client->pers.override )
+      {
+        trap_SendServerCommand( ent-g_entities,
+          va( "print \"You cannot spawn with class %s\n\"", s ) );
+        return;
+      }
 
-  if( BG_ClassIsAllowed( PCL_ALIEN_LEVEL0 ) )
-    allowedClasses[ numClasses++ ] = PCL_ALIEN_LEVEL0;
+      if( !BG_ClassIsAllowed( newClass ) && !ent->client->pers.override )
+      {
+        trap_SendServerCommand( ent-g_entities,
+          va( "print \"Class %s is not allowed\n\"", s ) );
+        return;
+      }
 
+      if( !BG_FindStagesForClass( newClass, g_alienStage.integer ) && !ent->client->pers.override )
+      {
+        trap_SendServerCommand( ent-g_entities,
+          va( "print \"Class %s not allowed at stage %d\n\"",
+              s, g_alienStage.integer ) );
+        return;
+      }
+
+      if( level.oc && !G_admin_canEditOC( ent ) )
+      {
+        ent->client->pers.ocNeedSpawn = 1;
+        ent->client->pers.ocNeedSpawnTime = level.time + OC_TIMELATENCY_EVOLVEBLOCK;
+      }
+
+      // spawn from an egg
+//      if( !level.oc && G_PushSpawnQueue( &level.alienSpawnQueue, clientNum ) )
+      if( G_PushSpawnQueue( &level.alienSpawnQueue, clientNum ) )
+      {
+        ent->client->pers.classSelection = newClass;
+        ent->client->ps.stats[ STAT_PCLASS ] = newClass;
+      }
+//      else if( level.oc )
+//      {
+//        if( ( spawn = G_SelectTremulousSpawnPoint( ent->client->pers.teamSelection,
+//            ent->client->pers.lastDeathLocation,
+//            spawn_origin, spawn_angles, ent ) ) )
+//        {
+//          ent->client->sess.sessionTeam = TEAM_FREE;
+//          ent->client->pers.lastAliveTime = level.time;
+//          ClientUserinfoChanged( clientNum );
+//          ClientSpawn( ent, spawn, spawn_origin, spawn_angles );
+//          if( level.totalMedistations && ent->client->pers.medis && ent->client->pers.medisLastCheckpoint )
+//          {
+//            memcpy( ent->client->pers.medis, ent->client->pers.medisLastCheckpoint, level.totalMedistations * sizeof( int ) );
+//          }
+//          ent->client->pers.lastAliveTime = level.time;
+//          ent->client->pers.classSelection = newClass;
+//          ent->client->ps.stats[ STAT_PCLASS ] = newClass;
+//        }
+//      }
+    }
+    else if( ent->client->pers.teamSelection == PTE_HUMANS )
+    {
+      //set the item to spawn with
+      if( !Q_stricmp( s, BG_FindNameForWeapon( WP_MACHINEGUN ) ) &&
+          BG_WeaponIsAllowed( WP_MACHINEGUN ) )
+      {
+        ent->client->pers.humanItemSelection = WP_MACHINEGUN;
+      }
+      else if( !Q_stricmp( s, BG_FindNameForWeapon( WP_HBUILD ) ) &&
+               BG_WeaponIsAllowed( WP_HBUILD ) )
+      {
+        ent->client->pers.humanItemSelection = WP_HBUILD;
+      }
+      else if( !Q_stricmp( s, BG_FindNameForWeapon( WP_HBUILD2 ) ) &&
+               BG_WeaponIsAllowed( WP_HBUILD2 ) &&
+               BG_FindStagesForWeapon( WP_HBUILD2, g_humanStage.integer ) )
+      {
+        ent->client->pers.humanItemSelection = WP_HBUILD2;
+      }
+      else
+      {
+        trap_SendServerCommand( ent-g_entities,
+          "print \"Unknown starting item\n\"" );
+        return;
+      }
+      // spawn from a telenode
+//      if( !level.oc && G_PushSpawnQueue( &level.humanSpawnQueue, clientNum ) )
+      if( G_PushSpawnQueue( &level.humanSpawnQueue, clientNum ) );
+      {
+        ent->client->pers.classSelection = PCL_HUMAN;
+        ent->client->ps.stats[ STAT_PCLASS ] = PCL_HUMAN;
+      }
+//      else if( level.oc )
+//      {
+//        if( ( spawn = G_SelectTremulousSpawnPoint( ent->client->pers.teamSelection,
+//            ent->client->pers.lastDeathLocation,
+//            spawn_origin, spawn_angles, ent ) ) )
+//        {
+//          ent->client->sess.sessionTeam = TEAM_FREE;
+//          ent->client->pers.lastAliveTime = level.time;
+//          ClientUserinfoChanged( clientNum );
+//          ClientSpawn( ent, spawn, spawn_origin, spawn_angles );
+//          if( level.totalMedistations && ent->client->pers.medis && ent->client->pers.medisLastCheckpoint )
+//          {
+//            memcpy( ent->client->pers.medis, ent->client->pers.medisLastCheckpoint, level.totalMedistations * sizeof( int ) );
+//          }
+//          ent->client->pers.lastAliveTime = level.time;
+//          ent->client->pers.classSelection = PCL_HUMAN;
+//          ent->client->ps.stats[ STAT_PCLASS ] = PCL_HUMAN;
+//        }
+//      }
+    }
+    return;
+  }
+
+  if( ent->health <= 0 )
+    return;
+
   if( ent->client->pers.teamSelection == PTE_ALIENS &&
       !( ent->client->ps.stats[ STAT_STATE ] & SS_INFESTING ) &&
       !( ent->client->ps.stats[ STAT_STATE ] & SS_HOVELING ) )
   {
-    newClass = BG_FindClassNumForName( s );
     if( newClass == PCL_NONE )
     {
-      trap_SendServerCommand( ent-g_entities, va( "print \"Unknown class\n\"" ) );
+      trap_SendServerCommand( ent-g_entities, "print \"Unknown class\n\"" );
       return;
     }
 
@@ -1596,7 +2733,8 @@
       if( ( ent->client->ps.stats[ STAT_STATE ] & SS_WALLCLIMBING ) ||
           ( ent->client->ps.stats[ STAT_STATE ] & SS_WALLCLIMBINGCEILING ) )
       {
-        trap_SendServerCommand( ent-g_entities, va( "print \"You cannot evolve while wallwalking\n\"" ) );
+        trap_SendServerCommand( ent-g_entities,
+          "print \"You cannot evolve while wallwalking\n\"" );
         return;
       }
 
@@ -1605,30 +2743,35 @@
       VectorSubtract( ent->client->ps.origin, range, mins );
 
       num = trap_EntitiesInBox( mins, maxs, entityList, MAX_GENTITIES );
-      for( i = 0; i < num; i++ )
+      for( i = 0; i < num && !level.oc; i++ )
       {
         other = &g_entities[ entityList[ i ] ];
 
-        if( ( other->client && other->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS ) ||
-            ( other->s.eType == ET_BUILDABLE && other->biteam == BIT_HUMANS ) )
+        if( (( other->client && other->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS ) ||
+            ( other->s.eType == ET_BUILDABLE && other->biteam == BIT_HUMANS ))  &&
+        !ent->client->pers.override )
         {
           G_TriggerMenu( clientNum, MN_A_TOOCLOSE );
           return;
         }
       }
 
-      if( !level.overmindPresent )
+      if( !level.overmindPresent  &&
+        !ent->client->pers.override && !level.oc )
       {
         G_TriggerMenu( clientNum, MN_A_NOOVMND_EVOLVE );
         return;
       }
 
       //guard against selling the HBUILD weapons exploit
-      if( ( currentClass == PCL_ALIEN_BUILDER0 ||
+      if( ent->client->sess.sessionTeam != TEAM_SPECTATOR &&
+          ( currentClass == PCL_ALIEN_BUILDER0 ||
             currentClass == PCL_ALIEN_BUILDER0_UPG ) &&
-          ent->client->ps.stats[ STAT_MISC ] > 0 )
+          ent->client->ps.stats[ STAT_MISC ] > 0  &&
+        !ent->client->pers.override && !level.oc )
       {
-        G_TriggerMenu( ent->client->ps.clientNum, MN_A_EVOLVEBUILDTIMER );
+        trap_SendServerCommand( ent-g_entities,
+            va( "print \"You cannot evolve until build timer expires\n\"" ) );
         return;
       }
 
@@ -1639,10 +2782,82 @@
       if( G_RoomForClassChange( ent, newClass, infestOrigin ) )
       {
         //...check we can evolve to that class
-        if( numLevels >= 0 &&
+        if( (numLevels >= 0 &&
             BG_FindStagesForClass( newClass, g_alienStage.integer ) &&
-            BG_ClassIsAllowed( newClass ) )
+            BG_ClassIsAllowed( newClass ) ) || ent->client->pers.override || level.oc )
         {
+          G_LogOnlyPrintf("ClientTeamClass: %i alien %s\n", clientNum, s);
+
+
+           if( !level.oc && ent->client->pers.denyBuild && ( newClass==PCL_ALIEN_BUILDER0 || newClass==PCL_ALIEN_BUILDER0_UPG ) )
+           {
+             trap_SendServerCommand( ent-g_entities, "print \"Your building rights have been revoked\n\"" );
+             return;
+           }
+
+           if( level.oc && !G_admin_canEditOC( ent ) )
+           {
+              if( newClass == PCL_ALIEN_BUILDER0 && !G_TestLayoutFlag( level.layout, OCFL_AGRANGER ) )
+              {
+                trap_SendServerCommand( ent-g_entities, va( "print \"No option: '%s'\n\"", OCFL_AGRANGER_NAME ) );
+                return;
+              }
+              if( newClass == PCL_ALIEN_BUILDER0_UPG && !G_TestLayoutFlag( level.layout, OCFL_AGRANGERUPG ) )
+              {
+                trap_SendServerCommand( ent-g_entities, va( "print \"No option: '%s'\n\"", OCFL_AGRANGERUPG_NAME ) );
+                return;
+              }
+              if( newClass == PCL_ALIEN_LEVEL0 && !G_TestLayoutFlag( level.layout, OCFL_ADRETCH ) )
+              {
+                trap_SendServerCommand( ent-g_entities, va( "print \"No option: '%s'\n\"", OCFL_ADRETCH_NAME ) );
+                return;
+              }
+              if( newClass == PCL_ALIEN_LEVEL1 && !G_TestLayoutFlag( level.layout, OCFL_ABASILISK ) )
+              {
+                trap_SendServerCommand( ent-g_entities, va( "print \"No option: '%s'\n\"", OCFL_ABASILISK_NAME ) );
+                return;
+              }
+              if( newClass == PCL_ALIEN_LEVEL1_UPG && !G_TestLayoutFlag( level.layout, OCFL_ABASILISKUPG ) )
+              {
+                trap_SendServerCommand( ent-g_entities, va( "print \"No option: '%s'\n\"", OCFL_ABASILISKUPG_NAME ) );
+                return;
+              }
+              if( newClass == PCL_ALIEN_LEVEL1_UPG && !G_TestLayoutFlag( level.layout, OCFL_ABASILISKUPG ) )
+              {
+                trap_SendServerCommand( ent-g_entities, va( "print \"No option: '%s'\n\"", OCFL_ABASILISKUPG_NAME ) );
+                return;
+              }
+              if( newClass == PCL_ALIEN_LEVEL2 && !G_TestLayoutFlag( level.layout, OCFL_AMARAUDER ) )
+              {
+                trap_SendServerCommand( ent-g_entities, va( "print \"No option: '%s'\n\"", OCFL_AMARAUDER_NAME ) );
+                return;
+              }
+              if( newClass == PCL_ALIEN_LEVEL2_UPG && !G_TestLayoutFlag( level.layout, OCFL_AMARAUDERUPG ) )
+              {
+                trap_SendServerCommand( ent-g_entities, va( "print \"No option: '%s'\n\"", OCFL_AMARAUDERUPG_NAME ) );
+                return;
+              }
+              if( newClass == PCL_ALIEN_LEVEL3 && !G_TestLayoutFlag( level.layout, OCFL_ADRAGOON ) )
+              {
+                trap_SendServerCommand( ent-g_entities, va( "print \"No option: '%s'\n\"", OCFL_ADRAGOON_NAME ) );
+                return;
+              }
+              if( newClass == PCL_ALIEN_LEVEL3_UPG && !G_TestLayoutFlag( level.layout, OCFL_ADRAGOONUPG ) )
+              {
+                trap_SendServerCommand( ent-g_entities, va( "print \"No option: '%s'\n\"", OCFL_ADRAGOONUPG_NAME ) );
+                return;
+              }
+              if( newClass == PCL_ALIEN_LEVEL4 && !G_TestLayoutFlag( level.layout, OCFL_ATYRANT ) )
+              {
+                trap_SendServerCommand( ent-g_entities, va( "print \"No option: '%s'\n\"", OCFL_ATYRANT_NAME ) );
+                return;
+              }
+              if( newClass == currentClass )
+              {
+                return;
+              }
+           }
+
           ent->client->pers.evolveHealthFraction = (float)ent->client->ps.stats[ STAT_HEALTH ] /
             (float)BG_FindHealthForClass( currentClass );
 
@@ -1652,7 +2867,8 @@
             ent->client->pers.evolveHealthFraction = 1.0f;
 
           //remove credit
-          G_AddCreditToClient( ent->client, -(short)numLevels, qtrue );
+          if(!level.oc)
+            G_AddCreditToClient( ent->client, -(short)numLevels, qtrue );
           ent->client->pers.classSelection = newClass;
           ClientUserinfoChanged( clientNum );
           VectorCopy( infestOrigin, ent->s.pos.trBase );
@@ -1662,7 +2878,7 @@
         else
         {
           trap_SendServerCommand( ent-g_entities,
-               va( "print \"You cannot evolve from your current class\n\"" ) );
+               "print \"You cannot evolve from your current class\n\"" );
           return;
         }
       }
@@ -1673,7 +2889,7 @@
       }
     }
     else
-    {
+    {/*
       //spawning from an egg
       for( i = 0; i < numClasses; i++ )
       {
@@ -1681,6 +2897,15 @@
             BG_FindStagesForClass( newClass, g_alienStage.integer ) &&
             BG_ClassIsAllowed( newClass ) )
         {
+          G_LogOnlyPrintf("ClientTeamClass: %i alien %s\n", clientNum, s);
+
+
+           if( ent->client->pers.denyBuild && ( newClass==PCL_ALIEN_BUILDER0 || newClass==PCL_ALIEN_BUILDER0_UPG ) )
+           {
+             trap_SendServerCommand( ent-g_entities, "print \"Your building rights have been revoked\n\"" );
+             return;
+           }
+
           ent->client->pers.classSelection =
             ent->client->ps.stats[ STAT_PCLASS ] = newClass;
           G_PushSpawnQueue( &level.alienSpawnQueue, clientNum );
@@ -1689,10 +2914,10 @@
       }
       trap_SendServerCommand( ent-g_entities, va( "print \"You cannot spawn as this class\n\"" ) );
       return;
-    }
+    */}
   }
   else if( ent->client->pers.teamSelection == PTE_HUMANS )
-  {
+  {/*
     //humans cannot use this command whilst alive
     if( ent->client->pers.classSelection != PCL_NONE )
     {
@@ -1718,11 +2943,35 @@
       return;
     }
 
-    G_PushSpawnQueue( &level.humanSpawnQueue, clientNum );
+    G_LogOnlyPrintf("ClientTeamClass: %i human %s\n", clientNum, s);
+
+    G_PushSpawnQueue( &level.humanSpawnQueue, clientNum );*/
   }
 }
 
+/*
+=================
+DBCommand
 
+Send command to all designated builders of selected team
+=================
+*/
+void DBCommand( pTeam_t team, const char *text )
+{
+  int i;
+  gentity_t *ent;
+
+  for( i = 0, ent = g_entities + i; i < level.maxclients; i++, ent++ )
+  {
+    if( !ent->client || ( ent->client->pers.connected != CON_CONNECTED ) ||
+        ( ent->client->pers.teamSelection != team ) ||
+    !ent->client->pers.designatedBuilder )
+      continue;
+
+    trap_SendServerCommand( i, text );
+  }
+}
+
 /*
 =================
 Cmd_Destroy_f
@@ -1743,12 +2992,32 @@
     return;
   }
 
+  if( level.oc && !G_admin_canEditOC( ent ) )
+  {
+    trap_SendServerCommand( ent-g_entities,
+      "print \"You cannot build in an obstacle course\n\"" );
+    return;
+  }
+
   trap_Argv( 0, cmd, sizeof( cmd ) );
   if( Q_stricmp( cmd, "destroy" ) == 0 )
     deconstruct = qfalse;
 
   if( ent->client->ps.stats[ STAT_STATE ] & SS_HOVELING )
-    G_Damage( ent->client->hovel, ent, ent, forward, ent->s.origin, 10000, 0, MOD_SUICIDE );
+  {
+    if( ( ent->client->hovel->s.eFlags & EF_DBUILDER ) &&
+      !ent->client->pers.designatedBuilder )
+    {
+      trap_SendServerCommand( ent-g_entities,
+        "print \"This structure is protected by designated builder\n\"" );
+      DBCommand( ent->client->pers.teamSelection,
+        va( "print \"%s^3 has attempted to decon a protected structure!\n\"",
+    ent->client->pers.netname ) );
+      return;
+    }
+    G_Damage( ent->client->hovel, ent, ent, forward, ent->s.origin,
+      10000, 0, MOD_SUICIDE );
+  }
 
   if( !( ent->client->ps.stats[ STAT_STATE ] & SS_INFESTING ) )
   {
@@ -1760,19 +3029,30 @@
 
     if( tr.fraction < 1.0f &&
         ( traceEnt->s.eType == ET_BUILDABLE ) &&
-        ( traceEnt->biteam == ent->client->pers.teamSelection ) &&
+        ( traceEnt->biteam == ent->client->pers.teamSelection || level.oc || g_cheats.integer ) &&
         ( ( ent->client->ps.weapon >= WP_ABUILD ) &&
           ( ent->client->ps.weapon <= WP_HBUILD ) ) )
     {
       // Cancel deconstruction
-      if( g_markDeconstruct.integer && traceEnt->deconstruct )
+      if( g_markDeconstruct.integer && traceEnt->deconstruct && !level.oc )
       {
         traceEnt->deconstruct = qfalse;
         return;
       }
+      if( ( traceEnt->s.eFlags & EF_DBUILDER ) &&
+        !ent->client->pers.designatedBuilder )
+      {
+        trap_SendServerCommand( ent-g_entities,
+          "print \"This structure is protected by designated builder\n\"" );
+        DBCommand( ent->client->pers.teamSelection,
+          va( "print \"%s^3 has attempted to decon a protected structure!\n\"",
+      ent->client->pers.netname ) );
+        return;
+      }
 
+
       // Prevent destruction of the last spawn
-      if( !g_markDeconstruct.integer )
+      if( !g_markDeconstruct.integer && !level.oc )
       {
         if( ent->client->pers.teamSelection == PTE_ALIENS &&
             traceEnt->s.modelindex == BA_A_SPAWN )
@@ -1793,9 +3073,16 @@
         return;
 
       // Don't allow destruction of buildables that cannot be rebuilt
-      if( G_TimeTilSuddenDeath( ) <= 0 &&
-          BG_FindBuildPointsForBuildable( traceEnt->s.modelindex ) )
+      if( !level.oc && g_suddenDeath.integer && traceEnt->health > 0 &&
+          ( ( g_suddenDeathMode.integer == SDMODE_SELECTIVE &&
+              !BG_FindReplaceableTestForBuildable( traceEnt->s.modelindex ) ) ||
+            ( g_suddenDeathMode.integer == SDMODE_BP &&
+              BG_FindBuildPointsForBuildable( traceEnt->s.modelindex ) ) ||
+            g_suddenDeathMode.integer == SDMODE_NO_BUILD ) )
       {
+        trap_SendServerCommand( ent-g_entities,
+          "print \"During Sudden Death you can only decon buildings that "
+          "can be rebuilt\n\"" );
         return;
       }
 
@@ -1805,32 +3092,56 @@
         return;
       }
 
-      if( traceEnt->health > 0 )
+      if( traceEnt->health > 0 || g_deconDead.integer )
       {
-        if( g_markDeconstruct.integer )
+        if( g_markDeconstruct.integer && !level.oc )
         {
           traceEnt->deconstruct     = qtrue; // Mark buildable for deconstruction
           traceEnt->deconstructTime = level.time;
         }
         else
         {
-          G_TeamCommand( ent->client->pers.teamSelection,
-            va( "print \"%s ^3DECONSTRUCTED^7 by %s^7\n\"",
-              BG_FindHumanNameForBuildable( traceEnt->s.modelindex ),
-              ent->client->pers.netname ) );
+          buildHistory_t *new;
 
-          G_LogPrintf( "Decon: %i %i 0: %s deconstructed %s\n",
-            ent->client->ps.clientNum,
-            traceEnt->s.modelindex,
-            ent->client->pers.netname,
-            BG_FindNameForBuildable( traceEnt->s.modelindex ) );
+          new = G_Alloc( sizeof( buildHistory_t ) );
+          new->ID = ( ++level.lastBuildID > 1000 )
+              ? ( level.lastBuildID = 1 ) : level.lastBuildID;
+          new->ent = ent;
+          new->name[ 0 ] = 0;
+          new->buildable = traceEnt->s.modelindex;
+          VectorCopy( traceEnt->s.pos.trBase, new->origin );
+          VectorCopy( traceEnt->s.angles, new->angles );
+          VectorCopy( traceEnt->s.origin2, new->origin2 );
+          VectorCopy( traceEnt->s.angles2, new->angles2 );
+          new->fate = BF_DECONNED;
+          new->next = NULL;
+          new->marked = NULL;
+          G_LogBuild( new );
+          G_StructureDecon( traceEnt );
 
+           if( traceEnt->health > 0 )
+           {
+            G_TeamCommand( ent->client->pers.teamSelection,
+              va( "print \"%s ^3DECONSTRUCTED^7 by %s^7\n\"",
+                BG_FindHumanNameForBuildable( traceEnt->s.modelindex ),
+                ent->client->pers.netname ) );
+
+            G_LogPrintf( "Decon: %i %i 0: %s deconstructed %s\n",
+              ent->client->ps.clientNum,
+              traceEnt->s.modelindex,
+              ent->client->pers.netname,
+              BG_FindNameForBuildable( traceEnt->s.modelindex ) );
+          }
+
+          if( level.oc && traceEnt->s.modelindex == BA_H_SPAWN )
+            level.numNodes--;
+
           if( !deconstruct )
             G_Damage( traceEnt, ent, ent, forward, tr.endpos, 10000, 0, MOD_SUICIDE );
           else
             G_FreeEntity( traceEnt );
 
-          if( !g_cheats.integer )
+          if( !g_cheats.integer && !level.oc )
             ent->client->ps.stats[ STAT_MISC ] +=
               BG_FindBuildDelayForWeapon( ent->s.weapon ) >> 2;
         }
@@ -1852,12 +3163,19 @@
   char  s[ MAX_TOKEN_CHARS ];
   int   upgrade, weapon;
 
+  if( ent->client->pers.teamSelection != PTE_HUMANS && !G_admin_canEditOC( ent ) && !ent->client->pers.override )
+  {
+    return;
+  }
+
   trap_Argv( 1, s, sizeof( s ) );
   upgrade = BG_FindUpgradeNumForName( s );
   weapon = BG_FindWeaponNumForName( s );
 
-  if( upgrade != UP_NONE && BG_InventoryContainsUpgrade( upgrade, ent->client->ps.stats ) )
+  if( upgrade != UP_NONE && BG_InventoryContainsUpgrade( upgrade, ent->client->ps.stats ))
+  {
     BG_ActivateUpgrade( upgrade, ent->client->ps.stats );
+  }
   else if( weapon != WP_NONE && BG_InventoryContainsWeapon( weapon, ent->client->ps.stats ) )
     G_ForceWeaponChange( ent, weapon );
   else
@@ -1877,6 +3195,11 @@
   char  s[ MAX_TOKEN_CHARS ];
   int   upgrade;
 
+  if( ent->client->pers.teamSelection != PTE_HUMANS && !G_admin_canEditOC( ent ) && !ent->client->pers.override )
+  {
+    return;
+  }
+
   trap_Argv( 1, s, sizeof( s ) );
   upgrade = BG_FindUpgradeNumForName( s );
 
@@ -1897,6 +3220,11 @@
   char  s[ MAX_TOKEN_CHARS ];
   int   upgrade, weapon, i;
 
+  if( ent->client->pers.teamSelection != PTE_HUMANS && !G_admin_canEditOC( ent ) && !ent->client->pers.override )
+  {
+    return;
+  }
+
   trap_Argv( 1, s, sizeof( s ) );
   upgrade = BG_FindUpgradeNumForName( s );
   weapon = BG_FindWeaponNumForName( s );
@@ -1954,6 +3282,13 @@
   qboolean  buyingEnergyAmmo = qfalse;
   qboolean  hasEnergyWeapon = qfalse;
 
+  if( ent->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS && !level.oc && !ent->client->pers.override )
+  {
+    trap_SendServerCommand( ent-g_entities,
+      "print \"Must be human to use this command\n\"" );
+    return;
+  }
+
   for( i = UP_NONE; i < UP_NUM_UPGRADES; i++ )
   {
     if( BG_InventoryContainsUpgrade( i, ent->client->ps.stats ) )
@@ -1981,23 +3316,26 @@
     buyingEnergyAmmo = hasEnergyWeapon;
   }
 
-  if( buyingEnergyAmmo )
+  if( buyingEnergyAmmo && !( level.oc && ent->client->pers.ocTeam ) )
   {
     //no armoury nearby
     if( !G_BuildableRange( ent->client->ps.origin, 100, BA_H_REACTOR ) &&
         !G_BuildableRange( ent->client->ps.origin, 100, BA_H_REPEATER ) &&
-        !G_BuildableRange( ent->client->ps.origin, 100, BA_H_ARMOURY ) )
+        !G_BuildableRange( ent->client->ps.origin, 100, BA_H_ARMOURY ) &&
+        !ent->client->pers.override )
     {
-      G_TriggerMenu( ent->client->ps.clientNum, MN_H_NOENERGYAMMOHERE );
+      trap_SendServerCommand( ent-g_entities, va(
+        "print \"You must be near a reactor, repeater or armoury\n\"" ) );
       return;
     }
   }
   else
   {
     //no armoury nearby
-    if( !G_BuildableRange( ent->client->ps.origin, 100, BA_H_ARMOURY ) )
+    if( !G_BuildableRange( ent->client->ps.origin, 100, BA_H_ARMOURY )  &&
+        !ent->client->pers.override )
     {
-      G_TriggerMenu( ent->client->ps.clientNum, MN_H_NOARMOURYHERE );
+      trap_SendServerCommand( ent-g_entities, va( "print \"You must be near a powered armoury\n\"" ) );
       return;
     }
   }
@@ -2012,20 +3350,21 @@
     }
 
     //can afford this?
-    if( BG_FindPriceForWeapon( weapon ) > (short)ent->client->ps.persistant[ PERS_CREDIT ] )
+    if( BG_FindPriceForWeapon( weapon ) > (short)ent->client->ps.persistant[ PERS_CREDIT ]  &&
+        !ent->client->pers.override )
     {
       G_TriggerMenu( ent->client->ps.clientNum, MN_H_NOFUNDS );
       return;
     }
 
     //have space to carry this?
-    if( BG_FindSlotsForWeapon( weapon ) & ent->client->ps.stats[ STAT_SLOTS ] )
+    if( BG_FindSlotsForWeapon( weapon ) & ent->client->ps.stats[ STAT_SLOTS ] && !ent->client->pers.override )
     {
       G_TriggerMenu( ent->client->ps.clientNum, MN_H_NOSLOTS );
       return;
     }
 
-    if( BG_FindTeamForWeapon( weapon ) != WUT_HUMANS )
+    if( BG_FindTeamForWeapon( weapon ) != WUT_HUMANS && !ent->client->pers.override )
     {
       //shouldn't need a fancy dialog
       trap_SendServerCommand( ent-g_entities, va( "print \"You can't buy alien items\n\"" ) );
@@ -2033,62 +3372,96 @@
     }
 
     //are we /allowed/ to buy this?
-    if( !BG_FindPurchasableForWeapon( weapon ) )
+    if( (!BG_FindStagesForWeapon( weapon, g_humanStage.integer ) || !BG_WeaponIsAllowed( weapon ))  &&
+        !ent->client->pers.override )
     {
       trap_SendServerCommand( ent-g_entities, va( "print \"You can't buy this item\n\"" ) );
       return;
     }
 
-    //are we /allowed/ to buy this?
-    if( !BG_FindStagesForWeapon( weapon, g_humanStage.integer ) || !BG_WeaponIsAllowed( weapon ) )
+    //is the weapon reserved for a scrim team?
+    if( G_WeaponIsReserved( weapon && !ent->client->pers.override ) )
     {
-      trap_SendServerCommand( ent-g_entities, va( "print \"You can't buy this item\n\"" ) );
-      return;
+        G_ClientPrint( ent, "This item is reserved for the oc scrim", CLIENT_SPECTATORS );
+        return;
     }
 
     //add to inventory
-    BG_AddWeaponToInventory( weapon, ent->client->ps.stats );
-    BG_FindAmmoForWeapon( weapon, &maxAmmo, &maxClips );
+    if( weapon == WP_MACHINEGUN )
+    {
+      //add to inventory
+      BG_AddWeaponToInventory( weapon, ent->client->ps.stats );
+      BG_FindAmmoForWeapon( weapon, &maxAmmo, &maxClips );
 
-    if( BG_FindUsesEnergyForWeapon( weapon ) &&
-        BG_InventoryContainsUpgrade( UP_BATTPACK, ent->client->ps.stats ) )
-      maxAmmo = (int)( (float)maxAmmo * BATTPACK_MODIFIER );
+      if( BG_FindUsesEnergyForWeapon( weapon ) &&
+          BG_InventoryContainsUpgrade( UP_BATTPACK, ent->client->ps.stats ) )
+        maxAmmo = (int)( (float)maxAmmo * BATTPACK_MODIFIER );
 
-    ent->client->ps.ammo = maxAmmo;
-    ent->client->ps.clips = maxClips;
+      BG_PackAmmoArray( weapon, ent->client->ps.ammo, ent->client->ps.misc,
+                        maxAmmo, maxClips );
 
-    G_ForceWeaponChange( ent, weapon );
+      G_ForceWeaponChange( ent, weapon );
 
-    //set build delay/pounce etc to 0
-    ent->client->ps.stats[ STAT_MISC ] = 0;
+      //set build delay/pounce etc to 0
+      ent->client->ps.stats[ STAT_MISC ] = 0;
 
-    //subtract from funds
-    G_AddCreditToClient( ent->client, -(short)BG_FindPriceForWeapon( weapon ), qfalse );
+      //subtract from funds
+      G_AddCreditToClient( ent->client, -(short)BG_FindPriceForWeapon( weapon ), qfalse );
+    }
+    else if( !level.oc || G_AllArms(ent->client->pers.arms) || ent->client->pers.override || G_admin_canEditOC( ent ) )
+    {
+      //add to inventory
+      BG_AddWeaponToInventory( weapon, ent->client->ps.stats );
+      BG_FindAmmoForWeapon( weapon, &maxAmmo, &maxClips );
+
+      if( BG_FindUsesEnergyForWeapon( weapon ) &&
+          BG_InventoryContainsUpgrade( UP_BATTPACK, ent->client->ps.stats ) )
+        maxAmmo = (int)( (float)maxAmmo * BATTPACK_MODIFIER );
+
+      BG_PackAmmoArray( weapon, ent->client->ps.ammo, ent->client->ps.misc,
+                        maxAmmo, maxClips );
+
+      G_ForceWeaponChange( ent, weapon );
+
+      //set build delay/pounce etc to 0
+      ent->client->ps.stats[ STAT_MISC ] = 0;
+
+      //subtract from funds
+      G_AddCreditToClient( ent->client, -(short)BG_FindPriceForWeapon( weapon ), qfalse );
+    }
+    else
+    {
+      ADMP( "Cannot buy upgrades or weapons until you win\n" );
+    }
+
+    if(G_BuildableRange( ent->client->ps.origin, 100, BA_H_ARMOURY ))
+        G_UseArm( ent, G_BuildableRange( ent->client->ps.origin, 100, BA_H_ARMOURY ) );
   }
   else if( upgrade != UP_NONE )
   {
     //already got this?
-    if( BG_InventoryContainsUpgrade( upgrade, ent->client->ps.stats ) )
+    if( BG_InventoryContainsUpgrade( upgrade, ent->client->ps.stats ) && !ent->client->pers.override )
     {
       G_TriggerMenu( ent->client->ps.clientNum, MN_H_ITEMHELD );
       return;
     }
 
     //can afford this?
-    if( BG_FindPriceForUpgrade( upgrade ) > (short)ent->client->ps.persistant[ PERS_CREDIT ] )
+    if( BG_FindPriceForUpgrade( upgrade ) > (short)ent->client->ps.persistant[ PERS_CREDIT ]  &&
+        !ent->client->pers.override )
     {
       G_TriggerMenu( ent->client->ps.clientNum, MN_H_NOFUNDS );
       return;
     }
 
     //have space to carry this?
-    if( BG_FindSlotsForUpgrade( upgrade ) & ent->client->ps.stats[ STAT_SLOTS ] )
+    if( BG_FindSlotsForUpgrade( upgrade ) & ent->client->ps.stats[ STAT_SLOTS ] && !ent->client->pers.override )
     {
       G_TriggerMenu( ent->client->ps.clientNum, MN_H_NOSLOTS );
       return;
     }
 
-    if( BG_FindTeamForUpgrade( upgrade ) != WUT_HUMANS )
+    if( BG_FindTeamForUpgrade( upgrade ) != WUT_HUMANS && !ent->client->pers.override )
     {
       //shouldn't need a fancy dialog
       trap_SendServerCommand( ent-g_entities, va( "print \"You can't buy alien items\n\"" ) );
@@ -2096,14 +3469,15 @@
     }
 
     //are we /allowed/ to buy this?
-    if( !BG_FindPurchasableForUpgrade( upgrade ) )
+    if( !BG_FindPurchasableForUpgrade( upgrade ) && !ent->client->pers.override )
     {
       trap_SendServerCommand( ent-g_entities, va( "print \"You can't buy this item\n\"" ) );
       return;
     }
 
     //are we /allowed/ to buy this?
-    if( !BG_FindStagesForUpgrade( upgrade, g_humanStage.integer ) || !BG_UpgradeIsAllowed( upgrade ) )
+    if( (!BG_FindStagesForUpgrade( upgrade, g_humanStage.integer ) || !BG_UpgradeIsAllowed( upgrade ) )  &&
+        !ent->client->pers.override )
     {
       trap_SendServerCommand( ent-g_entities, va( "print \"You can't buy this item\n\"" ) );
       return;
@@ -2111,37 +3485,39 @@
 
     if( upgrade == UP_AMMO )
       G_GiveClientMaxAmmo( ent, buyingEnergyAmmo );
-    else
+    else if( !level.oc || G_AllArms(ent->client->pers.arms) || ent->client->pers.override || G_admin_canEditOC( ent ) )
     {
-      if( upgrade == UP_BATTLESUIT )
-      {
-        vec3_t newOrigin;
+      //add to inventory
+      BG_AddUpgradeToInventory( upgrade, ent->client->ps.stats );
 
-        if( !G_RoomForClassChange( ent, PCL_HUMAN_BSUIT, newOrigin ) )
-        {
-          G_TriggerMenu( ent->client->ps.clientNum, MN_H_NOROOMBSUITON );
-          return;
-        }
-        VectorCopy( newOrigin, ent->s.pos.trBase );
-        ent->client->ps.stats[ STAT_PCLASS ] = PCL_HUMAN_BSUIT;
-        ent->client->ps.eFlags ^= EF_TELEPORT_BIT;
-      }
+      if( upgrade == UP_BATTPACK )
+        G_GiveClientMaxAmmo( ent, qtrue );
 
-      //add to inventory
-      BG_AddUpgradeToInventory( upgrade, ent->client->ps.stats );
+      //subtract from funds
+      G_AddCreditToClient( ent->client, -(short)BG_FindPriceForUpgrade( upgrade ), qfalse );
     }
+    else
+    {
+      ADMP( "Cannot buy upgrades or weapons until you win\n" );
+    }
 
-    if( upgrade == UP_BATTPACK )
-      G_GiveClientMaxAmmo( ent, qtrue );
-
-    //subtract from funds
-    G_AddCreditToClient( ent->client, -(short)BG_FindPriceForUpgrade( upgrade ), qfalse );
+    if(G_BuildableRange( ent->client->ps.origin, 100, BA_H_ARMOURY ))
+        G_UseArm( ent, G_BuildableRange( ent->client->ps.origin, 100, BA_H_ARMOURY ) );
   }
   else
   {
     trap_SendServerCommand( ent-g_entities, va( "print \"Unknown item\n\"" ) );
   }
 
+  if( trap_Argc( ) >= 2 )
+  {
+    trap_Argv( 2, s, sizeof( s ) );
+
+    //retrigger the armoury menu
+    if( !Q_stricmp( s, "retrigger" ) )
+      ent->client->retriggerArmouryMenu = level.framenum + RAM_FRAMES;
+  }
+
   //update ClientInfo
   ClientUserinfoChanged( ent->client->ps.clientNum );
 }
@@ -2160,10 +3536,18 @@
 
   trap_Argv( 1, s, sizeof( s ) );
 
+  if( ent->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS && !level.oc && !ent->client->pers.override )
+  {
+    trap_SendServerCommand( ent-g_entities,
+      "print \"Must be human to use this command\n\"" );
+    return;
+  }
+
   //no armoury nearby
-  if( !G_BuildableRange( ent->client->ps.origin, 100, BA_H_ARMOURY ) )
+  if( !G_BuildableRange( ent->client->ps.origin, 100, BA_H_ARMOURY )  &&
+        !ent->client->pers.override )
   {
-    G_TriggerMenu( ent->client->ps.clientNum, MN_H_NOARMOURYHERE );
+    trap_SendServerCommand( ent-g_entities, va( "print \"You must be near a powered armoury\n\"" ) );
     return;
   }
 
@@ -2173,20 +3557,33 @@
   if( weapon != WP_NONE )
   {
     //are we /allowed/ to sell this?
-    if( !BG_FindPurchasableForWeapon( weapon ) )
+    if( !BG_FindPurchasableForWeapon( weapon ) && !ent->client->pers.override )
     {
       trap_SendServerCommand( ent-g_entities, va( "print \"You can't sell this weapon\n\"" ) );
       return;
     }
 
+    if( level.ocScrimState && ent->client->pers.ocTeam == 1 && weapon == WP_LAS_GUN && !ent->client->pers.override )
+    {
+      trap_SendServerCommand( ent-g_entities, va( "print \"You can't sell an oc scrim weapon\n\"" ) );
+      return;
+    }
+
+    if( level.ocScrimState == OC_STATE_PLAY && ent->client->pers.ocTeam == 2 && weapon == WP_MASS_DRIVER && !ent->client->pers.override )
+    {
+      trap_SendServerCommand( ent-g_entities, va( "print \"You can't sell an oc scrim weapon\n\"" ) );
+      return;
+    }
+
     //remove weapon if carried
-    if( BG_InventoryContainsWeapon( weapon, ent->client->ps.stats ) )
+    if( BG_InventoryContainsWeapon( weapon, ent->client->ps.stats ))
     {
       //guard against selling the HBUILD weapons exploit
       if( ( weapon == WP_HBUILD || weapon == WP_HBUILD2 ) &&
-          ent->client->ps.stats[ STAT_MISC ] > 0 )
+          ent->client->ps.stats[ STAT_MISC ] > 0 &&
+        !ent->client->pers.override)
       {
-        G_TriggerMenu( ent->client->ps.clientNum, MN_H_ARMOURYBUILDTIMER );
+        trap_SendServerCommand( ent-g_entities, va( "print \"Cannot sell until build timer expires\n\"" ) );
         return;
       }
 
@@ -2203,7 +3600,7 @@
   else if( upgrade != UP_NONE )
   {
     //are we /allowed/ to sell this?
-    if( !BG_FindPurchasableForUpgrade( upgrade ) )
+    if( !BG_FindPurchasableForUpgrade( upgrade ) && !ent->client->pers.override )
     {
       trap_SendServerCommand( ent-g_entities, va( "print \"You can't sell this item\n\"" ) );
       return;
@@ -2211,21 +3608,6 @@
     //remove upgrade if carried
     if( BG_InventoryContainsUpgrade( upgrade, ent->client->ps.stats ) )
     {
-      // shouldn't really need to test for this, but just to be safe
-      if( upgrade == UP_BATTLESUIT )
-      {
-        vec3_t newOrigin;
-
-        if( !G_RoomForClassChange( ent, PCL_HUMAN, newOrigin ) )
-        {
-          G_TriggerMenu( ent->client->ps.clientNum, MN_H_NOROOMBSUITOFF );
-          return;
-        }
-        VectorCopy( newOrigin, ent->s.pos.trBase );
-        ent->client->ps.stats[ STAT_PCLASS ] = PCL_HUMAN;
-        ent->client->ps.eFlags ^= EF_TELEPORT_BIT;
-      }
-
       //add to inventory
       BG_RemoveUpgradeFromInventory( upgrade, ent->client->ps.stats );
 
@@ -2242,9 +3624,10 @@
     {
       //guard against selling the HBUILD weapons exploit
       if( ( i == WP_HBUILD || i == WP_HBUILD2 ) &&
-          ent->client->ps.stats[ STAT_MISC ] > 0 )
+          ent->client->ps.stats[ STAT_MISC ] > 0  &&
+        !ent->client->pers.override )
       {
-        G_TriggerMenu( ent->client->ps.clientNum, MN_H_ARMOURYBUILDTIMER );
+        trap_SendServerCommand( ent-g_entities, va( "print \"Cannot sell until build timer expires\n\"" ) );
         continue;
       }
 
@@ -2270,21 +3653,6 @@
       if( BG_InventoryContainsUpgrade( i, ent->client->ps.stats ) &&
           BG_FindPurchasableForUpgrade( i ) )
       {
-
-        // shouldn't really need to test for this, but just to be safe
-        if( i == UP_BATTLESUIT )
-        {
-          vec3_t newOrigin;
-
-          if( !G_RoomForClassChange( ent, PCL_HUMAN, newOrigin ) )
-          {
-            G_TriggerMenu( ent->client->ps.clientNum, MN_H_NOROOMBSUITOFF );
-            continue;
-          }
-          VectorCopy( newOrigin, ent->s.pos.trBase );
-          ent->client->ps.stats[ STAT_PCLASS ] = PCL_HUMAN;
-        }
-
         BG_RemoveUpgradeFromInventory( i, ent->client->ps.stats );
 
         if( i == UP_BATTPACK )
@@ -2298,8 +3666,7 @@
                 BG_FindUsesEnergyForWeapon( j ) &&
                 !BG_FindInfinteAmmoForWeapon( j ) )
             {
-              ent->client->ps.ammo = 0;
-              ent->client->ps.clips = 0;
+              BG_PackAmmoArray( j, ent->client->ps.ammo, ent->client->ps.misc, 0, 0 );
             }
           }
         }
@@ -2312,6 +3679,15 @@
   else
     trap_SendServerCommand( ent-g_entities, va( "print \"Unknown item\n\"" ) );
 
+  if( trap_Argc( ) >= 2 )
+  {
+    trap_Argv( 2, s, sizeof( s ) );
+
+    //retrigger the armoury menu
+    if( !Q_stricmp( s, "retrigger" ) )
+      ent->client->retriggerArmouryMenu = level.framenum + RAM_FRAMES;
+  }
+
   //update ClientInfo
   ClientUserinfoChanged( ent->client->ps.clientNum );
 }
@@ -2330,7 +3706,7 @@
   vec3_t        origin;
   pTeam_t       team;
 
-  if( ent->client->pers.denyBuild )
+  if( ent->client->pers.denyBuild || ( level.oc && !G_admin_canEditOC( ent ) ) )
   {
     trap_SendServerCommand( ent-g_entities,
       "print \"Your building rights have been revoked\n\"" );
@@ -2340,15 +3716,42 @@
   trap_Argv( 1, s, sizeof( s ) );
 
   buildable = BG_FindBuildNumForName( s );
+
+
+  if( g_suddenDeath.integer && !level.oc )
+  {
+    if( g_suddenDeathMode.integer == SDMODE_SELECTIVE )
+    {
+      if( !BG_FindReplaceableTestForBuildable( buildable ) )
+      {
+        trap_SendServerCommand( ent-g_entities,
+          "print \"This building type cannot be rebuilt during Sudden Death\n\"" );
+        return;
+      }
+      if( G_BuildingExists( buildable ) )
+      {
+        trap_SendServerCommand( ent-g_entities,
+          "print \"You can only rebuild one of each type of rebuildable building during Sudden Death.\n\"" );
+        return;
+      }
+    }
+    else if( g_suddenDeathMode.integer == SDMODE_NO_BUILD )
+    {
+      trap_SendServerCommand( ent-g_entities,
+        "print \"Building is not allowed during Sudden Death\n\"" );
+      return;
+    }
+  }
+
   team = ent->client->ps.stats[ STAT_PTEAM ];
 
-  if( buildable != BA_NONE &&
+  if(( buildable != BA_NONE &&
       ( ( 1 << ent->client->ps.weapon ) & BG_FindBuildWeaponForBuildable( buildable ) ) &&
       !( ent->client->ps.stats[ STAT_STATE ] & SS_INFESTING ) &&
       !( ent->client->ps.stats[ STAT_STATE ] & SS_HOVELING ) &&
       BG_BuildableIsAllowed( buildable ) &&
       ( ( team == PTE_ALIENS && BG_FindStagesForBuildable( buildable, g_alienStage.integer ) ) ||
-        ( team == PTE_HUMANS && BG_FindStagesForBuildable( buildable, g_humanStage.integer ) ) ) )
+        ( team == PTE_HUMANS && BG_FindStagesForBuildable( buildable, g_humanStage.integer ) ) ) ))
   {
     dist = BG_FindBuildDistForClass( ent->client->ps.stats[ STAT_PCLASS ] );
 
@@ -2406,7 +3809,210 @@
     trap_SendServerCommand( ent-g_entities, va( "print \"Cannot build this item\n\"" ) );
 }
 
+/*
+=================
+Cmd_Share_f
+=================
+*/
+void Cmd_Share_f( gentity_t *ent )
+{
+  int   i, clientNum = 0, creds = 0, skipargs = 0;
+  int   clientNums[ MAX_CLIENTS ] = { -1 };
+  char  cmd[ 12 ];
+  char  arg1[ MAX_STRING_TOKENS ];
+  char  arg2[ MAX_STRING_TOKENS ];
+  pTeam_t team;
 
+  if( !ent || !ent->client || ( ent->client->pers.teamSelection == PTE_NONE ) )
+  {
+    return;
+  }
+
+  if( !g_allowShare.integer )
+  {
+    return;
+  }
+
+  team = ent->client->pers.teamSelection;
+
+  G_SayArgv( 0, cmd, sizeof( cmd ) );
+  if( !Q_stricmp( cmd, "say" ) || !Q_stricmp( cmd, "say_team" ) )
+  {
+    skipargs = 1;
+    G_SayArgv( 1, cmd, sizeof( cmd ) );
+  }
+
+  // target player name is in arg1
+  G_SayArgv( 1+skipargs, arg1, sizeof( arg1 ) );
+  // amount to be shared is in arg2
+  G_SayArgv( 2+skipargs, arg2, sizeof( arg2 ) );
+
+  if( arg1[0] && !strchr( arg1, ';' ) && Q_stricmp( arg1, "target_in_aim" ) )
+  {
+    //check arg1 is a number
+    for( i = 0; arg1[ i ]; i++ )
+    {
+      if( arg1[ i ] < '0' || arg1[ i ] > '9' )
+      {
+        clientNum = -1;
+        break;
+      }
+    }
+
+    if( clientNum >= 0 )
+    {
+      clientNum = atoi( arg1 );
+    }
+    else if( G_ClientNumbersFromString( arg1, clientNums, MAX_CLIENTS ) == 1 )
+    {
+      // there was one partial name match
+      clientNum = clientNums[ 0 ];
+    }
+    else
+    {
+      // look for an exact name match before bailing out
+      clientNum = G_ClientNumberFromString( ent, arg1 );
+      if( clientNum == -1 )
+      {
+        trap_SendServerCommand( ent-g_entities,
+          "print \"share: invalid player name specified.\n\"" );
+        return;
+      }
+    }
+  }
+  else // arg1 not set
+  {
+    vec3_t      forward, end;
+    trace_t     tr;
+    gentity_t   *traceEnt;
+
+
+    // trace a teammate
+    AngleVectors( ent->client->ps.viewangles, forward, NULL, NULL );
+    VectorMA( ent->client->ps.origin, 8192 * 16, forward, end );
+
+    trap_Trace( &tr, ent->client->ps.origin, NULL, NULL, end, ent->s.number, MASK_OCSOLID );
+    traceEnt = &g_entities[ tr.entityNum ];
+
+    if( tr.fraction < 1.0f && traceEnt->client &&
+      ( traceEnt->client->pers.teamSelection == team ) )
+    {
+      clientNum = traceEnt - g_entities;
+    }
+    else
+    {
+      trap_SendServerCommand( ent-g_entities,
+        va( "print \"share: aim at a teammate to share %s.\n\"",
+        ( team == PTE_HUMANS ) ? "credits" : "evolvepoints" ) );
+      return;
+    }
+  }
+
+  // verify target player team
+  if( ( clientNum < 0 ) || ( clientNum >= level.maxclients ) ||
+      ( level.clients[ clientNum ].pers.teamSelection != team ) )
+  {
+    trap_SendServerCommand( ent-g_entities,
+      "print \"share: not a valid player of your team.\n\"" );
+    return;
+  }
+
+  if( !arg2[0] || strchr( arg2, ';' ) )
+  {
+    // default credit count
+    if( team == PTE_HUMANS )
+    {
+      creds = FREEKILL_HUMAN;
+    }
+    else if( team == PTE_ALIENS )
+    {
+      creds = FREEKILL_ALIEN;
+    }
+  }
+  else
+  {
+    //check arg2 is a number
+    for( i = 0; arg2[ i ]; i++ )
+    {
+      if( arg2[ i ] < '0' || arg2[ i ] > '9' )
+      {
+        trap_SendServerCommand( ent-g_entities,
+          "print \"usage: share [name|slot#] [amount]\n\"" );
+        break;
+      }
+    }
+
+    // credit count from parameter
+    creds = atoi( arg2 );
+  }
+
+  // player specified "0" to transfer
+  if( creds <= 0 )
+  {
+    trap_SendServerCommand( ent-g_entities,
+      "print \"Ooh, you are a generous one, indeed!\n\"" );
+    return;
+  }
+
+  // transfer only credits the player really has
+  if( creds > ent->client->ps.persistant[ PERS_CREDIT ] )
+  {
+    creds = ent->client->ps.persistant[ PERS_CREDIT ];
+  }
+
+  // player has no credits
+  if( creds <= 0 )
+  {
+    trap_SendServerCommand( ent-g_entities,
+      "print \"Earn some first, lazy gal!\n\"" );
+    return;
+  }
+
+  // allow transfers only up to the credit/evo limit
+  if( ( team == PTE_HUMANS ) &&
+      ( creds > HUMAN_MAX_CREDITS - level.clients[ clientNum ].ps.persistant[ PERS_CREDIT ] ) )
+  {
+    creds = HUMAN_MAX_CREDITS - level.clients[ clientNum ].ps.persistant[ PERS_CREDIT ];
+  }
+  else if( ( team == PTE_ALIENS ) &&
+      ( creds > ALIEN_MAX_KILLS - level.clients[ clientNum ].ps.persistant[ PERS_CREDIT ] ) )
+  {
+    creds = ALIEN_MAX_KILLS - level.clients[ clientNum ].ps.persistant[ PERS_CREDIT ];
+  }
+
+  // target cannot take any more credits
+  if( creds <= 0 )
+  {
+    trap_SendServerCommand( ent-g_entities,
+      va( "print \"share: player cannot receive any more %s.\n\"",
+        ( team == PTE_HUMANS ) ? "credits" : "evolvepoints" ) );
+    return;
+  }
+
+  // transfer credits
+  ent->client->ps.persistant[ PERS_CREDIT ] -= creds;
+  trap_SendServerCommand( ent-g_entities,
+    va( "print \"share: transferred %d %s to %s^7.\n\"", creds,
+      ( team == PTE_HUMANS ) ? "credits" : "evolvepoints",
+      level.clients[ clientNum ].pers.netname ) );
+  level.clients[ clientNum ].ps.persistant[ PERS_CREDIT ] += creds;
+  trap_SendServerCommand( clientNum,
+    va( "print \"You have received %d %s from %s^7.\n\"", creds,
+      ( team == PTE_HUMANS ) ? "credits" : "evolvepoints",
+      ent->client->pers.netname ) );
+
+  G_LogPrintf( "Share: %i %i %i %d: %s^7 transferred %d%s to %s^7\n",
+    ent->client->ps.clientNum,
+    clientNum,
+    team,
+    creds,
+    ent->client->pers.netname,
+    creds,
+    ( team == PTE_HUMANS ) ? "c" : "e",
+    level.clients[ clientNum ].pers.netname );
+}
+
+
 /*
 =================
 Cmd_Boost_f
@@ -2421,23 +4027,1562 @@
   if( ent->client->pers.cmd.buttons & BUTTON_WALKING )
     return;
 
-  if( ent->client->ps.stats[ STAT_STAMINA ] > 0 )
+  if( ( ent->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS ) &&
+      ( ent->client->ps.stats[ STAT_STAMINA ] > 0 ) )
     ent->client->ps.stats[ STAT_STATE ] |= SS_SPEEDBOOST;
 }
 
 /*
 =================
+strlcmp
+=================
+*/
+int strlcmp( const char *a, const char *b, int len )
+{
+  const char *string1 = a;
+  const char *string2 = b;
+
+  while( string1 - a < len && string2 - b < len && *string1 && *string2 && *string1 == *string2 && *string1 != '\n' && *string2 != '\n' )
+  {
+    string1++;
+    string2++;
+  }
+
+  return *string1 - *string2;
+}
+
+/*
+=================
+G_SameGuy
+
+Test for another instance (test for guid, ip and admin name)
+=================
+*/
+int G_SameGuy( gentity_t *ent, char *stats )  // there's a segfault somewhere in here
+{
+    char *statsPtr, *ip;
+    char linebuf[ MAX_STRING_CHARS ];
+    char toTest[ MAX_STRING_CHARS ];
+    char realName[ MAX_NAME_LENGTH ] = {""};
+    char pureName[ MAX_NAME_LENGTH ] = {""};
+    char cleanName[ MAX_NAME_LENGTH ] = {""};
+    char userinfo[ MAX_INFO_STRING ];
+    int i = 0, j = 0, l = 0;
+
+    statsPtr = stats;
+
+    trap_GetUserinfo( ent-g_entities, userinfo, sizeof( userinfo ) );
+
+    if( !( ip = Info_ValueForKey( userinfo, "ip" ) ) )
+      return 1;  // if for some reason ip cannot be parsed, return same guy
+
+    G_SanitiseName( ent->client->pers.netname, cleanName );
+    realName[ 0 ] = '\0';
+    pureName[ 0 ] = '\0';
+    cleanName[ 0 ] = '\0';
+    for( i = 0; i < MAX_ADMIN_ADMINS && g_admin_admins[ i ]; i++ )
+    {
+        if( !Q_stricmp( g_admin_admins[ i ]->guid, ent->client->pers.guid ) )
+        {
+            l = g_admin_admins[ i ]->level;
+            G_SanitiseName( g_admin_admins[ i ]->name, pureName );
+            if( Q_stricmp( cleanName, pureName ) )
+            {
+                Q_strncpyz( realName, g_admin_admins[ i ]->name, sizeof( realName ) );
+            }
+            break;
+        }
+    }
+    i = 0;
+    if( realName[0] && pureName[0] )
+        strcpy( realName, pureName );
+    else if( cleanName[0] )
+        strcpy( realName, cleanName );
+    else
+        strcpy( realName, "UnnamedPlayer" );  // How can this happen?
+
+    while( *statsPtr )
+    {
+      if( i >= sizeof( linebuf ) - 1 )
+      {
+        G_Printf( S_COLOR_RED "ERROR: line overflow" );
+        return 0;
+      }
+      linebuf[ i++ ] = *statsPtr;
+      linebuf[ i ]   = '\0';
+      if( *statsPtr == '\n' )
+      {
+        i = 0;
+        while( linebuf[ i++ ] > 1 );  // skip the count
+        while( linebuf[ i++ ] > 1 );  // skip the time
+        while( linebuf[ i++ ] > 1 );  // skip the (aliased) name
+        while( linebuf[ i++ ] > 1 );  // skip the date
+
+        while( linebuf[ i ] > 1 )     // parse and test for the guid
+        {
+            toTest[j++] = linebuf[i++];
+            toTest[j]   = '\0';
+        }
+        if( !Q_stricmp( ent->client->pers.guid, toTest ) )
+          return 1;
+        toTest[ 0 ] = j = 0;
+        while( linebuf[ i++ ] > 1 );  // skip the ip
+//        while( linebuf[ i ] > 1 )     // parse and test for the ip
+//        {
+//            toTest[j++] = linebuf[i++];
+//            toTest[j]   = '\0';
+//        }
+        if( !Q_stricmp( ip, toTest ) )
+          return 1;
+        toTest[ 0 ] = j = 0;
+        while( linebuf[ i ] > 1 )     // parse and test for admin name
+        {
+            toTest[j++] = linebuf[i++];
+            toTest[j]   = '\0';
+        }
+        if( !Q_stricmp( realName, toTest ) )
+          return 1;
+        toTest[ 0 ] = i = j = 0;
+      }
+      statsPtr++;
+    }
+    return 0;
+}
+
+/*
+=================
+G_CompareStats
+=================
+*/
+int G_CompareStats( const char *a, const char *b )
+{
+    int countA;
+    int countB;
+    int scoreA;
+    int scoreB;
+    sscanf( a, "%d %d", &countA, &scoreA );
+    sscanf( b, "%d %d", &countB, &scoreB );
+    if( countA != countB )
+        return countB - countA;
+    else if( scoreA != scoreB )
+        return scoreA - scoreB;
+    else
+        return strcmp( a, b );  // alpha-order: count, time, name, date, guid, ip, adminname
+//    return 0;
+}
+
+/*
+=================
+G_MediStats
+
+Stats format 1 - Incompatible with formats < 1! Stat files need manual update
+'type: variable': a variable of type type
+*seperator*: the seperator char, 0x01
+
+First line is:
+
+'totalArmouries'*seperator*'totalMedistations'
+
+The following lines represent a player record:
+
+'num: count'*seperator*'num: timeInMS'*seperator*'str: date'*seperator*'str: guid'*seperator*'str: ip'*seperator*'str: adminName'
+
+Note: new records must be GREATER than the last record
+=================
+*/
+char *G_MediStats( gentity_t *ent, int count, int time )
+{
+  int   worstCount = level.totalMedistations;   //  ///  ////*************UGLY+
+  int worstTime = 0;
+  char map[ MAX_QPATH ];
+  char fileName[ MAX_OSPATH ];
+  char stat[ MAX_STRING_CHARS ];
+  char stats[ MAX_STRING_CHARS * 8];
+  fileHandle_t f;
+  int len, line = 0, record = 0, i = 0, j = 0, k = 0, ssss;
+  char *statsh, *stats2, *statsh2;
+  char buf[ OC_STATMAXRECORDS ][ MAX_STRING_CHARS ];
+  char data[ OC_STATMAXRECORDS ];
+  char name[ MAX_NAME_LENGTH ] = {""};
+  char realName[ MAX_NAME_LENGTH ] = {""};
+  char pureName[ MAX_NAME_LENGTH ] = {""};
+  char cleanName[ MAX_NAME_LENGTH ] = {""};
+  char date[ MAX_CVAR_VALUE_STRING ] = {""};
+  qtime_t qt;
+  int t;
+  char *ip, *statsPos;
+  char userinfo[ MAX_INFO_STRING ];
+  int l;
+  int records;
+
+  // stats disabled?
+  if( !g_statsEnabled.integer || g_statsRecords.integer <= 0 || g_statsRecords.integer >= OC_STATMAXRECORDS )
+    return "";
+
+  // other checks
+  if( !level.oc )
+    return "";
+
+  if( g_cheats.integer )
+  {
+    G_ClientPrint( ent, "Cannot store record with cheats enabled", 0 );
+    return "";
+  }
+
+  // initialize values
+
+  l = 0;
+  records = ( ( g_statsRecords.integer > 0 ) ? ( g_statsRecords.integer ) : ( 1 ) );
+  G_SanitiseName( ent->client->pers.netname, cleanName );
+  realName[ 0 ] = '\0';
+  pureName[ 0 ] = '\0';
+  cleanName[ 0 ] = '\0';
+  for( i = 0; i < MAX_ADMIN_ADMINS && g_admin_admins[ i ]; i++ )
+  {
+    if( !Q_stricmp( g_admin_admins[ i ]->guid, ent->client->pers.guid ) )
+    {
+      l = g_admin_admins[ i ]->level;
+      G_SanitiseName( g_admin_admins[ i ]->name, pureName );
+      if( Q_stricmp( cleanName, pureName ) )
+      {
+        Q_strncpyz( realName, g_admin_admins[ i ]->name, sizeof( realName ) );
+      }
+      break;
+    }
+  }
+  i = 0;
+  if( realName[0] && pureName[0] )
+    strcpy( realName, pureName );
+  else if( cleanName[0] )
+    strcpy( realName, cleanName );
+  else
+    strcpy( realName, "noname");
+
+  trap_GetUserinfo( ent - g_entities, userinfo, sizeof( userinfo ) );
+  ip = Info_ValueForKey( userinfo, "ip" );
+  if( !ip )
+    return " - ip detection error";
+
+  t = trap_RealTime( &qt );
+  trap_Cvar_VariableStringBuffer( "gamedate", date, sizeof( date ) );
+  strcat( date, va( " %d:%02i", qt.tm_hour, qt.tm_min ) );
+
+  strcpy(name, ent->client->pers.netname);
+  G_SanitiseName( ent->client->pers.netname, name );
+
+  trap_Cvar_VariableStringBuffer( "mapname", map, sizeof( map ) );
+  if( !map[ 0 ] )
+  {
+    G_Printf( "MediStats( ): no map is loaded\n" );
+    return "";
+  }
+  G_ToLowerCase(level.layout);
+  Com_sprintf( fileName, sizeof( fileName ), "stats/%s/%s/med.dat", map, level.layout );
+
+  if( !ip || !Q_stricmp( ip, "noip" ) || !Q_stricmp( ent->client->pers.guid, "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" ) )
+  {
+    trap_SendServerCommand( ent-g_entities, "print \"^3Your client is out of date.  You will ^1NOT^3 be able to set records.  Please replace your client executable with the one at ^2http://trem.tjw.org/backport/^3 and reconnect.\n\"" );
+    return "";
+  }
+
+  // input into stats
+
+  len = trap_FS_FOpenFile( fileName, &f, FS_READ );
+  if( len < 0 )
+  {
+    trap_FS_FCloseFile( f );
+    if( trap_FS_FOpenFile( fileName, &f, FS_APPEND ) < 0 )
+    {
+      trap_FS_FCloseFile( f );
+      G_Printf( "medistats: could not open %s\n", fileName );
+      return "";
+    }
+    else
+    {
+      trap_FS_FCloseFile( f );
+      len = trap_FS_FOpenFile( fileName, &f, FS_READ );
+    }
+  }
+
+  strcpy( stats, va( "%d %d\n", level.totalArmouries, level.totalMedistations ) );
+  statsh    = G_Alloc( len + 1 );
+  trap_FS_Read( statsh, len, f );
+  *( statsh + len ) = '\0';
+  if( len >= MAX_STRING_CHARS * 7 )
+  {
+    G_Free(statsh);
+    return " - overflow caught: file too big";
+  }
+  statsh2 = statsh;
+  while( *statsh2 && *statsh2++ != '\n' );
+  strcat( stats, ( len ) ? ( statsh2 ) : ( "" ) );
+  G_Free( statsh );
+  stats2 = statsPos = stats + strlen( va( "%d %d\n", level.totalArmouries, level.totalMedistations ) );
+
+  trap_FS_FCloseFile( f );
+
+  // update stats in buffer
+    // add the new stat
+    Com_sprintf( stat, sizeof( stat ), "%d%c%d%c%s%c%s%c%s%c%s%c%s\n", count, '\1', time, '\1', name, '\1', date, '\1', ent->client->pers.guid, '\1', ( ( ip ) ? ( ip ) : ( "noip" ) ), '\1', realName );
+
+    // explode into buf
+    while( *stats2 )
+    {
+        buf[line][i++] = *stats2;
+        buf[line][i] = '\0';
+        if( *stats2 == '\n' )
+        {
+            i = 0;
+            if( ++line >= records )
+            {
+                break;
+            }
+        }
+        stats2++;
+    }
+    stats2 = statsPos;
+    qsort( buf, line, MAX_STRING_CHARS, (int(*)())G_CompareStats );
+    // if the same guy has another stat..
+    if( G_SameGuy( ent, stats2 ) )
+    {
+        // iterate through each stat, and return if there is a better time
+        for( i = 0; i < line; i++ )
+        {
+            if( G_SameGuy( ent, buf[ i ] ) )
+            {
+                k = 0;
+                data[ 0 ] = j = 0;
+                while( buf[ i ][ k ] > 1 )  // parse count
+                {
+                    data[j++] = buf[i][k++];
+                    data[j]   = '\0';
+                } k++;
+                ssss = atoi( data );
+                if( ssss > count )
+                    return "";
+
+                data[ 0 ] = j = 0;
+                while( buf[ i ][ k ] > 1 )  // parse time
+                {
+                    data[j++] = buf[i][k++];
+                    data[j]   = '\0';
+                }  k++;
+                if( atoi( data ) < time && ssss == count )
+                    return "";
+            }
+        } i = k = 0;
+        // guy broke his own record, so remove all old records
+        test:  // JMP for duplicates
+        for( i = 0; i < line; i++ )
+        {
+            if( G_SameGuy( ent, buf[ i ] ) )
+            {
+//                while( *stats2 && strlcmp( buf[ i ], *stats2++, MAX_STRING_CHARS ) );
+//                if( !*stats2-- )
+//                    return " - ^1Error removing duplicate stats";  // marker
+//                memmove( stats2, stats2 + strlen( buf[ i ] ) + 1, strlen( buf[ i ] ) + 1 );  // this line is no longer needed
+                memmove( buf[ i ], buf[ i + 1 ], ( line - i ) * sizeof( buf[ 0 ] ) );
+                memset( buf[ line-- ], 0, sizeof( buf[ 0 ] ) );
+                goto test;
+            }
+        }
+    }
+    stats2 = statsPos;
+    // if the guy isn't on the top x, return -- NOTE: removing / beating old records will bypass the list not full check, but if the guy beat a record that's already on the list, the new record is also going to be on the list; changing g_statsRecords will also not affect it, because the old stats have either been truncated before parsing, or more room for records is open anyway; and, if the order is wrong, which should only be possible by manually editing the files, and g_statsRecords is lowered, this will still not be affected just as the previous, but loss of some records data is possible: the records, regardless of order, up to g_statsRecords are going to be parsed and handled. If the order is correct, this would not be a problem, because the worse times will be truncated. Thus manual resorting is hazardous, and not advised.
+    if( line >= records )
+    {
+        for( i = 0; i < line; i++ )
+        {
+            k = 0;
+            data[ 0 ] = j = 0;
+            while( buf[ i ][ k ] > 1 )  // parse count
+            {
+                data[j++] = buf[i][k++];
+                data[j]   = '\0';
+            } k++;
+            if( atoi( data ) <= worstCount )
+                worstCount = atoi( data );
+        } i = k = 0;
+
+        for( i = 0; i < line; i++ )
+        {
+            k = 0;
+            data[ 0 ] = j = 0;
+            while( buf[ i ][ k ] > 1 )  // parse count
+            {
+                data[j++] = buf[i][k++];
+                data[j]   = '\0';
+            } k++;
+            data[ 0 ] = j = 0;
+            if( atoi( data ) <= worstCount )
+            {
+              while( buf[ i ][ k ] > 1 )  // parse time
+              {
+                  data[j++] = buf[i][k++];
+                  data[j]   = '\0';
+              } k++;
+              if( atoi( data ) >= worstTime )
+                  worstTime = atoi( data );
+            }
+        } i = k = 0;
+
+        if( count < worstCount )
+            return "";
+        if( count == worstCount && time > worstTime )
+            return "";
+    }
+    // add the record - if there's no space, remove the last records until there is (since the list was sorted, old scores can be truncated.  See previous comment for data loss details)
+    while( line >= records )
+    {
+        memset( buf[ --line ], 0, sizeof( buf[ 0 ] ) );
+    }
+    strcpy( buf[ line++ ], stat );
+    // truncate -- Not needed
+    // sort
+    qsort( buf, line, MAX_STRING_CHARS, (int(*)())G_CompareStats );
+    // parse for the record # - if not found, return
+    record = 0;
+    for( i = 0; i < line; i++ )
+    {
+        record++;
+        if( !strlcmp( buf[ i ], stat, sizeof( buf[ 0 ] ) ) )
+        {
+            break;
+        }
+    }
+    if( record <= 0 )
+        return " - ^1Error retrieving record id, not saving stat";
+    // implode buf into stats
+    stats2 = statsPos;
+    memset( stats2, 0, sizeof( stats ) - ( stats2 - stats ) );
+    for( i = 0; i < line; i++ )
+    {
+        strcat( stats2, buf[ i ] );
+    }
+    //
+  // output updated stats
+  len = trap_FS_FOpenFile( fileName, &f, FS_WRITE );
+  if( len < 0 )
+  {
+    G_Printf( "medistats: could not open %s\n", fileName );
+    return "";
+  }
+  stats2 = statsPos;
+
+  G_Printf("medistats: saving stats to %s\n", fileName );
+
+  trap_FS_Write( stats, strlen( stats ), f );
+
+  trap_FS_FCloseFile( f );
+
+  if( record )
+  {
+    char *s = G_Alloc(MAX_STRING_CHARS);
+    Com_sprintf(s, MAX_STRING_CHARS, " ^s^f^r^e^e^2New Record!: #%d^7", record);
+    return s;
+  }
+  return "";
+}
+
+/*
+=================
+G_WinStats
+=================
+*/
+char *G_WinStats( gentity_t *ent, int count, int time )
+{
+  int   worstCount = level.totalArmouries;   //  ///  ////*************UGLY+
+  int worstTime = 0;
+  char map[ MAX_QPATH ];
+  char fileName[ MAX_OSPATH ];
+  char stat[ MAX_STRING_CHARS ];
+  char stats[ MAX_STRING_CHARS * 8];
+  fileHandle_t f;
+  int len, line = 0, record = 0, i = 0, j = 0, k = 0, ssss;
+  char *statsh, *stats2, *statsh2;
+  char buf[ OC_STATMAXRECORDS ][ MAX_STRING_CHARS ];
+  char data[ OC_STATMAXRECORDS ];
+  char name[ MAX_NAME_LENGTH ] = {""};
+  char realName[ MAX_NAME_LENGTH ] = {""};
+  char pureName[ MAX_NAME_LENGTH ] = {""};
+  char cleanName[ MAX_NAME_LENGTH ] = {""};
+  char date[ MAX_CVAR_VALUE_STRING ] = {""};
+  qtime_t qt;
+  int t;
+  char *ip, *statsPos;
+  char userinfo[ MAX_INFO_STRING ];
+  int l;
+  int records;
+
+  // stats disabled?
+  if( !g_statsEnabled.integer || g_statsRecords.integer <= 0 || g_statsRecords.integer > OC_STATMAXRECORDS )
+    return "";
+
+  // other checks
+  if( !level.oc )
+    return "";
+
+  if( g_cheats.integer )
+  {
+    G_ClientPrint( ent, "Cannot store record with cheats enabled", 0 );
+    return "";
+  }
+
+  // initialize values
+
+  l = 0;
+  records = ( ( g_statsRecords.integer > 0 ) ? ( g_statsRecords.integer ) : ( 1 ) );
+  G_SanitiseName( ent->client->pers.netname, cleanName );
+  realName[ 0 ] = '\0';
+  pureName[ 0 ] = '\0';
+  cleanName[ 0 ] = '\0';
+  for( i = 0; i < MAX_ADMIN_ADMINS && g_admin_admins[ i ]; i++ )
+  {
+    if( !Q_stricmp( g_admin_admins[ i ]->guid, ent->client->pers.guid ) )
+    {
+      l = g_admin_admins[ i ]->level;
+      G_SanitiseName( g_admin_admins[ i ]->name, pureName );
+      if( Q_stricmp( cleanName, pureName ) )
+      {
+        Q_strncpyz( realName, g_admin_admins[ i ]->name, sizeof( realName ) );
+      }
+      break;
+    }
+  }
+  i = 0;
+  if( realName[0] && pureName[0] )
+    strcpy( realName, pureName );
+  else if( cleanName[0] )
+    strcpy( realName, cleanName );
+  else
+    strcpy( realName, "noname");
+
+  trap_GetUserinfo( ent - g_entities, userinfo, sizeof( userinfo ) );
+  ip = Info_ValueForKey( userinfo, "ip" );
+  if( !ip )
+    return " - ip detection error";
+
+  t = trap_RealTime( &qt );
+  trap_Cvar_VariableStringBuffer( "gamedate", date, sizeof( date ) );
+  strcat( date, va( " %d:%02i", qt.tm_hour, qt.tm_min ) );
+
+  strcpy(name, ent->client->pers.netname);
+  G_SanitiseName( ent->client->pers.netname, name );
+
+  trap_Cvar_VariableStringBuffer( "mapname", map, sizeof( map ) );
+  if( !map[ 0 ] )
+  {
+    G_Printf( "WinStats( ): no map is loaded\n" );
+    return "";
+  }
+  G_ToLowerCase(level.layout);
+  Com_sprintf( fileName, sizeof( fileName ), "stats/%s/%s/win.dat", map, level.layout );
+
+  if( !ip || !Q_stricmp( ip, "noip" ) || !Q_stricmp( ent->client->pers.guid, "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" ) )
+  {
+    trap_SendServerCommand( ent-g_entities, "print \"^3Your client is out of date.  You will ^1NOT^3 be able to set records.  Please replace your client executable with the one at ^2http://trem.tjw.org/backport/^3 and reconnect.\n\"" );
+    return "";
+  }
+
+  // input into stats
+
+  len = trap_FS_FOpenFile( fileName, &f, FS_READ );
+  if( len < 0 )
+  {
+    trap_FS_FCloseFile( f );
+    if( trap_FS_FOpenFile( fileName, &f, FS_APPEND ) < 0 )
+    {
+      trap_FS_FCloseFile( f );
+      G_Printf( "winstats: could not open %s\n", fileName );
+      return "";
+    }
+    else
+    {
+      trap_FS_FCloseFile( f );
+      len = trap_FS_FOpenFile( fileName, &f, FS_READ );
+    }
+  }
+
+  strcpy( stats, va( "%d %d\n", level.totalArmouries, level.totalMedistations ) );
+  statsh    = G_Alloc( len + 1 );
+  trap_FS_Read( statsh, len, f );
+  *( statsh + len ) = '\0';
+  if( len >= MAX_STRING_CHARS * 7 )
+  {
+    G_Free(statsh);
+    return " - overflow caught: file too big";
+  }
+  statsh2 = statsh;
+  while( *statsh2 && *statsh2++ != '\n' );
+  strcat( stats, ( len ) ? ( statsh2 ) : ( "" ) );
+  G_Free( statsh );
+  stats2 = statsPos = stats + strlen( va( "%d %d\n", level.totalArmouries, level.totalMedistations ) );
+
+  trap_FS_FCloseFile( f );
+
+  // update stats in buffer
+    // add the new stat
+    Com_sprintf( stat, sizeof( stat ), "%d%c%d%c%s%c%s%c%s%c%s%c%s\n", count, '\1', time, '\1', name, '\1', date, '\1', ent->client->pers.guid, '\1', ( ( ip ) ? ( ip ) : ( "noip" ) ), '\1', realName );
+
+    // explode into buf
+    while( *stats2 )
+    {
+        buf[line][i++] = *stats2;
+        buf[line][i] = '\0';
+        if( *stats2 == '\n' )
+        {
+            i = 0;
+            if( ++line >= records )
+            {
+                break;
+            }
+        }
+        stats2++;
+    }
+    stats2 = statsPos;
+    qsort( buf, line, MAX_STRING_CHARS, (int(*)())G_CompareStats );
+    // if the same guy has another stat..
+    if( G_SameGuy( ent, stats2 ) )
+    {
+        // iterate through each stat, and return if there is a better time
+        for( i = 0; i < line; i++ )
+        {
+            if( G_SameGuy( ent, buf[ i ] ) )
+            {
+                k = 0;
+                data[ 0 ] = j = 0;
+                while( buf[ i ][ k ] > 1 )  // parse count
+                {
+                    data[j++] = buf[i][k++];
+                    data[j]   = '\0';
+                } k++;
+                ssss = atoi( data );
+                if( ssss > count )
+                    return "";
+
+                data[ 0 ] = j = 0;
+                while( buf[ i ][ k ] > 1 )  // parse time
+                {
+                    data[j++] = buf[i][k++];
+                    data[j]   = '\0';
+                }  k++;
+                if( atoi( data ) < time && ssss == count )
+                    return "";
+            }
+        } i = k = 0;
+        // guy broke his own record, so remove all old records
+        test:  // JMP for duplicates
+        for( i = 0; i < line; i++ )
+        {
+            if( G_SameGuy( ent, buf[ i ] ) )
+            {
+//                while( *stats2 && strlcmp( buf[ i ], *stats2++, MAX_STRING_CHARS ) );
+//                if( !*stats2-- )
+//                    return " - ^1Error removing duplicate stats";  // marker
+//                memmove( stats2, stats2 + strlen( buf[ i ] ) + 1, strlen( buf[ i ] ) + 1 );  // this line is no longer needed
+                memmove( buf[ i ], buf[ i + 1 ], ( line - i ) * sizeof( buf[ 0 ] ) );
+                memset( buf[ line-- ], 0, sizeof( buf[ 0 ] ) );
+                goto test;
+            }
+        }
+    }
+    stats2 = statsPos;
+    // if the guy isn't on the top x, return -- NOTE: removing / beating old records will bypass the list not full check, but if the guy beat a record that's already on the list, the new record is also going to be on the list; changing g_statsRecords will also not affect it, because the old stats have either been truncated before parsing, or more room for records is open anyway; and, if the order is wrong, which should only be possible by manually editing the files, and g_statsRecords is lowered, this will still not be affected just as the previous, but loss of some records data is possible: the records, regardless of order, up to g_statsRecords are going to be parsed and handled. If the order is correct, this would not be a problem, because the worse times will be truncated. Thus manual resorting is hazardous, and not advised.
+    if( line >= records )
+    {
+        for( i = 0; i < line; i++ )
+        {
+            k = 0;
+            data[ 0 ] = j = 0;
+            while( buf[ i ][ k ] > 1 )  // parse count
+            {
+                data[j++] = buf[i][k++];
+                data[j]   = '\0';
+            } k++;
+            if( atoi( data ) <= worstCount )
+                worstCount = atoi( data );
+        } i = k = 0;
+
+        for( i = 0; i < line; i++ )
+        {
+            k = 0;
+            data[ 0 ] = j = 0;
+            while( buf[ i ][ k ] > 1 )  // parse count
+            {
+                data[j++] = buf[i][k++];
+                data[j]   = '\0';
+            } k++;
+            data[ 0 ] = j = 0;
+            if( atoi( data ) <= worstCount )
+            {
+              while( buf[ i ][ k ] > 1 )  // parse time
+              {
+                  data[j++] = buf[i][k++];
+                  data[j]   = '\0';
+              } k++;
+              if( atoi( data ) >= worstTime )
+                  worstTime = atoi( data );
+            }
+        } i = k = 0;
+
+        if( count < worstCount )
+            return "";
+        if( count == worstCount && time > worstTime )
+            return "";
+    }
+    // add the record - if there's no space, remove the last records until there is (since the list was sorted, old scores can be truncated.  See previous comment for data loss details)
+    while( line >= records )
+    {
+        memset( buf[ --line ], 0, sizeof( buf[ 0 ] ) );
+    }
+    strcpy( buf[ line++ ], stat );
+    // truncate -- Not needed
+    // sort
+    qsort( buf, line, MAX_STRING_CHARS, (int(*)())G_CompareStats );
+    // parse for the record # - if not found, return
+    record = 0;
+    for( i = 0; i < line; i++ )
+    {
+        record++;
+        if( !strlcmp( buf[ i ], stat, sizeof( buf[ 0 ] ) ) )
+        {
+            break;
+        }
+    }
+    if( record <= 0 )
+        return " - ^1Error retrieving record id, not saving stat";
+    // implode buf into stats
+    stats2 = statsPos;
+    memset( stats2, 0, sizeof( stats ) - ( stats2 - stats ) );
+    for( i = 0; i < line; i++ )
+    {
+        strcat( stats2, buf[ i ] );
+    }
+    //
+  // output updated stats
+
+  len = trap_FS_FOpenFile( fileName, &f, FS_WRITE );
+  if( len < 0 )
+  {
+    G_Printf( "winstats: could not open %s\n", fileName );
+    return "";
+  }
+  stats2 = statsPos;
+
+  G_Printf("winstats: saving stats to %s\n", fileName );
+
+  trap_FS_Write( stats, strlen( stats ), f );
+
+  trap_FS_FCloseFile( f );
+
+  if( record )
+  {
+    char *s = G_Alloc(MAX_STRING_CHARS);
+    Com_sprintf(s, MAX_STRING_CHARS, " ^s^f^r^e^e^2New Record!: #%d^7", record);
+    return s;
+  }
+  return "";
+}
+
+/*
+=================
+Cmd_Mystats_f
+=================
+*/
+void Cmd_Mystats_f( gentity_t *ent )
+{
+  gentity_t *client;
+  char color[ MAX_STRING_CHARS ];
+  int percent, i;
+  if( level.ocLoadTime || !ent || !ent->client )
+    return;
+  if( g_floodMinTime.integer )
+    if ( G_Flood_Limited( ent ) )
+    {
+      trap_SendServerCommand( ent-g_entities, "print \"Your chat is flood-limited; wait before chatting again\n\"" );
+      return;
+    }
+  G_ClientPrint(ent, "Your Obstacle Course Information--", 0);
+  if( ent->client->pers.ocTeam )
+  {
+    if( level.ocScrimState > OC_STATE_PREP)
+    {
+        if(level.ocScrimMode == OC_MODE_ARM && level.totalArmouries && level.scrimTeam[ent->client->pers.ocTeam].arms)
+        {
+            gentity_t **tmp = G_Alloc( level.totalArmouries * sizeof( gentity_t * ) );
+            memcpy(tmp, level.scrimTeam[ent->client->pers.ocTeam].arms, level.totalArmouries * sizeof( gentity_t * ));  // memcpy should be faster than merge itself
+            for(i = 0; i < MAX_CLIENTS; i++)
+            {
+                client = g_entities + i;
+
+                if(client->client && client->client->pers.ocTeam == ent->client->pers.ocTeam)
+                    G_MergeArms(tmp, client->client->pers.arms);
+            }
+
+            percent = (int)( 100 * (G_NumberOfArms(tmp)) / (level.totalArmouries) );
+            if(percent < 50)
+            {
+                Q_strncpyz(color, "^1", sizeof(color));
+            }
+            else if(percent < 100)
+            {
+                Q_strncpyz(color, "^3", sizeof(color));
+            }
+            else
+            {
+                Q_strncpyz(color, "^2", sizeof(color));
+            }
+
+            if(level.totalArmouries == 1 || G_TestLayoutFlag(level.layout, OCFL_ONEARM))
+            {
+                if(G_NumberOfArms(tmp))
+                {
+                    G_ClientPrint(ent, va("Armouries: ^2Win^7 - %dm%ds%dms)", MINS(level.scrimTeam[ent->client->pers.ocTeam].time - (level.ocStartTime + g_ocWarmup.integer)), SECS(level.scrimTeam[ent->client->pers.ocTeam].time - (level.ocStartTime + g_ocWarmup.integer)), MSEC(level.scrimTeam[ent->client->pers.ocTeam].time - (level.ocStartTime + g_ocWarmup.integer))), 0);
+                }
+                else
+                {
+                    G_ClientPrint(ent, "Armouries: ^1None", 0);
+                }
+            }
+            else if(G_AllArms(ent->client->pers.arms))
+            {
+                G_ClientPrint(ent, va("Armouries: %d/%d (%s%d^7 percent) - ^2%dm%ds%dms", G_NumberOfArms(tmp), level.totalArmouries, color, percent, MINS(level.scrimTeam[ent->client->pers.ocTeam].time - (level.ocStartTime + g_ocWarmup.integer)), SECS(level.scrimTeam[ent->client->pers.ocTeam].time - (level.ocStartTime + g_ocWarmup.integer)), MSEC(level.scrimTeam[ent->client->pers.ocTeam].time - (level.ocStartTime + g_ocWarmup.integer))), 0);
+            }
+            else
+            {
+                G_ClientPrint(ent, va("Armouries: %d/%d (%s%d^7 percent)", G_NumberOfArms(tmp), level.totalArmouries, color, percent), 0);
+            }
+
+            G_Free(tmp);
+        }
+        else if(level.ocScrimMode == OC_MODE_MEDI && level.totalMedistations && level.scrimTeam[ent->client->pers.ocTeam].medis)
+        {
+            gentity_t **tmp = G_Alloc( level.totalMedistations * sizeof( gentity_t * ) );
+            memcpy(tmp, level.scrimTeam[ent->client->pers.ocTeam].medis, level.totalMedistations * sizeof( gentity_t * ));  // memcpy should be faster than merge itself
+            for(i = 0; i < MAX_CLIENTS; i++)
+            {
+                client = g_entities + i;
+
+                if(client->client && client->client->pers.ocTeam == ent->client->pers.ocTeam)
+                    G_MergeMedis(tmp, client->client->pers.medis);
+            }
+
+            percent = (int)( 100 * (G_NumberOfMedis(tmp)) / (level.totalMedistations) );
+            if(percent < 50)
+            {
+                Q_strncpyz(color, "^1", sizeof(color));
+            }
+            else if(percent < 100)
+            {
+                Q_strncpyz(color, "^3", sizeof(color));
+            }
+            else
+            {
+                Q_strncpyz(color, "^2", sizeof(color));
+            }
+
+            G_ClientPrint(ent, va("Medical Stations: %d/%d (%s%d^7 percent)%s", G_NumberOfMedis(tmp), level.totalMedistations, color, percent, G_AllMedis(tmp) ? va(" - ^2%dm%ds%dms", MINS(level.scrimTeam[ent->client->pers.ocTeam].time - (level.ocStartTime + g_ocWarmup.integer)), SECS(level.scrimTeam[ent->client->pers.ocTeam].time - (level.ocStartTime + g_ocWarmup.integer)), MSEC(level.scrimTeam[ent->client->pers.ocTeam].time - (level.ocStartTime + g_ocWarmup.integer))) : ("")), 0);
+
+            G_Free(tmp);
+        }
+    }
+    return;
+  }
+  else
+  {
+    if(level.totalArmouries && ent->client->pers.arms)
+    {
+        percent = (int)( 100 * (G_NumberOfArms(ent->client->pers.arms)) / (level.totalArmouries) );
+        if(percent < 50)
+        {
+            Q_strncpyz(color, "^1", sizeof(color));
+        }
+        else if(percent < 100)
+        {
+            Q_strncpyz(color, "^3", sizeof(color));
+        }
+        else
+        {
+            Q_strncpyz(color, "^2", sizeof(color));
+        }
+
+        if(level.totalArmouries == 1 || G_TestLayoutFlag(level.layout, OCFL_ONEARM))
+        {
+            if(G_NumberOfArms(ent->client->pers.arms))
+            {
+                G_ClientPrint(ent, va("Armouries: ^2Win^7 - %dm%ds%dms)", MINS(ent->client->pers.winTime), SECS(ent->client->pers.winTime), MSEC(ent->client->pers.winTime)), 0);
+            }
+            else
+            {
+                G_ClientPrint(ent, "Armouries: ^1None", 0);
+            }
+        }
+        else if(G_AllArms(ent->client->pers.arms))
+        {
+            G_ClientPrint(ent, va("Armouries: %d/%d (%s%d^7 percent) - ^2%dm%ds%dms", G_NumberOfArms(ent->client->pers.arms), level.totalArmouries, color, percent, MINS(ent->client->pers.winTime), SECS(ent->client->pers.winTime), MSEC(ent->client->pers.winTime)), 0);
+        }
+        else
+        {
+            G_ClientPrint(ent, va("Armouries: %d/%d (%s%d^7 percent)", G_NumberOfArms(ent->client->pers.arms), level.totalArmouries, color, percent), 0);
+        }
+    }
+    if(level.totalMedistations && ent->client->pers.medis)
+    {
+        percent = (int)( 100 * (G_NumberOfMedis(ent->client->pers.medis)) / (level.totalMedistations) );
+        if(percent < 50)
+        {
+            Q_strncpyz(color, "^1", sizeof(color));
+        }
+        else if(percent < 100)
+        {
+            Q_strncpyz(color, "^3", sizeof(color));
+        }
+        else
+        {
+            Q_strncpyz(color, "^2", sizeof(color));
+        }
+
+        G_ClientPrint(ent, va("Medical Stations: %d/%d (%s%d^7 percent)%s", G_NumberOfMedis(ent->client->pers.medis), level.totalMedistations, color, percent, G_AllMedis(ent->client->pers.medis) ? va(" - ^2%dm%ds%dms", MINS(ent->client->pers.mediTime), SECS(ent->client->pers.mediTime), MSEC(ent->client->pers.mediTime)) : ("")), 0);
+    }
+  }
+}
+
+/*
+=================
+Cmd_Stats_f
+=================
+*/
+void Cmd_Stats_f( gentity_t *ent )
+{
+  fileHandle_t f;
+  int arms = 0;
+  int medis = 0;
+  int  len, i=0, j=0;
+  char arg1[ MAX_STRING_TOKENS ];
+  char arg2[ MAX_STRING_TOKENS ];
+  char *statsWin, *statsMedi, *statsWinPtr, *statsMediPtr;
+  char *linePtr;
+//  char *linePtr2;
+  char map[ MAX_QPATH ];
+  char layout[ MAX_QPATH ];
+  char fileName[ MAX_OSPATH ];
+  char line[ MAX_STRING_CHARS ];
+  char name[ MAX_STRING_CHARS ];
+  char dateTime[ MAX_STRING_CHARS ];
+  char data[ MAX_STRING_CHARS ];
+  int  score, record, count;
+
+  trap_Argv( 1, arg1, sizeof( arg1 ) );
+  trap_Argv( 2, arg2, sizeof( arg2 ) );
+
+  if( level.ocLoadTime || !ent || !ent->client )
+    return;
+  if( g_floodMinTime.integer )
+    if ( G_Flood_Limited( ent ) )
+    {
+      trap_SendServerCommand( ent-g_entities, "print \"Your chat is flood-limited; wait before chatting again\n\"" );
+      return;
+    }
+
+  if( strchr( arg1, ';' ) || strchr( arg2, ';' ) || strchr( arg1, '/' ) || strchr( arg2, '/' ) || strchr( arg1, '\\' ) || strchr( arg2, '\\' ) || strchr( arg1, '\"' ) || strchr( arg2, '\"' ) )
+  {
+    trap_SendServerCommand( ent-g_entities, "print \"Invalid stat string\n\"" );
+    return;
+  }
+
+  if( g_floodMinTime.integer )
+    if ( G_Flood_Limited( ent ) )
+    {
+      trap_SendServerCommand( ent-g_entities, "print \"Your chat is flood-limited; wait before chatting again\n\"" );
+      return;
+    }
+
+  if( trap_Argc( ) > 4 || trap_Argc( ) < 1 )
+  {
+    ADMP( "stats: Usage:\n/stats: see current oc stats\n/stats mapname: see mapname with layout oc's stats\n/stats mapname layoutname: see mapname with layoutname's stats\n/stats mapname layoutname more: a third argument will give more details of records" );
+    return;
+  }
+
+  if( trap_Argc( ) < 2 )
+    trap_Cvar_VariableStringBuffer( "mapname", map, sizeof( map ) );
+  else if( trap_Argc( ) <= 4 )
+    Q_strncpyz( map, arg1, sizeof( map ) );
+  else
+    return;
+  if( trap_Argc( ) == 3 || trap_Argc( ) == 4 )
+    Q_strncpyz( layout, arg2, sizeof( layout ) );
+  else if( trap_Argc( ) == 2 )
+    strcpy( layout, "oc" );
+  else if( trap_Argc( ) < 2 )
+    Q_strncpyz( layout, level.layout, sizeof( layout ) );
+  else
+    return;
+  Com_sprintf( fileName, sizeof( fileName ), "stats/%s/%s/win.dat", map, layout );
+
+  len = trap_FS_FOpenFile( fileName, &f, FS_READ );
+  if( len < 0 )
+  {
+    trap_FS_FCloseFile( f );
+    if( level.totalArmouries <= 0 && trap_Argc( ) <= 2 )
+    {
+        if( trap_FS_FOpenFile( fileName, &f, FS_APPEND ) < 0 )
+        {
+            trap_FS_FCloseFile( f );
+            ADMP( "stat: No records (needs at least 1 medi record)\n" );
+            return;
+        }
+        else
+        {
+          trap_FS_Write( va( "%d %d\n", level.totalArmouries, level.totalMedistations ), strlen( va( "%d %d\n", level.totalArmouries, level.totalMedistations ) ), f );
+          trap_FS_FCloseFile( f );
+          len = trap_FS_FOpenFile( fileName, &f, FS_READ );
+        }
+    }
+    else
+    {
+      ADMP( "stat: No records (needs at least 1 medi and arm record)\n" );
+      return;
+    }
+  }
+  statsWin = G_Alloc( len + 1 );
+  statsWinPtr = statsWin;
+  trap_FS_Read( statsWin, len, f );
+  *( statsWin + len ) = '\0';
+  trap_FS_FCloseFile( f );
+
+  Com_sprintf( fileName, sizeof( fileName ), "stats/%s/%s/med.dat", map, layout );
+
+  len = trap_FS_FOpenFile( fileName, &f, FS_READ );
+  if( len < 0 )
+  {
+    trap_FS_FCloseFile( f );
+    if( level.totalMedistations <= 0 && !level.ocLoadTime && trap_Argc( ) <= 2 )
+    {
+        if( trap_FS_FOpenFile( fileName, &f, FS_APPEND ) < 0 )
+        {
+            trap_FS_FCloseFile( f );
+            ADMP( "stat: No records (needs at least 1 arm record)\n" );
+            return;
+        }
+        else
+        {
+          trap_FS_Write( va( "%d %d\n", level.totalArmouries, level.totalMedistations ), strlen( va( "%d %d\n", level.totalArmouries, level.totalMedistations ) ), f );
+          trap_FS_FCloseFile( f );
+          len = trap_FS_FOpenFile( fileName, &f, FS_READ );
+        }
+    }
+    else
+    {
+      ADMP( "stat: No records (needs at least 1 medi and arm record)\n" );
+      return;
+    }
+  }
+  statsMedi = G_Alloc( len + 1 );
+  statsMediPtr = statsMedi;
+  trap_FS_Read( statsMedi, len, f );
+  *( statsMedi + len ) = '\0';
+  trap_FS_FCloseFile( f );
+
+  data[ 0 ] = i = j = 0;
+  while( *statsWinPtr > 1 && *statsWinPtr != ' ' && *statsWinPtr != '\n' && i < MAX_STRING_CHARS )  // parse total arms
+  {
+    data[ i++ ] = *statsWinPtr++;
+    data[ i ] = 0;
+  } statsWinPtr++; i = j = 0;
+  while( *statsWinPtr > 1 && *statsWinPtr != ' ' && *statsWinPtr != '\n' && i < MAX_STRING_CHARS ) statsWinPtr++;  // skip total medis
+  ;;statsWinPtr++; i = j = 0;
+  arms = atoi( data );
+
+  data[ 0 ] = i = j = 0;
+  while( *statsMediPtr > 1 && *statsMediPtr != ' ' && *statsMediPtr != '\n' && i < MAX_STRING_CHARS ) statsMediPtr++;  // skip total arms
+  ;;statsMediPtr++; i = j = 0;
+  while( *statsMediPtr > 1 && *statsMediPtr != ' ' && *statsMediPtr != '\n' && i < MAX_STRING_CHARS )  // parse total medis
+  {
+    data[ i++ ] = *statsMediPtr++;
+    data[ i ] = 0;
+  } statsMediPtr++; i = j = 0;
+
+  medis = atoi( data );
+
+  if( medis > 0 )
+  {
+    if( trap_Argc( ) < 4 )
+      trap_SendServerCommand( ent - g_entities, va( "print \"%s %s Most Medical Stations Used\n\n---\nName - Count - Time\n\n\"", map, layout ) );
+    else
+      trap_SendServerCommand( ent - g_entities, va( "print \"%s %s Most Medical Stations Used\n\n---\nName - Count - Time - Date\n\n\"", map, layout ) );
+    i = 0;
+    record = 0;
+    while( *statsMediPtr )
+    {
+      if( i >= sizeof( line ) - 1 )
+      {
+        G_Free( statsWin );
+        G_Free( statsMedi );
+        G_Printf( S_COLOR_RED "ERROR: line overflow in %s before \"%s\"\n",
+         va( "stats/%s/%s/med.dat", map, layout ), line );
+        return;
+      }
+      line[ i++ ] = *statsMediPtr;
+      line[ i ] = '\0';
+      if( *statsMediPtr == '\n' )
+      {
+        i = j = 0;
+//        sscanf( line, "%d %d", &count, &score );
+        linePtr = line;
+        count = atoi(linePtr++);
+        while( *linePtr && *linePtr > 1) linePtr++;
+        if(*linePtr) linePtr++;
+        score = atoi(linePtr);
+        linePtr = line;
+//        linePtr2 = line;  // originally used to put a terminator after name
+        for( i = 0; i < 2; i++ ) // twice to skip first two numbers
+        {
+          while( *linePtr && *linePtr >  1 )
+          {
+            linePtr++;
+          }
+          while( *linePtr && *linePtr <= 1 )
+          {
+            linePtr++;
+          }
+//          while( *linePtr2 && *linePtr2 != '\n' )
+//          {
+//            linePtr2++;
+//          }
+//          while( *linePtr2 && *linePtr2 == '\n' )
+//          {
+//            *(linePtr2++) = '\0';
+//          }
+        } i = 0;
+        name[0] = '\0';
+        dateTime[0] = '\0';
+        while( i + 1 < MAX_STRING_CHARS && linePtr[i] > 1 )
+        {
+          name[i] = linePtr[i];
+          i++;
+          name[i] = '\0';
+        }
+        if( linePtr[i++] )
+        while( j + 1 < MAX_STRING_CHARS && i + 1 < MAX_STRING_CHARS && linePtr[i] > 1 )
+        {
+          dateTime[j++] = linePtr[i++];
+          dateTime[j] = '\0';
+        } i = j = 0;
+        record++;
+        if( trap_Argc( ) < 4 )
+//, score / 60000, ( score - ( ( score / 60000 ) * 60000 ) ) / 1000, score - ( ( score / 1000 ) * 1000 ) )
+          trap_SendServerCommand( ent - g_entities, va( "print \"^7#^7%d^7: ^7%s^7 - %d/%d ^7%dm:%ds:%dms^7\n\"", record, name, count, medis, MINS( score ), SECS( score ), MSEC( score ) ) );
+        else
+          trap_SendServerCommand( ent - g_entities, va( "print \"^7#^7%d^7: ^7%s^7 - %d/%d ^7%dm:%ds:%dms^7 - %s^7\n\"", record, name, count, medis, MINS( score ), SECS( score ), MSEC( score ), dateTime ) );
+      }
+      statsMediPtr++;
+    }
+  }
+  else
+  {
+    trap_SendServerCommand( ent-g_entities, va( "print \"No Medical Stations\n\"" ) );
+  }
+
+  if( arms > 0 )
+  {
+    if( trap_Argc( ) < 4 )
+      trap_SendServerCommand( ent - g_entities, va( "print \"\n\n\n%s %s Best Winning Times\n\n---\nName - Time\n\n\"", map, layout ) );
+    else
+      trap_SendServerCommand( ent - g_entities, va( "print \"\n\n\n%s %s Best Winning Times\n\n---\nName - Time - Date\n\n\"", map, layout ) );
+
+    i = 0;
+    record = 0;
+
+    while( *statsWinPtr )
+    {
+      if( i >= sizeof( line ) - 1 )
+      {
+        G_Free( statsWin );
+        G_Free( statsMedi );
+        G_Printf( S_COLOR_RED "ERROR: line overflow in %s before \"%s\"\n",
+         va( "stats/%s/%s/win.dat", map, layout ), line );
+        return;
+      }
+      line[ i++ ] = *statsWinPtr;
+      line[ i ] = '\0';
+      if( *statsWinPtr == '\n' )
+      {
+        i = j = 0;
+//        sscanf( line, "%d %d", &count, &score );
+        linePtr = line;
+        count = atoi(linePtr++);
+        while( *linePtr && *linePtr > 1) linePtr++;
+        if(*linePtr) linePtr++;
+        score = atoi(linePtr);
+        linePtr = line;
+//        linePtr2 = line;  // originally used to put a terminator after name
+        for( i = 0; i < 2; i++ ) // twice to skip first two numbers
+        {
+          while( *linePtr && *linePtr >  1 )
+          {
+            linePtr++;
+          }
+          while( *linePtr && *linePtr <= 1 )
+          {
+            linePtr++;
+          }
+//          while( *linePtr2 && *linePtr2 != '\n' )
+//          {
+//            linePtr2++;
+//          }
+//          while( *linePtr2 && *linePtr2 == '\n' )
+//          {
+//            *(linePtr2++) = '\0';
+//          }
+        } i = 0;
+        name[0] = '\0';
+        dateTime[0] = '\0';
+        while( i + 1 < MAX_STRING_CHARS && linePtr[i] > 1 )
+        {
+          name[i] = linePtr[i];
+          i++;
+          name[i] = '\0';
+        }
+        if( linePtr[i++] )
+        while( j + 1 < MAX_STRING_CHARS && i + 1 < MAX_STRING_CHARS && linePtr[i] > 1 )
+        {
+          dateTime[j++] = linePtr[i++];
+          dateTime[j] = '\0';
+        } i = j = 0;
+        record++;
+        if( trap_Argc( ) < 4 )
+          trap_SendServerCommand( ent - g_entities, va( "print \"^7#^7%d^7: ^7%s^7 - ^7%dm:%ds:%dms^7\n\"", record, name, MINS( score ), SECS( score ), MSEC( score ) ) );
+        else
+          trap_SendServerCommand( ent - g_entities, va( "print \"^7#^7%d^7: ^7%s^7 - ^7%dm:%ds:%dms^7 - %s^7\n\"", record, name, MINS( score ), SECS( score ), MSEC( score ), dateTime ) );
+      }
+      statsWinPtr++;
+    }
+  }
+  else
+  {
+    trap_SendServerCommand( ent-g_entities, va( "print \"No Armouries\n\"" ) );
+  }
+
+  G_Free( statsMedi );
+  G_Free( statsWin );
+}
+
+/*
+=================
+Cmd_Spawnup_f
+=================
+*/
+void Cmd_Spawnup_f( gentity_t *ent )
+{
+  vec3_t      forward, end;
+  trace_t     tr;
+  gentity_t   *traceEnt;
+
+  AngleVectors( ent->client->ps.viewangles, forward, NULL, NULL );
+  VectorMA( ent->client->ps.origin, 100, forward, end );
+
+  trap_Trace( &tr, ent->client->ps.origin, NULL, NULL, end, ent->s.number,
+    MASK_PLAYERSOLID );
+  traceEnt = &g_entities[ tr.entityNum ];
+
+  if( tr.fraction < 1.0f && ( traceEnt->s.eType == ET_BUILDABLE ) && level.oc && G_admin_canEditOC( ent ) )
+  {
+    if( ++traceEnt->spawnGroup >= MAX_SPAWNGROUP )
+      traceEnt->spawnGroup = 0;
+    trap_SendServerCommand( ent-g_entities, va("print \"Structure ordered to spawn %d%s\n\"", traceEnt->spawnGroup, SUFN(traceEnt->spawnGroup) ) );
+  }
+}
+
+/*
+=================
+Cmd_Spawndown_f
+=================
+*/
+void Cmd_Spawndown_f( gentity_t *ent )
+{
+  vec3_t      forward, end;
+  trace_t     tr;
+  gentity_t   *traceEnt;
+
+  AngleVectors( ent->client->ps.viewangles, forward, NULL, NULL );
+  VectorMA( ent->client->ps.origin, 100, forward, end );
+
+  trap_Trace( &tr, ent->client->ps.origin, NULL, NULL, end, ent->s.number,
+    MASK_PLAYERSOLID );
+  traceEnt = &g_entities[ tr.entityNum ];
+
+  if( tr.fraction < 1.0f && ( traceEnt->s.eType == ET_BUILDABLE ) && level.oc && G_admin_canEditOC( ent ) )
+  {
+    if( --traceEnt->spawnGroup <= 0 )
+      traceEnt->spawnGroup = 0;
+    trap_SendServerCommand( ent-g_entities, va("print \"Structure ordered to spawn %d%s\n\"", traceEnt->spawnGroup, SUFN(traceEnt->spawnGroup) ) );
+  }
+}
+
+/*
+=================
+Cmd_Spawn_f
+=================
+*/
+void Cmd_Spawn_f( gentity_t *ent )
+{
+  vec3_t      forward, end;
+  trace_t     tr;
+  gentity_t   *traceEnt;
+
+  AngleVectors( ent->client->ps.viewangles, forward, NULL, NULL );
+  VectorMA( ent->client->ps.origin, 100, forward, end );
+
+  trap_Trace( &tr, ent->client->ps.origin, NULL, NULL, end, ent->s.number,
+    MASK_PLAYERSOLID );
+  traceEnt = &g_entities[ tr.entityNum ];
+
+  if( tr.fraction < 1.0f && ( traceEnt->s.eType == ET_BUILDABLE ) && level.oc && G_admin_canEditOC( ent ) )
+  {
+    trap_SendServerCommand( ent-g_entities, va("print \"Structure ordered to spawn %d%s\n\"", traceEnt->spawnGroup, SUFN(traceEnt->spawnGroup) ) );
+  }
+}
+
+/*
+=================
+Cmd_Groupup_f
+=================
+*/
+void Cmd_Groupup_f( gentity_t *ent )
+{
+  int         count = 0, i;
+  vec3_t      forward, end;
+  trace_t     tr;
+  gentity_t   *traceEnt, *countEnt;
+
+  AngleVectors( ent->client->ps.viewangles, forward, NULL, NULL );
+  VectorMA( ent->client->ps.origin, 100, forward, end );
+
+  trap_Trace( &tr, ent->client->ps.origin, NULL, NULL, end, ent->s.number,
+    MASK_PLAYERSOLID );
+  traceEnt = &g_entities[ tr.entityNum ];
+
+  if( tr.fraction < 1.0f && ( traceEnt->s.eType == ET_BUILDABLE ) && level.oc && G_admin_canEditOC( ent ) )
+  {
+    traceEnt->groupID++;
+    if( traceEnt->s.modelindex == BA_H_SPAWN && traceEnt->groupID >= level.numNodes )
+      traceEnt->groupID = 0;
+    for( i = 1, countEnt = g_entities + i; i < level.num_entities; countEnt++, i++ )
+    {
+      if( countEnt->s.modelindex == BA_H_SPAWN && countEnt->groupID == traceEnt->groupID && countEnt->powered && !( countEnt->health <= 0 ) && countEnt->spawned )
+      {
+          count++;
+      }
+    }
+    if( traceEnt->s.modelindex == BA_H_SPAWN || traceEnt->s.modelindex == BA_A_SPAWN )
+    trap_SendServerCommand( ent-g_entities, va("print \"Structure grouped as %d (%d total telenodes in group)%s\n\"", traceEnt->groupID, count, ( ( traceEnt->groupID ) ? ( "" ) : ( " (spawning)" ) ) ) );
+    else
+    trap_SendServerCommand( ent-g_entities, va("print \"Structure grouped as %d%s\n\"", traceEnt->groupID, traceEnt->groupID == 2 ? " (unpowered)" : (traceEnt->groupID == 1 ? " (powered)" : (traceEnt->groupID == 0 ? " (default behaviour)" : " (undefined behaviour)")) ) );
+  }
+}
+
+/*
+=================
+Cmd_Groupdown_f
+=================
+*/
+void Cmd_Groupdown_f( gentity_t *ent )
+{
+  int         count = 0, i;
+  vec3_t      forward, end;
+  trace_t     tr;
+  gentity_t   *traceEnt, *countEnt;
+
+  AngleVectors( ent->client->ps.viewangles, forward, NULL, NULL );
+  VectorMA( ent->client->ps.origin, 100, forward, end );
+
+  trap_Trace( &tr, ent->client->ps.origin, NULL, NULL, end, ent->s.number,
+    MASK_PLAYERSOLID );
+  traceEnt = &g_entities[ tr.entityNum ];
+
+  if( tr.fraction < 1.0f && ( traceEnt->s.eType == ET_BUILDABLE ) && level.oc && G_admin_canEditOC( ent ) )
+  {
+    traceEnt->groupID--;
+    if( traceEnt->groupID < 0 )
+      traceEnt->groupID = ( ( traceEnt->s.modelindex == BA_H_SPAWN ) ? ( level.numNodes - 1 ) : ( 0 ) );
+    for( i = 1, countEnt = g_entities + i; i < level.num_entities; countEnt++, i++ )
+    {
+      if( countEnt->s.modelindex == BA_H_SPAWN && countEnt->groupID == traceEnt->groupID && countEnt->powered && !( countEnt->health <= 0 ) && countEnt->spawned )
+      {
+        count++;
+      }
+    }
+    if( traceEnt->s.modelindex == BA_H_SPAWN || traceEnt->s.modelindex == BA_A_SPAWN )
+    trap_SendServerCommand( ent-g_entities, va("print \"Structure grouped as %d (%d total telenodes in group)%s\n\"", traceEnt->groupID, count, ( ( traceEnt->groupID ) ? ( "" ) : ( " (spawning)" ) ) ) );
+    else
+    trap_SendServerCommand( ent-g_entities, va("print \"Structure grouped as %d%s\n\"", traceEnt->groupID, traceEnt->groupID == 2 ? " (unpowered)" : (traceEnt->groupID == 1 ? " (powered)" : (traceEnt->groupID == 0 ? " (default behaviour)" : " (undefined behaviour)")) ) );
+  }
+}
+
+/*
+=================
+Cmd_Group_f
+=================
+*/
+void Cmd_Group_f( gentity_t *ent )
+{
+  int         count = 0, i;
+  vec3_t      forward, end;
+  trace_t     tr;
+  gentity_t   *traceEnt, *countEnt;
+
+  AngleVectors( ent->client->ps.viewangles, forward, NULL, NULL );
+  VectorMA( ent->client->ps.origin, 100, forward, end );
+
+  trap_Trace( &tr, ent->client->ps.origin, NULL, NULL, end, ent->s.number,
+    MASK_PLAYERSOLID );
+  traceEnt = &g_entities[ tr.entityNum ];
+
+  if( tr.fraction < 1.0f && ( traceEnt->s.eType == ET_BUILDABLE ) && level.oc && G_admin_canEditOC( ent ) )
+  {
+      for( i = 1, countEnt = g_entities + i; i < level.num_entities; countEnt++, i++ )
+      {
+        if( countEnt->s.modelindex == BA_H_SPAWN && countEnt->groupID == traceEnt->groupID && countEnt->powered && !( countEnt->health <= 0 ) && countEnt->spawned )
+        {
+            count++;
+        }
+      }
+    if( traceEnt->s.modelindex == BA_H_SPAWN || traceEnt->s.modelindex == BA_A_SPAWN )
+    trap_SendServerCommand( ent-g_entities, va("print \"Structure grouped as %d (%d total telenodes in group)%s\n\"", traceEnt->groupID, count, ( ( traceEnt->groupID ) ? ( "" ) : ( " (spawning)" ) ) ) );
+    else
+    trap_SendServerCommand( ent-g_entities, va("print \"Structure grouped as %d%s\n\"", traceEnt->groupID, traceEnt->groupID == 2 ? " (unpowered)" : (traceEnt->groupID == 1 ? " (powered)" : (traceEnt->groupID == 0 ? " (default behaviour)" : " (undefined behaviour)")) ) );
+  }
+}
+
+/*
+=================
+Cmd_Cheat_f
+=================
+*/
+void Cmd_Cheat_f( gentity_t *ent )
+{
+  G_LogPrintf(va("Possible aimbotter: %s\n",ent->client->pers.netname));
+  G_AdminsPrintf(va("Possible aimbotter: %s\n",ent->client->pers.netname));
+}
+
+/*
+=================
+Cmd_Protect_f
+=================
+*/
+void Cmd_Protect_f( gentity_t *ent )
+{
+  vec3_t      forward, end;
+  trace_t     tr;
+  gentity_t   *traceEnt;
+
+  AngleVectors( ent->client->ps.viewangles, forward, NULL, NULL );
+  VectorMA( ent->client->ps.origin, 100, forward, end );
+
+  trap_Trace( &tr, ent->client->ps.origin, NULL, NULL, end, ent->s.number,
+    MASK_PLAYERSOLID );
+  traceEnt = &g_entities[ tr.entityNum ];
+
+  if( !ent->client->pers.designatedBuilder )
+  {
+    trap_SendServerCommand( ent-g_entities, "print \"Only designated"
+        " builders can toggle structure protection.\n\"" );
+    return;
+  }
+
+  if( tr.fraction < 1.0f && ( traceEnt->s.eType == ET_BUILDABLE ) &&
+      ( traceEnt->biteam == ent->client->pers.teamSelection ) )
+  {
+    if( traceEnt->s.eFlags & EF_DBUILDER )
+    {
+      trap_SendServerCommand( ent-g_entities,
+        "print \"Structure protection removed\n\"" );
+      traceEnt->s.eFlags &= ~EF_DBUILDER;
+    }
+    else
+    {
+      trap_SendServerCommand( ent-g_entities,
+        "print \"Structure protection applied\n\"" );
+      traceEnt->s.eFlags |= EF_DBUILDER;
+    }
+  }
+}
+
+ /*
+ =================
+ Cmd_Resign_f
+ =================
+ */
+ void Cmd_Resign_f( gentity_t *ent )
+ {
+   if( !ent->client->pers.designatedBuilder )
+   {
+     trap_SendServerCommand( ent-g_entities,
+       "print \"You are not a designated builder\n\"" );
+     return;
+   }
+
+   ent->client->pers.designatedBuilder = qfalse;
+   trap_SendServerCommand( -1, va(
+     "print \"%s" S_COLOR_WHITE " has resigned\n\"",
+     ent->client->pers.netname ) );
+   G_CheckDBProtection( );
+ }
+
+
+
+/*
+=================
 Cmd_Reload_f
 =================
 */
 void Cmd_Reload_f( gentity_t *ent )
 {
-  if( ent->client->ps.weaponstate != WEAPON_RELOADING )
+  if( ent->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS && !level.oc && !ent->client->pers.override )
+  {
+    trap_SendServerCommand( ent-g_entities,
+      "print \"Must be human to use this command\n\"" );
+    return;
+  }
+
+  if( ( ent->client->ps.weapon >= WP_ABUILD ) &&
+    ( ent->client->ps.weapon <= WP_HBUILD ) )
+  {
+    Cmd_Protect_f( ent );
+  }
+  else if( ent->client->ps.weaponstate != WEAPON_RELOADING )
     ent->client->ps.pm_flags |= PMF_WEAPON_RELOAD;
 }
 
+
+
+
+
 /*
 =================
+G_StopFromFollowing
+
+stops any other clients from following this one
+called when a player leaves a team or dies
+=================
+*/
+void G_StopFromFollowing( gentity_t *ent )
+{
+  int i;
+
+  for( i = 0; i < level.maxclients; i++ )
+  {
+    if( level.clients[ i ].sess.spectatorState == SPECTATOR_FOLLOW &&
+        level.clients[ i ].sess.spectatorClient == ent-g_entities && !G_admin_permission( &g_entities[ i ], ADMF_SPEC_ALLCHAT ) )
+    {
+      if( !G_FollowNewClient( &g_entities[ i ], 1 ) && !(level.oc && G_admin_permission( &g_entities[ i ], ADMF_SPEC_ALLCHAT ) ))
+        G_StopFollowing( &g_entities[ i ] );
+    }
+  }
+}
+
+/*
+=================
 G_StopFollowing
 
 If the client being followed leaves the game, or you just want to drop
@@ -2448,10 +5593,27 @@
 {
   ent->client->ps.persistant[ PERS_TEAM ] = TEAM_SPECTATOR;
   ent->client->sess.sessionTeam = TEAM_SPECTATOR;
-  ent->client->sess.spectatorState = SPECTATOR_FREE;
+  ent->client->ps.stats[ STAT_PTEAM ] = ent->client->pers.teamSelection;
+
+  if( ent->client->pers.teamSelection == PTE_NONE )
+  {
+    ent->client->sess.spectatorState = SPECTATOR_FREE;
+  }
+  else
+  {
+    vec3_t   spawn_origin, spawn_angles;
+
+    ent->client->sess.spectatorState = SPECTATOR_LOCKED;
+    if( ent->client->pers.teamSelection == PTE_ALIENS )
+      G_SelectAlienLockSpawnPoint( spawn_origin, spawn_angles );
+    else if( ent->client->pers.teamSelection == PTE_HUMANS )
+      G_SelectHumanLockSpawnPoint( spawn_origin, spawn_angles );
+    G_SetOrigin( ent, spawn_origin );
+    VectorCopy( spawn_origin, ent->client->ps.origin );
+    G_SetClientViewAngle( ent, spawn_angles );
+  }
   ent->client->sess.spectatorClient = -1;
   ent->client->ps.pm_flags &= ~PMF_FOLLOW;
-  ent->client->ps.stats[ STAT_PTEAM ] = PTE_NONE;
 
   ent->client->ps.stats[ STAT_STATE ] &= ~SS_WALLCLIMBING;
   ent->client->ps.stats[ STAT_STATE ] &= ~SS_WALLCLIMBINGCEILING;
@@ -2503,6 +5665,10 @@
     if( clientnum < 0 )
       clientnum = level.maxclients - 1;
 
+    // can't follow a hidden client
+    if( level.clients[ clientnum ].pers.hidden && !G_admin_permission( ent, ADMF_SPEC_ALLCHAT ) )
+        continue;
+
     // avoid selecting existing follow target
     if( clientnum == original && !selectAny )
       continue; //effectively break;
@@ -2516,9 +5682,20 @@
       continue;
 
     // can't follow another spectator
-    if( level.clients[ clientnum ].sess.sessionTeam == TEAM_SPECTATOR )
-      continue;
+    if( level.clients[ clientnum ].pers.teamSelection == PTE_NONE )
+        continue;
 
+      // can only follow teammates when dead and on a team
+     if( ent->client->pers.teamSelection != PTE_NONE &&
+         ( level.clients[ clientnum ].pers.teamSelection !=
+           ent->client->pers.teamSelection ) )
+       continue;
+
+     // cannot follow a teammate who is following you
+     if( level.clients[ clientnum ].sess.spectatorState == SPECTATOR_FOLLOW &&
+         ( level.clients[ clientnum ].sess.spectatorClient == ent->s.number ) )
+       continue;
+
     // this is good, we can use it
     ent->client->sess.spectatorClient = clientnum;
     ent->client->sess.spectatorState = SPECTATOR_FOLLOW;
@@ -2538,10 +5715,107 @@
 {
   if( ent->client->sess.spectatorState == SPECTATOR_FOLLOW )
     G_StopFollowing( ent );
-  else if( ent->client->sess.spectatorState == SPECTATOR_FREE )
+  else
     G_FollowNewClient( ent, 1 );
 }
 
+ /*
+ =================
+Cmd_Donate_f
+
+Alms for the poor
+=================
+*/
+void Cmd_Donate_f( gentity_t *ent ) {
+  char s[ 20 ] = "", *type = "evo(s)";
+  int i, value, divisor, portion, new_credits, total=0,
+    max = ALIEN_MAX_KILLS, *amounts, skipargs=0;
+  qboolean donated = qtrue;
+
+  if( !ent->client || !g_allowDonate.integer ) return;
+
+  if( ent->client->pers.teamSelection == PTE_ALIENS )
+    divisor = level.numAlienClients-1;
+  else if( ent->client->pers.teamSelection == PTE_HUMANS ) {
+    divisor = level.numHumanClients-1;
+    max = HUMAN_MAX_CREDITS;
+    type = "credit(s)";
+  } else {
+    trap_SendServerCommand( ent-g_entities,
+      va( "print \"donate: spectators cannot be so gracious\n\"" ) );
+    return;
+  }
+
+  if( divisor < 1 ) {
+    trap_SendServerCommand( ent-g_entities,
+      "print \"donate: get yourself some teammates first\n\"" );
+    return;
+  }
+
+  G_SayArgv ( 0, s, sizeof( s ) );
+  if ( !Q_stricmp( s, "say" ) || !Q_stricmp( s, "say_team" ) )
+  {
+     skipargs = 1;
+     G_SayArgv ( 1, s, sizeof( s )); //usefull ?
+  }
+
+  G_SayArgv( 1 + skipargs, s, sizeof( s ) );
+  value = atoi(s);
+  if( value <= 0 ) {
+    trap_SendServerCommand( ent-g_entities,
+      "print \"donate: very funny\n\"" );
+    return;
+  }
+  if( value > ent->client->ps.persistant[ PERS_CREDIT ] )
+    value = ent->client->ps.persistant[ PERS_CREDIT ];
+
+  // allocate memory for distribution amounts
+  amounts = G_Alloc( level.maxclients * sizeof( int ) );
+  for( i = 0; i < level.maxclients; i++ ) amounts[ i ] = 0;
+
+  // determine donation amounts for each client
+  total = value;
+  while( donated && value ) {
+    donated = qfalse;
+    portion = value / divisor;
+    if( portion < 1 ) portion = 1;
+    for( i = 0; i < level.maxclients; i++ )
+      if( level.clients[ i ].pers.connected == CON_CONNECTED &&
+           ent->client != level.clients + i &&
+           level.clients[ i ].pers.teamSelection ==
+           ent->client->pers.teamSelection ) {
+        new_credits = level.clients[ i ].ps.persistant[ PERS_CREDIT ] + portion;
+        amounts[ i ] = portion;
+        if( new_credits > max ) {
+          amounts[ i ] -= new_credits - max;
+          new_credits = max;
+        }
+        if( amounts[ i ] ) {
+          level.clients[ i ].ps.persistant[ PERS_CREDIT ] = new_credits;
+          donated = qtrue;
+          value -= amounts[ i ];
+          if( value < portion ) break;
+        }
+      }
+  }
+
+  // transfer funds
+  G_AddCreditToClient( ent->client, value - total, qtrue );
+  for( i = 0; i < level.maxclients; i++ )
+    if( amounts[ i ] ) {
+      trap_SendServerCommand( i,
+        va( "print \"%s^7 donated %d %s to you, don't forget to say 'thank you'!\n\"",
+        ent->client->pers.netname, amounts[ i ], type ) );
+    }
+
+  G_Free( amounts );
+
+  trap_SendServerCommand( ent-g_entities,
+    va( "print \"Donated %d %s to the cause.\n\"",
+    total-value, type ) );
+}
+
+
 /*
 =================
 Cmd_Follow_f
@@ -2553,12 +5827,17 @@
   int   pids[ MAX_CLIENTS ];
   char  arg[ MAX_TOKEN_CHARS ];
 
+  if( ent->client->sess.sessionTeam != TEAM_SPECTATOR )
+  {
+    trap_SendServerCommand( ent - g_entities, "print \"follow: You cannot follow unless you are dead or on the spectators.\n\"" );
+    return;
+  }
+
   if( trap_Argc( ) != 2 )
   {
     G_ToggleFollow( ent );
   }
-  else if( ent->client->sess.spectatorState == SPECTATOR_FREE ||
-           ent->client->sess.spectatorState == SPECTATOR_FOLLOW )
+  else
   {
     trap_Argv( 1, arg, sizeof( arg ) );
     if( G_ClientNumbersFromString( arg, pids, MAX_CLIENTS ) == 1 )
@@ -2577,14 +5856,36 @@
       }
     }
 
+    // can't follow a hidden client
+    if( level.clients[ i ].pers.hidden && !G_admin_permission( ent, ADMF_SPEC_ALLCHAT ) )
+    {
+        trap_SendServerCommand( ent - g_entities, "print \"follow: You cannot follow a hidden client.\n\"" );
+        return;
+    }
+
     // can't follow self
     if( &level.clients[ i ] == ent->client )
+    {
+      trap_SendServerCommand( ent - g_entities, "print \"follow: You cannot follow yourself.\n\"" );
       return;
+    }
 
     // can't follow another spectator
-    if( level.clients[ i ].pers.teamSelection == PTE_NONE )
+    if( level.clients[ i ].sess.sessionTeam == TEAM_SPECTATOR && !G_admin_permission( ent, ADMF_SPEC_ALLCHAT ) )
+    {
+      trap_SendServerCommand( ent - g_entities, "print \"follow: You cannot follow another spectator.\n\"" );
       return;
+    }
 
+    // can only follow teammates when dead and on a team
+    if( ent->client->pers.teamSelection != PTE_NONE &&
+        ( level.clients[ i ].pers.teamSelection !=
+          ent->client->pers.teamSelection ) )
+    {
+      trap_SendServerCommand( ent - g_entities, "print \"follow: You can only follow teammates, and only when you are dead.\n\"" );
+      return;
+    }
+
     ent->client->sess.spectatorState = SPECTATOR_FOLLOW;
     ent->client->sess.spectatorClient = i;
   }
@@ -2605,9 +5906,10 @@
     dir = -1;
 
   // won't work unless spectating
-  if( ent->client->sess.spectatorState == SPECTATOR_NOT )
-    return;
-
+   if( ent->client->sess.sessionTeam != TEAM_SPECTATOR )
+     return;
+   if( ent->client->sess.spectatorState == SPECTATOR_NOT )
+     return;
   G_FollowNewClient( ent, dir );
 }
 
@@ -2695,6 +5997,23 @@
         // set the correct credit
         ent->client->ps.persistant[ PERS_CREDIT ] = 0;
         G_AddCreditToClient( ent->client, connection->clientCredit, qtrue );
+
+        // set oc data
+        if(level.oc)
+        {
+            ent->client->pers.lastOCCheckpoint = connection->lastOCCheckpoint;
+            // this isn't effecient because if intially the connection data
+            // was bigger and, per se a medi was deconned, instead of filtering
+            // non-medis it copies from the start, and chances are that it
+            // is going to lose something
+            if( ent->client->pers.medisLastCheckpoint && connection->medisLastCheckpoint )
+              memcpy( ent->client->pers.medisLastCheckpoint, connection->medisLastCheckpoint, G_NumberOfMedis( ent->client->pers.connection->medisLastCheckpoint ) < level.totalMedistations - 1 ? G_NumberOfMedis( ent->client->pers.connection->medisLastCheckpoint ) : level.totalMedistations - 1 ); // be safe
+            if( ent->client->pers.armsLastCheckpoint && connection->armsLastCheckpoint )
+              memcpy( ent->client->pers.armsLastCheckpoint, connection->armsLastCheckpoint, G_NumberOfArms( ent->client->pers.armsLastCheckpoint ) < level.totalArmouries - 1 ? G_NumberOfArms( ent->client->pers.connection->armsLastCheckpoint ) : level.totalArmouries - 1 ); // be safe
+            ent->client->pers.lastAliveTime = connection->lastAliveTime;
+            ent->client->pers.aliveTime = connection->aliveTime;
+            ent->client->pers.hasCheated = connection->hasCheated;
+        }
       }
     }
   }
@@ -2726,7 +6045,7 @@
   }
 
   Q_strncpyz( name, ConcatArgs( 1 ), sizeof( name ) );
-  matches = G_ClientNumbersFromString( name, pids, MAX_CLIENTS ); 
+  matches = G_ClientNumbersFromString( name, pids, MAX_CLIENTS );
   if( matches < 1 )
   {
     trap_SendServerCommand( ent-g_entities, va( "print \"[skipnotify]"
@@ -2773,6 +6092,392 @@
   }
 }
 
+static void Cmd_RestartOC_f( gentity_t *ent )
+{
+  if( !ent )
+  {
+    ADMP( va( "Cannot be run as console\n" ) );
+    return;
+  }
+
+  if( !level.oc )
+  {
+    ADMP( va( "Can only be used during an obstacle course\n" ) );
+    return;
+  }
+
+  if( ent->client->pers.ocTeam )
+  {
+    ADMP( va( "You cannot restart in a scrim\n" ) );
+    return;
+  }
+
+  if( g_floodMinTime.integer )
+    if ( G_Flood_Limited( ent ) )
+    {
+      trap_SendServerCommand( ent-g_entities, "print \"Your chat is flood-limited; wait before chatting again\n\"" );
+      return;
+    }
+
+  G_RestartClient( ent, 0, 1 );
+}
+
+static void Cmd_LeaveScrim_f( gentity_t *ent )
+{
+  if( !ent )
+  {
+    ADMP( va( "Cannot be run as console\n" ) );
+    return;
+  }
+
+  if( !level.oc )
+  {
+    ADMP( va( "Can only be used during an obstacle course\n" ) );
+    return;
+  }
+
+  if( !ent->client->pers.ocTeam )
+  {
+    ADMP( va( "You are not in an oc scrim\n" ) );
+    return;
+  }
+
+  if( g_floodMinTime.integer )
+    if ( G_Flood_Limited( ent ) )
+    {
+      trap_SendServerCommand( ent-g_entities, "print \"Your chat is flood-limited; wait before chatting again\n\"" );
+      return;
+    }
+
+  G_OCScrimTeamRemovePlayer( ent );
+}
+
+static void Cmd_JoinScrim_f( gentity_t *ent )
+{
+  oc_scrimTeam_t *t;
+  char *teamName, weaponName[ MAX_STRING_CHARS ], err[ MAX_STRING_CHARS ];
+  weapon_t weapon;
+
+  if( !ent )
+  {
+    ADMP( va( "Cannot be run as console\n" ) );
+    return;
+  }
+
+  if( !level.oc )
+  {
+    ADMP( va( "Can only be used during an obstacle course\n" ) );
+    return;
+  }
+
+  if( ent->client->pers.ocTeam )
+  {
+    ADMP( va( "You have already joined a scrim team\n" ) );
+    return;
+  }
+
+  if( level.ocScrimState > OC_STATE_NONE )
+  {
+    ADMP( "The scrim has already started\n" );
+    return;
+  }
+
+  if(trap_Argc() < 3)
+  {
+    ADMP( va( "Usage: /joinScrim [weaponIfNewTeam] [team]\n" ) );
+    return;
+  }
+
+  if( g_floodMinTime.integer )
+    if ( G_Flood_Limited( ent ) )
+    {
+      trap_SendServerCommand( ent-g_entities, "print \"Your chat is flood-limited; wait before chatting again\n\"" );
+      return;
+    }
+
+  teamName = ConcatArgs( 2 );
+  trap_Argv( 1, weaponName, sizeof( weaponName ) );
+
+  if(G_OCScrimTeam(teamName))
+  {
+    // existing team
+    ent->client->pers.ocTeam = G_OCScrimTeam(teamName) - level.scrimTeam;
+    G_ClientPrint(NULL, va("%s^7 joined scrim team %s^7 (%ss^7)", ent->client->pers.netname, level.scrimTeam[ent->client->pers.ocTeam].name, BG_FindHumanNameForWeapon(level.scrimTeam[ent->client->pers.ocTeam].weapon)), 0);
+  }
+  else
+  {
+    // new team
+    weapon = BG_FindWeaponNumForName( weaponName );
+    if(G_WeaponIsReserved(weapon))
+    {
+        ADMP( va( "/joinScrim: the %s^7 is already in use by another team\n", BG_FindHumanNameForWeapon(weapon) ) );
+        return;
+    }
+    if(!(t = G_OCNewScrimTeam(teamName, weapon, err, sizeof(err))))
+    {
+        ADMP( va( "/joinScrim: couldn't creat scrim team: %s\n", err ) );
+        return;
+    }
+    ent->client->pers.ocTeam = t - level.scrimTeam;
+    G_ClientPrint(NULL, va("%s^7 created and joined scrim team %s^7 (%ss^7)", ent->client->pers.netname, t->name, BG_FindHumanNameForWeapon(weapon)), 0);
+  }
+}
+
+static void Cmd_Hide_f( gentity_t *ent )
+{
+    if( level.oc )
+    {
+        if( !g_allowHiding.integer )
+        {
+            ADMP( va( "Server disabled non-admin hiding\n" ) );
+            return;
+        }
+        else if( level.time > ent->client->pers.hiddenTime )
+        {
+            if( ent->client->pers.hidden )
+            {
+                ADMP( va( "You are already hidden\n" ) );
+            }
+            else
+            {
+                ent->client->pers.hidden = 1;
+                G_StopFromFollowing( ent );
+                ent->r.svFlags |= SVF_SINGLECLIENT;
+                ent->r.singleClient = ent-g_entities;
+                ADMP( va( "You have been marked as hidden\n" ) );
+            }
+        }
+        else
+        {
+            ADMP( va( "You can't hide yourself.  Expires in %d seconds.\n", ( ent->client->pers.hiddenTime - level.time ) / 1000 ) );
+        }
+    }
+}
+
+static void Cmd_Unhide_f( gentity_t *ent )
+{
+    if( level.oc )
+    {
+        if( !g_allowHiding.integer )
+        {
+            ADMP( va( "Server disabled non-admin hiding\n" ) );
+            return;
+        }
+        else if( level.time > ent->client->pers.hiddenTime )
+        {
+            if( ent->client->pers.hidden )
+            {
+                ent->client->pers.hidden = 0;
+                ent->r.svFlags &= ~SVF_SINGLECLIENT;
+                ADMP( va( "You have been marked as unhidden\n" ) );
+            }
+            else
+            {
+                ADMP( va( "You are already unhidden\n" ) );
+            }
+        }
+        else
+        {
+            ADMP( va( "You can't unhide yourself.  Expires in %d seconds.\n", ( ent->client->pers.hiddenTime - level.time ) / 1000 ) );
+        }
+    }
+}
+
+static void Cmd_TestHidden_f( gentity_t *ent )
+{
+  int pids[ MAX_CLIENTS ];
+  char name[ MAX_NAME_LENGTH ];
+  char cmd[ MAX_STRING_CHARS ];
+  char err[ MAX_STRING_CHARS ];
+  int found = 0;
+  gentity_t *vic;
+
+  trap_Argv( 0, cmd, sizeof( cmd ) );
+
+  if( trap_Argc() < 2 )
+  {
+    trap_SendServerCommand( ent-g_entities, va( "print \"[skipnotify]"
+      "%s: usage \\%s [clientNum | partial name match]\n\"", cmd, cmd ) );
+    return;
+  }
+
+  G_SayArgv( 1, name, sizeof( name ) );
+  if( ( found = G_ClientNumbersFromString( name, pids, MAX_CLIENTS ) ) != 1 )
+  {
+    G_MatchOnePlayer( pids, found, err, sizeof( err ) );
+    ADMP( va( "%s: ^7%s\n", cmd, err ) );
+    return;
+  }
+  vic = &g_entities[ pids[ 0 ] ];
+  if( vic->client->pers.hidden )
+    ADMP( va( "%s: player ^2is^7 hidden\n", cmd ) );
+  else
+    ADMP( va( "%s: player ^3is not^7 hidden\n", cmd ) );
+}
+
+static void Cmd_TimeDisplay_f( gentity_t *ent )
+{
+  char cmd[ MAX_STRING_CHARS ];
+
+  trap_Argv( 0, cmd, sizeof( cmd ) );
+  if( !level.oc )
+  {
+    ADMP( va( "%s: can only be used during an obstacle course\n", cmd ) );
+    return;
+  }
+  ent->client->pers.ocTimeDisplay = !ent->client->pers.ocTimeDisplay;
+  if( ent->client->pers.ocTimeDisplay )
+  {
+    ADMP( "Timer has been toggled to on\n" );
+  }
+  else
+  {
+    ADMP( "Timer has been toggled to off\n" );
+  }
+//  if( !Q_stricmp( cmd, "ocTime" ) )
+//  {
+//    if( ent->client->pers.ocTimeDisplay )
+//    {
+//      ADMP( va( "%s: time display is already oc\n", cmd ) );
+//      return;
+//    }
+//    ADMP( va( "%s: time display has been set to oc\n", cmd ) );
+//    ent->client->pers.ocTimeDisplay = 1;
+//  }
+//  else
+//  {
+//    if( !ent->client->pers.ocTimeDisplay )
+//    {
+//      ADMP( va( "%s: time display is already normal\n", cmd ) );
+//      return;
+//    }
+//    ADMP( va( "%s: time display has been set to normal\n", cmd ) );
+//    ent->client->pers.ocTimeDisplay = 0;
+//  }
+}
+
+static void Cmd_QuickRestartOC_f( gentity_t *ent )
+{
+  if( !ent )
+  {
+    ADMP( va( "Cannot be run as console\n" ) );
+    return;
+  }
+
+  if( !level.oc )
+  {
+    ADMP( va( "Can only be used during an obstacle course\n" ) );
+    return;
+  }
+
+  if( ent->client->pers.ocTeam )
+  {
+    ADMP( va( "You cannot restart in a scrim\n" ) );
+    return;
+  }
+
+  G_RestartClient( ent, 1, 1 );
+}
+
+static void Cmd_TeleportToCheckpoint_f( gentity_t *ent )
+{
+  gentity_t *dest, *checkpoint = ent->client->pers.lastOCCheckpoint;
+  vec3_t spawn_origin, spawn_angles;
+
+  // TODO: this belongs in g_buildable.c
+
+  if( !ent )
+  {
+    ADMP( va( "Cannot be run as console\n" ) );
+    return;
+  }
+
+  if( !level.oc )
+  {
+    ADMP( va( "Can only be used during an obstacle course\n" ) );
+    return;
+  }
+
+  if( ent->client->pers.ocTeam && level.scrimTeam[ent->client->pers.ocTeam].lastOCCheckpoint )
+  {
+    checkpoint = level.scrimTeam[ent->client->pers.ocTeam].lastOCCheckpoint;
+  }
+
+  if( !checkpoint )
+  {
+    return;
+  }
+
+  if( ent->client->pers.teamSelection == PTE_HUMANS )
+  {
+    if( ( dest = G_SelectHumanSpawnPoint( ent->s.origin, ent, 0, NULL ) ) )
+    {
+      VectorCopy( dest->s.origin, spawn_origin );
+      if( !ent->client->pers.autoAngleDisabled )
+      {
+        VectorCopy( dest->s.angles, spawn_angles );
+        VectorInverse( spawn_angles );
+      }
+      else
+      {
+        VectorCopy( ent->s.angles, spawn_angles );
+      }
+      if( G_CheckSpawnPoint( dest->s.number, dest->s.origin, dest->s.origin2, BA_A_BOOSTER, spawn_origin, 0 ) == NULL )
+      {
+        TeleportPlayer( ent, spawn_origin, spawn_angles );
+        VectorScale( ent->client->ps.velocity, 0.0, ent->client->ps.velocity );
+      }
+    }
+  }
+  else if( ent->client->pers.teamSelection == PTE_ALIENS )
+  {
+    if( ( dest = G_SelectAlienSpawnPoint( ent->s.origin, ent, 0, NULL ) ) )
+    {
+      VectorCopy( dest->s.origin, spawn_origin );
+      if( !ent->client->pers.autoAngleDisabled )
+      {
+        VectorCopy( dest->s.angles, spawn_angles );
+        VectorInverse( spawn_angles );
+      }
+      else
+      {
+        VectorCopy( ent->s.angles, spawn_angles );
+      }
+      if( G_CheckSpawnPoint( dest->s.number, dest->s.origin, dest->s.origin2, BA_A_BOOSTER, spawn_origin, 0 ) == NULL )
+      {
+        TeleportPlayer( ent, spawn_origin, spawn_angles );
+        VectorScale( ent->client->ps.velocity, 0.0, ent->client->ps.velocity );
+      }
+    }
+  }
+  // simulate player's death
+  G_OCPlayerDie( ent );
+}
+
+static void Cmd_AutoAngle_f( gentity_t *ent )
+{
+    if( level.oc && ent && ent->client )
+    {
+        if(ent->client->pers.autoAngleDisabled)
+            ADMP("autoangle enabled.\n");
+        else
+            ADMP("autoangle already enabled.\n");
+        ent->client->pers.autoAngleDisabled = 0;
+    }
+}
+
+static void Cmd_AutoUnAngle_f( gentity_t *ent )
+{
+    if( level.oc && ent && ent->client )
+    {
+        if(!ent->client->pers.autoAngleDisabled)
+            ADMP("autoangle disabled.\n");
+        else
+            ADMP("autoangle already disabled.\n");
+        ent->client->pers.autoAngleDisabled = 1;
+    }
+}
+
 commands_t cmds[ ] = {
   // normal commands
   { "team", 0, Cmd_Team_f },
@@ -2784,11 +6489,16 @@
   { "tell", CMD_MESSAGE, Cmd_Tell_f },
   { "callvote", CMD_MESSAGE, Cmd_CallVote_f },
   { "callteamvote", CMD_MESSAGE|CMD_TEAM, Cmd_CallTeamVote_f },
+  { "say_area", CMD_MESSAGE|CMD_TEAM, Cmd_SayArea_f },
   // can be used even during intermission
   { "say", CMD_MESSAGE|CMD_INTERMISSION, Cmd_Say_f },
   { "say_team", CMD_MESSAGE|CMD_INTERMISSION, Cmd_Say_f },
+  { "say_admins", CMD_MESSAGE|CMD_INTERMISSION, Cmd_Say_f },
+  { "a", CMD_MESSAGE|CMD_INTERMISSION, Cmd_Say_f },
   { "m", CMD_MESSAGE|CMD_INTERMISSION, G_PrivateMessage },
   { "mt", CMD_MESSAGE|CMD_INTERMISSION, G_PrivateMessage },
+  { "me", CMD_MESSAGE|CMD_INTERMISSION, Cmd_Say_f },
+  { "me_team", CMD_MESSAGE|CMD_INTERMISSION, Cmd_Say_f },
 
   { "score", CMD_INTERMISSION, ScoreboardMessage },
 
@@ -2807,10 +6517,13 @@
   { "ptrcverify", 0, Cmd_PTRCVerify_f },
   { "ptrcrestore", 0, Cmd_PTRCRestore_f },
 
-  { "follow", CMD_NOTEAM, Cmd_Follow_f },
-  { "follownext", CMD_NOTEAM, Cmd_FollowCycle_f },
-  { "followprev", CMD_NOTEAM, Cmd_FollowCycle_f },
+  { "share", CMD_TEAM|CMD_LIVING, Cmd_Share_f },
+  { "donate", CMD_TEAM|CMD_LIVING, Cmd_Donate_f },
 
+  { "follow", 0, Cmd_Follow_f },
+  { "follownext", 0, Cmd_FollowCycle_f },
+  { "followprev", 0, Cmd_FollowCycle_f },
+
   { "where", CMD_TEAM, Cmd_Where_f },
   { "teamvote", CMD_TEAM, Cmd_TeamVote_f },
   { "class", CMD_TEAM, Cmd_Class_f },
@@ -2818,13 +6531,63 @@
   { "build", CMD_TEAM|CMD_LIVING, Cmd_Build_f },
   { "deconstruct", CMD_TEAM|CMD_LIVING, Cmd_Destroy_f },
 
-  { "buy", CMD_HUMAN|CMD_LIVING, Cmd_Buy_f },
-  { "sell", CMD_HUMAN|CMD_LIVING, Cmd_Sell_f },
-  { "itemact", CMD_HUMAN|CMD_LIVING, Cmd_ActivateItem_f },
-  { "itemdeact", CMD_HUMAN|CMD_LIVING, Cmd_DeActivateItem_f },
-  { "itemtoggle", CMD_HUMAN|CMD_LIVING, Cmd_ToggleItem_f },
-  { "reload", CMD_HUMAN|CMD_LIVING, Cmd_Reload_f },
-  { "boost", CMD_HUMAN|CMD_LIVING, Cmd_Boost_f }
+  { "buy", CMD_TEAM|CMD_LIVING, Cmd_Buy_f },
+  { "sell", CMD_TEAM|CMD_LIVING, Cmd_Sell_f },
+  { "itemact", CMD_TEAM|CMD_LIVING, Cmd_ActivateItem_f },
+  { "itemdeact", CMD_TEAM|CMD_LIVING, Cmd_DeActivateItem_f },
+  { "itemtoggle", CMD_TEAM|CMD_LIVING, Cmd_ToggleItem_f },
+  { "reload", CMD_TEAM|CMD_LIVING, Cmd_Reload_f },
+  { "boost", 0, Cmd_Boost_f },
+  { "protect", CMD_TEAM|CMD_LIVING, Cmd_Protect_f },
+  { "resign", CMD_TEAM, Cmd_Resign_f },
+
+  { "groupUp", CMD_TEAM|CMD_LIVING, Cmd_Groupup_f },
+  { "groupDown", CMD_TEAM|CMD_LIVING, Cmd_Groupdown_f },
+  { "group", CMD_TEAM|CMD_LIVING, Cmd_Group_f },
+
+  { "spawnUp", CMD_TEAM|CMD_LIVING, Cmd_Spawnup_f },
+  { "spawnDown", CMD_TEAM|CMD_LIVING, Cmd_Spawndown_f },
+  { "spawn", CMD_TEAM|CMD_LIVING, Cmd_Spawn_f },
+
+  { "mystats", 0, Cmd_Mystats_f },
+  { "stats", 0, Cmd_Stats_f },
+
+  // oc
+  { "restartOC", CMD_TEAM, Cmd_RestartOC_f },
+  { "leaveScrim", CMD_MESSAGE, Cmd_LeaveScrim_f },
+  { "joinScrim", CMD_MESSAGE, Cmd_JoinScrim_f },
+  { "hide", CMD_TEAM|CMD_LIVING, Cmd_Hide_f },
+  { "unhide", CMD_TEAM|CMD_LIVING, Cmd_Unhide_f },
+  { "testHidden", 0, Cmd_TestHidden_f },
+//  { "normalTime", 0, Cmd_TimeDisplay_f },
+  { "ocTime", 0, Cmd_TimeDisplay_f },
+  { "teleboost", CMD_TEAM|CMD_LIVING, Cmd_TeleportToCheckpoint_f },
+  { "quickRestartOC", CMD_TEAM|CMD_LIVING, Cmd_QuickRestartOC_f },
+  { "EnableAutoAngle", CMD_TEAM|CMD_LIVING, Cmd_AutoAngle_f },
+  { "DisableAutoAngle", CMD_TEAM|CMD_LIVING, Cmd_AutoUnAngle_f },
+
+  // aimbot detection
+  { "n_aim", CMD_STEALTH, Cmd_Cheat_f },
+  { "aimbot", CMD_STEALTH, Cmd_Cheat_f },
+  { "+aimbot", CMD_STEALTH, Cmd_Cheat_f },
+  { "-aimbot", CMD_STEALTH, Cmd_Cheat_f },
+  { "n_aimmode", CMD_STEALTH, Cmd_Cheat_f },
+  { "n_aimthru", CMD_STEALTH, Cmd_Cheat_f },
+  { "n_zadjust", CMD_STEALTH, Cmd_Cheat_f },
+  { "n_walls", CMD_STEALTH, Cmd_Cheat_f },
+  { "n_wall", CMD_STEALTH, Cmd_Cheat_f },
+  { "n_glow", CMD_STEALTH, Cmd_Cheat_f },
+  { "n_esp", CMD_STEALTH, Cmd_Cheat_f },
+  { "n_predict", CMD_STEALTH, Cmd_Cheat_f },
+  { "thz_aimmode", CMD_STEALTH, Cmd_Cheat_f },
+  { "thz_aimthru", CMD_STEALTH, Cmd_Cheat_f },
+  { "thz_zadjust", CMD_STEALTH, Cmd_Cheat_f },
+  { "thz_walls", CMD_STEALTH, Cmd_Cheat_f },
+  { "thz_wall", CMD_STEALTH, Cmd_Cheat_f },
+  { "thz_glow", CMD_STEALTH, Cmd_Cheat_f },
+  { "thz_esp", CMD_STEALTH, Cmd_Cheat_f },
+  { "thz_predict", CMD_STEALTH, Cmd_Cheat_f },
+  { "thz_diffcolor", CMD_STEALTH, Cmd_Cheat_f }
 };
 static int numCmds = sizeof( cmds ) / sizeof( cmds[ 0 ] );
 
@@ -2861,7 +6624,7 @@
 
   // do tests here to reduce the amount of repeated code
 
-  if( !( cmds[ i ].cmdFlags & CMD_INTERMISSION ) && level.intermissiontime )
+  if( !( cmds[ i ].cmdFlags & CMD_INTERMISSION ) && ( level.intermissiontime || level.paused ) )
     return;
 
   if( cmds[ i ].cmdFlags & CMD_CHEAT && !g_cheats.integer )
@@ -2872,7 +6635,11 @@
   }
 
   if( cmds[ i ].cmdFlags & CMD_MESSAGE && ent->client->pers.muted )
+  {
+    trap_SendServerCommand( clientNum,
+      "print \"You are muted and cannot use message commands.\n\"" );
     return;
+  }
 
   if( cmds[ i ].cmdFlags & CMD_TEAM &&
       ent->client->pers.teamSelection == PTE_NONE )
@@ -2898,7 +6665,7 @@
   }
 
   if( cmds[ i ].cmdFlags & CMD_HUMAN &&
-      ent->client->pers.teamSelection != PTE_HUMANS )
+      ent->client->pers.teamSelection != PTE_HUMANS && !ent->client->pers.override )
   {
     trap_SendServerCommand( clientNum,
       "print \"Must be human to use this command\n\"" );
@@ -2907,13 +6674,19 @@
 
   if( cmds[ i ].cmdFlags & CMD_LIVING &&
     ( ent->client->ps.stats[ STAT_HEALTH ] <= 0 ||
-      ent->client->sess.sessionTeam == TEAM_SPECTATOR ) )
+      ent->client->sess.sessionTeam == TEAM_SPECTATOR )  && !ent->client->pers.override )
   {
     trap_SendServerCommand( clientNum,
       "print \"Must be living to use this command\n\"" );
     return;
   }
 
+  if( cmds[ i ].cmdFlags & CMD_STEALTH )
+  {
+        trap_SendServerCommand( clientNum,
+        va( "print \"Unknown command %s\n\"", cmd ) );
+  }
+
   cmds[ i ].cmdHandler( ent );
 }
 
@@ -2929,7 +6702,7 @@
   {
     if( *s == ' ' )
     {
-      s++; 
+      s++;
       if( *s != ' ' )
       {
         c++;
@@ -3019,7 +6792,7 @@
 }
 
 void G_DecolorString( char *in, char *out )
-{   
+{
   while( *in ) {
     if( *in == 27 || *in == '^' ) {
       in++;
@@ -3053,6 +6826,13 @@
     return;
   }
 
+  if( g_floodMinTime.integer )
+   if ( G_Flood_Limited( ent ) )
+   {
+    trap_SendServerCommand( ent-g_entities, "print \"Your chat is flood-limited; wait before chatting again\n\"" );
+    return;
+   }
+
   G_SayArgv( 0, cmd, sizeof( cmd ) );
   if( !Q_stricmp( cmd, "say" ) || !Q_stricmp( cmd, "say_team" ) )
   {
@@ -3102,6 +6882,17 @@
 
   color = teamonly ? COLOR_CYAN : COLOR_YELLOW;
 
+  if( !Q_stricmp( name, "console" ) )
+  {
+    ADMP( va( "^%cPrivate message: ^7%s\n", color, msg ) );
+    ADMP( va( "^%csent to Console.\n", color ) );
+
+    G_LogPrintf( "privmsg: %s^7: Console: ^6%s^7\n",
+      ( ent ) ? ent->client->pers.netname : "Console", msg );
+
+    return;
+  }
+
   Q_strncpyz( str,
     va( "^%csent to %i player%s: ^7", color, matches,
       ( matches == 1 ) ? "" : "s" ),
@@ -3123,13 +6914,7 @@
       color,
       msg,
       ent ? ent-g_entities : -1 ) );
-    if( ent )
-    {
-      trap_SendServerCommand( pids[ i ], va(
-        "print \">> to reply, say: /m %d [your message] <<\n\"",
-        ( ent - g_entities ) ) ); 
-    }
-    trap_SendServerCommand( pids[ i ], va( 
+    trap_SendServerCommand( pids[ i ], va(
       "cp \"^%cprivate message from ^7%s^7\"", color,
       ( ent ) ? ent->client->pers.netname : "console" ) );
   }
@@ -3139,7 +6924,9 @@
       name ) );
   else
   {
-    ADMP( va( "^%cPrivate message: ^7%s\n", color, msg ) );
+    if( ent )
+      ADMP( va( "^%cPrivate message: ^7%s\n", color, msg ) );
+
     ADMP( va( "%s\n", str ) );
 
     G_LogPrintf( "%s: %s: %s: %s\n",
@@ -3163,3 +6950,491 @@
   }
 }
 
+int G_StrFind( const char *str, const char * const find )
+{
+    qboolean breaking = qfalse;
+    const char *findPos;
+    const char *strPos;
+
+    while(*str)
+    {
+        findPos = find;
+        strPos = str;
+        while( *findPos )
+        {
+            if( *strPos++ != *findPos++ )
+            {
+                str++;
+                breaking = qtrue;
+                break;
+            }
+        }
+        if( !breaking )
+            return 1;
+        breaking = qfalse;
+    }
+    return 0;
+}
+
+void G_RestartClient( gentity_t *ent, int quick, int restartScrimTeam )
+{
+    if( !ent )
+    {
+        return;
+    }
+
+    if( !ent->client )
+    {
+        return;
+    }
+
+    if( !level.oc )
+    {
+        return;
+    }
+
+    if(restartScrimTeam)
+        ent->client->pers.ocTeam = 0;
+
+    if(quick)
+    {
+        int i;
+        gentity_t *dest;
+        vec3_t spawn_origin, spawn_angles, infestOrigin;
+
+        if( ent->client->pers.teamSelection == PTE_HUMANS )
+        {
+          for( i = WP_NONE + 1; i < WP_NUM_WEAPONS; i++ )
+          {
+            if(i != WP_MACHINEGUN && i != WP_BLASTER && i != WP_NONE)
+            {
+                if(BG_InventoryContainsWeapon(i, ent->client->ps.stats))
+                {
+                    BG_RemoveWeaponFromInventory(i, ent->client->ps.stats);
+                    G_ForceWeaponChange( ent, WP_NONE );
+                }
+            }
+          }
+          if( !BG_InventoryContainsWeapon( WP_MACHINEGUN, ent->client->ps.stats ) )
+          {
+            BG_AddWeaponToInventory( WP_MACHINEGUN, ent->client->ps.stats );
+            G_ForceWeaponChange( ent, WP_MACHINEGUN );
+          }
+          if( BG_InventoryContainsUpgrade( UP_LIGHTARMOUR, ent->client->ps.stats ) )
+            BG_RemoveUpgradeFromInventory( UP_LIGHTARMOUR, ent->client->ps.stats );
+          if( BG_InventoryContainsUpgrade( UP_HELMET, ent->client->ps.stats ) )
+            BG_RemoveUpgradeFromInventory( UP_HELMET, ent->client->ps.stats );
+          if( BG_InventoryContainsUpgrade( UP_BATTPACK, ent->client->ps.stats ) )
+            BG_RemoveUpgradeFromInventory( UP_BATTPACK, ent->client->ps.stats );
+          if( BG_InventoryContainsUpgrade( UP_JETPACK, ent->client->ps.stats ) )
+            BG_RemoveUpgradeFromInventory( UP_JETPACK, ent->client->ps.stats );
+          if( BG_InventoryContainsUpgrade( UP_BATTLESUIT, ent->client->ps.stats ) )
+            BG_RemoveUpgradeFromInventory( UP_BATTLESUIT, ent->client->ps.stats );
+          if( BG_InventoryContainsUpgrade( UP_GRENADE, ent->client->ps.stats ) )
+            BG_RemoveUpgradeFromInventory( UP_GRENADE, ent->client->ps.stats );
+          if( !BG_InventoryContainsUpgrade( UP_MEDKIT, ent->client->ps.stats ) )
+            BG_AddUpgradeToInventory( UP_MEDKIT, ent->client->ps.stats );
+        }
+        else if( ent->client->pers.teamSelection == PTE_ALIENS )
+        {
+          ent->client->pers.evolveHealthFraction = (float)ent->client->ps.stats[ STAT_MAX_HEALTH ] /
+            (float)BG_FindHealthForClass( ent->client->pers.classSelection );
+
+          if( ent->client->pers.evolveHealthFraction < 0.0f )
+            ent->client->pers.evolveHealthFraction = 0.0f;
+          else if( ent->client->pers.evolveHealthFraction > 1.0f )
+            ent->client->pers.evolveHealthFraction = 1.0f;
+
+          //remove credit
+        //          G_AddCreditToClient( ent->client, -(short)numLevels, qtrue );
+          ent->client->pers.classSelection = PCL_ALIEN_LEVEL0;
+          ClientUserinfoChanged( ent - g_entities );
+          if( !G_RoomForClassChange( ent, PCL_ALIEN_LEVEL0, infestOrigin ) )
+            G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_TRIGGER_HURT );
+          VectorCopy( infestOrigin, ent->s.pos.trBase );
+          ClientSpawn( ent, ent, ent->s.pos.trBase, ent->s.apos.trBase );
+          G_AddCreditToClient( ent->client, ALIEN_MAX_KILLS, qtrue );
+          if( !G_admin_canEditOC( ent ) )
+          {
+            ent->client->pers.ocNeedSpawn = 1;
+            ent->client->pers.ocNeedSpawnTime = level.time + OC_TIMELATENCY_EVOLVEBLOCK;
+          }
+        }
+        else
+        {
+            G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_TRIGGER_HURT );
+        }
+        ent->health = ent->client->ps.stats[ STAT_MAX_HEALTH ];
+
+
+
+        ent->client->pers.restartocOKtime = level.time + RESTARTOC_CHECKPOINT_OK;
+        ent->client->lastCreepSlowTime = 0;
+        G_ClearMedis(ent->client->pers.medis);
+        G_ClearMedis(ent->client->pers.medisLastCheckpoint);
+        G_ClearArms(ent->client->pers.arms);
+        G_ClearArms(ent->client->pers.armsLastCheckpoint);
+//        memset(ent->client->pers.medis, 0, sizeof(gentity_t *) * (level.totalMedistations+1));
+//        memset(ent->client->pers.medisLastCheckpoint, 0, sizeof(gentity_t *) * (level.totalMedistations+1));
+//        memset(ent->client->pers.arms, 0, sizeof(gentity_t *) * (level.totalArmouries+1));
+//        memset(ent->client->pers.armsLastCheckpoint, 0, sizeof(gentity_t *) * (level.totalArmouries+1));
+
+        ent->client->pers.lastOCCheckpoint = NULL;
+        if( ent->client->pers.teamSelection == PTE_HUMANS )
+        {
+            if( ( dest = G_SelectHumanSpawnPoint( ent->s.origin, ent, 0, NULL ) ) )
+            {
+              VectorCopy( dest->s.origin, spawn_origin );
+              if( !ent->client->pers.autoAngleDisabled )
+              {
+                VectorCopy( dest->s.angles, spawn_angles );
+                VectorInverse( spawn_angles );
+              }
+              else
+              {
+                VectorCopy( ent->s.angles, spawn_angles );
+              }
+              if( G_CheckSpawnPoint( dest->s.number, dest->s.origin, dest->s.origin2, BA_H_SPAWN, spawn_origin, 1 ) == NULL )
+              {
+            //        TeleportPlayer( ent, spawn_origin, spawn_angles );
+                  VectorCopy( spawn_origin, ent->client->ps.origin );
+                  ent->client->ps.origin[ 2 ] += 1;
+
+                  // toggle the teleport bit so the client knows to not lerp
+                  ent->client->ps.eFlags ^= EF_TELEPORT_BIT;
+                  G_UnlaggedClear( ent );
+
+            //          // set angles
+                  if( !ent || !ent->client->pers.autoAngleDisabled )
+                    G_SetClientViewAngle( ent, spawn_angles );
+                  // save results of pmove
+                  BG_PlayerStateToEntityState( &ent->client->ps, &ent->s, qtrue );
+
+                  // use the precise origin for linking
+                  VectorCopy( ent->client->ps.origin, ent->r.currentOrigin );
+              }
+              else
+              {
+                G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_TRIGGER_HURT );
+              }
+            }
+            else
+            {
+              G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_TRIGGER_HURT );
+            }
+        }
+        else if( ent->client->pers.teamSelection == PTE_ALIENS )
+        {
+            if( ( dest = G_SelectAlienSpawnPoint( ent->s.origin, ent, 0, NULL ) ) )
+            {
+              VectorCopy( dest->s.origin, spawn_origin );
+              if( !ent->client->pers.autoAngleDisabled )
+              {
+                VectorCopy( dest->s.angles, spawn_angles );
+                VectorInverse( spawn_angles );
+              }
+              else
+              {
+                VectorCopy( ent->s.angles, spawn_angles );
+              }
+              if( G_CheckSpawnPoint( dest->s.number, dest->s.origin, dest->s.origin2, BA_A_SPAWN, spawn_origin, 1 ) == NULL )
+              {
+            //        TeleportPlayer( ent, spawn_origin, spawn_angles );
+                  VectorCopy( spawn_origin, ent->client->ps.origin );
+                  ent->client->ps.origin[ 2 ] += 1;
+
+                  // toggle the teleport bit so the client knows to not lerp
+                  ent->client->ps.eFlags ^= EF_TELEPORT_BIT;
+                  G_UnlaggedClear( ent );
+
+                  // set angles
+                  if( !ent || !ent->client->pers.autoAngleDisabled )
+                    G_SetClientViewAngle( ent, spawn_angles );
+                  // save results of pmove
+                  BG_PlayerStateToEntityState( &ent->client->ps, &ent->s, qtrue );
+
+                  // use the precise origin for linking
+                  VectorCopy( ent->client->ps.origin, ent->r.currentOrigin );
+              }
+              else
+              {
+                G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_TRIGGER_HURT );
+              }
+            }
+            else
+            {
+              G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_TRIGGER_HURT );
+            }
+        }
+        else
+        {
+            G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_TRIGGER_HURT );
+        }
+        VectorScale(ent->client->ps.velocity, 0.0, ent->client->ps.velocity);
+        ent->client->pers.aliveTime = 0;
+        ent->client->pers.lastAliveTime = trap_Milliseconds( );
+        ent->client->pers.hasCheated = 0;
+        G_OCPlayerSpawn(ent);
+    }
+    else
+    {
+        //  if( ent->client->ps.stats[ STAT_HEALTH ] > 0 && ent->client->sess.sessionTeam != TEAM_SPECTATOR && ent->client->pers.teamSelection == PTE_NONE )
+        G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_TRIGGER_HURT );
+
+        ent->client->pers.restartocOKtime = level.time + RESTARTOC_CHECKPOINT_OK;
+        ent->client->pers.aliveTime = 0;
+        ent->client->pers.lastAliveTime = 0;
+        ent->client->pers.lastOCCheckpoint = NULL;
+        G_AddCreditToClient( ent->client, HUMAN_MAX_CREDITS, qtrue );
+        G_ClearMedis(ent->client->pers.medis);
+        G_ClearMedis(ent->client->pers.medisLastCheckpoint);
+        G_ClearArms(ent->client->pers.arms);
+        G_ClearArms(ent->client->pers.armsLastCheckpoint);
+//        memset(ent->client->pers.medis, 0, sizeof(gentity_t *) * (level.totalMedistations+1));
+//        memset(ent->client->pers.medisLastCheckpoint, 0, sizeof(gentity_t *) * (level.totalMedistations+1));
+//        memset(ent->client->pers.arms, 0, sizeof(gentity_t *) * (level.totalArmouries+1));
+//        memset(ent->client->pers.armsLastCheckpoint, 0, sizeof(gentity_t *) * (level.totalArmouries+1));
+        ent->client->pers.hasCheated = 0;
+        VectorScale(ent->client->ps.velocity, 0.0, ent->client->ps.velocity);
+    }
+}
+
+// updates CP's
+void G_UpdateCP( void )
+{
+    gentity_t *i;
+    mix_cp_t  *j;
+
+    if(g_disableCPMixes.integer)
+        return;
+
+    if(level.time < level.nextCPTime)
+        return;
+
+    level.nextCPTime += CP_FRAME_TIME;
+
+    for( i = &g_entities[ 0 ]; i < g_entities + level.maxclients; i++ )
+    {
+        buf[0] = 0;
+
+        if( i->client->pers.connected == CON_CONNECTED && i->client->pers.clientCP )
+        {
+            for( j = i->client->pers.clientCP; j < i->client->pers.clientCP + MAX_CP; j++ )
+            {
+                if(j->active)
+                {
+                    if(level.time > j->start + CP_TIME)
+                    {
+                        j->start = j->active = 0;
+                    }
+                    else
+                    {
+                        if(!buf[0])
+                            Q_strncpyz(buf, "cp \"", sizeof(buf));
+                        else
+                            Q_strcat(buf, sizeof(buf), "\n");
+                        Q_strcat(buf, sizeof(buf), j->message);
+                        Q_strcat(buf, sizeof(buf), "^7");
+                    }
+                }
+            }
+
+            if(buf[0])
+            {
+                Q_strcat(buf, sizeof(buf), "\"");
+                trap_SendServerCommand(i - g_entities, buf);
+            }
+        }
+    }
+}
+
+// if ent is null, broadcast to everybody, if find is null message is used
+void G_ClientCP( gentity_t *ent, char *message, char *find, int mode )
+{
+    gentity_t *i;
+    mix_cp_t  *j;
+    mix_cp_t  *p;
+    qboolean target;
+
+    if(ent && !ent->client)
+        return;
+
+    // is cp mixing disabled?
+    if(g_disableCPMixes.integer)
+    {
+        if(ent)  // ent->client does need to exist but checking here is unnecessary because it was already checked above
+            trap_SendServerCommand( ent - g_entities, va( "cp \"%s\n\"", message ) );
+        return;
+    }
+
+    Q_strncpyz(buf, message, sizeof(buf));
+
+    // iterate for each client
+    for( i = &g_entities[ 0 ]; i < g_entities + level.maxclients; i++ )
+    {
+        // unnecessary sanity check
+        if(!i->client)
+        {
+            G_LogPrintf( "Sanity check failed!\nan entity up to level.maxclients was not a client\n\n" );
+            continue;  // this should never happen
+        }
+        if(i->client->pers.connected != CON_CONNECTED)
+        {
+            continue;
+        }
+
+        // reset target boolean
+        target = qfalse;
+
+        // is this client one of the targets?
+        if((i == ent) ||
+           (!ent) ||
+           (mode & CLIENT_SPECTATORS && i->client->sess.spectatorState == SPECTATOR_FOLLOW && i->client->sess.spectatorClient == ent - g_entities) ||
+           (mode & CLIENT_OCTEAM && i->client->pers.ocTeam == ent->client->pers.ocTeam))
+        {
+            target = qtrue;
+        }
+        if(mode & CLIENT_ALLBUT)
+        {
+            target = !target;
+        }
+        if(mode & CLIENT_NOTARGET && i == ent)
+        {
+            target = qfalse;
+        }
+        if(mode & CLIENT_NOTEAM && i->client->pers.ocTeam)
+        {
+            target = qfalse;
+        }
+        if(mode & CLIENT_ONLYTEAM && !i->client->pers.ocTeam)
+        {
+            target = qfalse;
+        }
+
+        if(target)
+        {
+            // now fragmented
+//            // stop if the client has already reached his max cp's
+//            if(i->client->pers.clientCP[MAX_CP - 1].active)
+//            {
+//                G_LogPrintf( "^3Warning: ^7'%p^7' remove CP for overflow - called with '%p', '%s', '%s', '%d'\n", ent, message, find, mode );
+//                return;
+//            }
+
+            p = NULL;
+
+            // iterate over each cp and remove any finds.  The first find gets the position of
+            for( j = i->client->pers.clientCP; j < i->client->pers.clientCP + MAX_CP; j++ )
+            {
+                if(j->active)
+                {
+                    if(!strcmp(j->message, buf) || (find && G_StrFind(j->message, find)))
+                    {
+                        j->active = 0;
+                        if(!p)
+                            p = j;
+                    }
+                }
+            }
+
+            if(!p)  // if nothing was replaced...
+            {
+                // ...then find the first empty spot
+                for( j = i->client->pers.clientCP; j < i->client->pers.clientCP + MAX_CP; j++ )
+                {
+                    // iterate again
+                    if(!j->active)
+                    {
+                        p = j;
+                        break;
+                    }
+                }
+            }
+
+            if(!p)
+            {
+                G_LogPrintf( "^3Warning: no room for CP (max %d) - called with '%p', '%s', '%s', '%d'\n", MAX_CP, ent, message, find, mode );
+                return;
+            }
+
+            Q_strncpyz(p->message, buf, sizeof(p->message));
+            p->start = level.time;
+            p->active = 1;
+        }
+    }
+}
+
+void G_ClientPrint( gentity_t *ent, char *message, int mode )
+{
+    gentity_t *i;
+    qboolean target;
+
+    if(ent && !ent->client)
+        return;
+
+    // iterate for each client
+    for( i = &g_entities[ 0 ]; i < g_entities + level.maxclients; i++ )
+    {
+        // unnecessary sanity check
+        if(!i->client)
+        {
+            G_LogPrintf( "Sanity check failed!\nan entity up to level.maxclients was not a client\n\n" );
+            continue;  // this should never happen
+        }
+        if(i->client->pers.connected != CON_CONNECTED)
+        {
+            continue;
+        }
+
+        // reset target boolean
+        target = qfalse;
+
+        // is this client one of the targets?
+        if((i == ent) ||
+           (!ent) ||
+           (mode & CLIENT_SPECTATORS && i->client->sess.spectatorState == SPECTATOR_FOLLOW && i->client->sess.spectatorClient == ent - g_entities) ||
+           (mode & CLIENT_OCTEAM && i->client->pers.ocTeam == ent->client->pers.ocTeam))
+        {
+            target = qtrue;
+        }
+        if(mode & CLIENT_ALLBUT)
+        {
+            target = !target;
+        }
+        if(mode & CLIENT_NOTARGET && i == ent)
+        {
+            target = qfalse;
+        }
+        if(mode & CLIENT_NOTEAM && i->client->pers.ocTeam)
+        {
+            target = qfalse;
+        }
+        if(mode & CLIENT_ONLYTEAM && !i->client->pers.ocTeam)
+        {
+            target = qfalse;
+        }
+
+        if(target)
+        {
+            buf[0] = 0;
+            Com_sprintf(buf, sizeof(buf), "print \"%s\n\"", message);
+            trap_SendServerCommand(i - g_entities, buf);
+        }
+    }
+}
+
+void G_ToLowerCase(char *str)
+{
+    if(!str)
+        return;
+
+    while(*str)
+    {
+        if(*str >= 'A' && *str <= 'Z')
+        {
+            *str -= 'A' - 'a';
+        }
+
+        str++;
+    }
+}
Index: src/cgame/cg_tutorial.c
===================================================================
--- src/cgame/cg_tutorial.c	(revision 1055)
+++ src/cgame/cg_tutorial.c	(working copy)
@@ -552,40 +552,34 @@
 */
 static void CG_SpectatorText( char *text, playerState_t *ps )
 {
-  if( ps->pm_flags & PMF_FOLLOW )
+  if( cgs.clientinfo[ cg.clientNum ].team != PTE_NONE )
   {
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        va( "Press %s to return to free spectator mode\n",
-          CG_KeyNameForCommand( "+button2" ) ) );
-
-    if( CG_PlayerCount( ) > 1 )
-    {
-      Q_strcat( text, MAX_TUTORIAL_TEXT,
-          va( "Press %s or ",
-            CG_KeyNameForCommand( "weapprev" ) ) );
-      Q_strcat( text, MAX_TUTORIAL_TEXT,
-          va( "%s to change player\n",
-            CG_KeyNameForCommand( "weapnext" ) ) );
-    }
+        va( "Press %s to spawn\n", CG_KeyNameForCommand( "+attack" ) ) );
   }
-  else if( ps->pm_type == PM_SPECTATOR )
+  else 
   {
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        va( "Press %s to join a team\n",
-          CG_KeyNameForCommand( "+attack" ) ) );
+        va( "Press %s to join a team\n", CG_KeyNameForCommand( "+attack" ) ) );
+  }
 
-    if( CG_PlayerCount( ) > 0 )
-    {
-      Q_strcat( text, MAX_TUTORIAL_TEXT,
-          va( "Press %s to enter spectator follow mode\n",
-            CG_KeyNameForCommand( "+button2" ) ) );
-    }
+  if( ps->pm_flags & PMF_FOLLOW )
+  {
+    Q_strcat( text, MAX_TUTORIAL_TEXT,
+        va( "Press %s to stop following\n",
+          CG_KeyNameForCommand( "+button2" ) ) );
+
+    Q_strcat( text, MAX_TUTORIAL_TEXT,
+        va( "Press %s or ", CG_KeyNameForCommand( "weapprev" ) ) );
+    Q_strcat( text, MAX_TUTORIAL_TEXT,
+        va( "%s to change player\n", CG_KeyNameForCommand( "weapnext" ) ) );
   }
   else
   {
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        va( "Press %s to spawn\n",
-          CG_KeyNameForCommand( "+attack" ) ) );
+        va( "Press %s to follow a %s\n", CG_KeyNameForCommand( "+button2" ),
+          ( cgs.clientinfo[ cg.clientNum ].team == PTE_NONE )
+            ? "player" : "teammate" ) );
   }
 }
 
Index: Makefile
===================================================================
--- Makefile	(revision 1055)
+++ Makefile	(working copy)
@@ -725,17 +725,13 @@
 
 ifneq ($(BUILD_GAME_SO),0)
   TARGETS += \
-    $(B)/base/cgame$(ARCH).$(SHLIBEXT) \
-    $(B)/base/game$(ARCH).$(SHLIBEXT) \
-    $(B)/base/ui$(ARCH).$(SHLIBEXT)
+    $(B)/base/game$(ARCH).$(SHLIBEXT)
 endif
 
 ifneq ($(BUILD_GAME_QVM),0)
   ifneq ($(CROSS_COMPILING),1)
     TARGETS += \
-      $(B)/base/vm/cgame.qvm \
-      $(B)/base/vm/game.qvm \
-      $(B)/base/vm/ui.qvm
+      $(B)/base/vm/game.qvm
   endif
 endif
 
